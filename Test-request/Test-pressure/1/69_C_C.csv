,index,languageName,submissionId,submitTime,userName,statusMessage,code
0,C,C(gcc 7.5.0),61483883,2023-03-24 19:55:05,小憕666,答案错误,"#include <stdio.h>
#include <math.h>
long long point[10][5];
int n, t, p;
long long max_point=0;
long long cal_point(int n, int nowtime)
{
	long long tem=point[n][0]-point[n][1]*nowtime-point[n][4]*p;
	return point[n][2]>tem(?)point[n][2]:tem;
}
void backtrack(int now, int nowtime, long long nowpoint)
{
    if(now<n)
    {
        for(int i=now; i<n; i++)
        {
            if(nowtime+point[i][3]<=t)
            {
                nowtime+=point[i][3];
                nowpoint+=cal_point(i, nowtime);
            }
            
            backtrack(i+1, nowtime, nowpoint);
            
        }
    }
    else
    {
        if(nowpoint>max_point)
            max_point=nowpoint;
    }
}


int main(void)
{
    scanf(""%d%d%d"", &n, &t, &p);
    
    for(int i=0; i<n; i++)
        for(int j=0; j<5; j++)
        	scanf(""%lld"", &point[i][j]);
    
    backtrack(0, 0, 0);
    
    printf(""%lld"", max_point);
    
    
}"
1,C,C(gcc 7.5.0),61484092,2023-03-24 19:56:41,小郭同学401564,答案错误,"#include<stdio.h>
#include<math.h>
#include<string.h>
long long n,t,pp;
long long a[10];
long long max;
struct ffff
{
    long long a;
    long long b;
    long long c;
    long long x;
    long long y;
}p[11];

long long maxx(long long xxx,long long yyy)
{
    return xxx>yyy(?)xxx:yyy;
}

void dfs(long long ti)
{
        long long sum=0,time=0;
        for(long long j=0;j<n;j++)
        {
            
            if(a[j])
            {
                time+=p[j].x;
                sum+=maxx(p[j].c,p[j].a-time*p[j].b-p[j].y*pp);
            }
        }
        max=maxx(max,sum);
    for(long long i=0;i<n;i++)
    {
        if(!a[i]&&p[i].x<=ti)
        {
            a[i]=1;
            dfs(ti-p[i].x);
            a[i]=0;
        }
    }
}

int  main()
{
    scanf(""%lld%lld%lld"",&n,&t,&pp);
    for(long long i=0;i<n;i++)
    scanf(""%lld%lld%lld%lld%lld"",&p[i].a,&p[i].b,&p[i].c,&p[i].x,&p[i].y);
    dfs(t);
    printf(""%lld"",max);
}"
2,C,C,61486554,2023-03-24 20:16:26,牛客20220304118,答案错误,"#include <stdio.h>
#include <stdlib.h>
long long p;
struct niuniu{
	long long a;
	long long b;
	long long c;
	long long x;
	long long y;
};
long long my_max(long long a,long long b){
	return a>b(?)a:b;
}
int cmp(const void*j,const void*k){
	if(my_max((*(struct niuniu*)j).c,(*(struct niuniu*)j).a
	-(*(struct niuniu*)j).x*(*(struct niuniu*)j).b-
	(*(struct niuniu*)j).y*p)<
	my_max((*(struct niuniu*)j).c,(*(struct niuniu*)j).a
	-(*(struct niuniu*)j).x*(*(struct niuniu*)j).b-
	(*(struct niuniu*)j).y*p)){
		return 1;
	}
	else if(my_max((*(struct niuniu*)j).c,(*(struct niuniu*)j).a
	-(*(struct niuniu*)j).x*(*(struct niuniu*)j).b-
	(*(struct niuniu*)j).y*p)==
	my_max((*(struct niuniu*)j).c,(*(struct niuniu*)j).a
	-(*(struct niuniu*)j).x*(*(struct niuniu*)j).b-
	(*(struct niuniu*)j).y*p)){
		return (*(struct niuniu*)j).x<(*(struct niuniu*)j).x;
	}
	return 0;
}
int main()
{
	long long n,t,i,j,sum=0,t0=0,t1=0;
	scanf(""%lld %lld %lld"",&n,&t,&p);
	struct niuniu arr[n];
	for(i=0;i<n;i++){
		scanf(""%lld %lld %lld %lld %lld"",&arr[i].a,
		&arr[i].b,&arr[i].c,&arr[i].x,&arr[i].y);
	}
	qsort(arr,n,sizeof(struct niuniu),cmp);
//	for(i=0;i<n;i++){
//		printf(""%lld\n"",arr[i].a);
//	}
//	printf(""t0=%lld\n"",arr[2].a-arr[2].x*arr[2].b-arr[2].y*p);
	for(i=0;i<n;i++){
		if(t>=arr[i].x){
			t0+=arr[i].x;
//			t1+=arr[i].y;
//			printf(""max=%lld\n"",my_max(arr[i].c,arr[i].a-t0*
//			arr[i].b-t1*p));
			sum+=my_max(arr[i].c,arr[i].a-t0*arr[i].b
			-arr[i].y*p);
			t-=arr[i].x;	
		}
//		printf(""t=%lld\t"",t);
//		printf(""sum=%lld\n"",sum);
	}
	printf(""%lld"",sum);
	return 0;
}"
3,C,C(gcc 7.5.0),61486938,2023-03-24 20:19:45,小憕666,运行超时,"#include <stdio.h>
#include <math.h>
long long point[10][5];
_Bool if_reach[10];
int n, t, p;
long long max_point=0;
long long cal_point(int n, int nowtime)
{
	long long tem=point[n][0]-point[n][1]*nowtime-point[n][4]*p;
	return point[n][2]>tem(?)point[n][2]:tem;
}
void backtrack(int nowtime, long long nowpoint)
{
    int count=0;
    int go[10];
    for(int i=0; i<n; i++)
    	if(if_reach[i]==0)
    		go[count++]=i;
    	
	if(count)
	{
		for(int i=0; i<count; i++)
    	{
       		int tag=0;
           if(if_reach[go[i]]==0 && nowtime+point[go[i]][3]<=t)
            {
                nowtime+=point[go[i]][3];
                nowpoint+=cal_point(go[i], nowtime);
                tag=1;
            }
            
            if_reach[go[i]]=1;
            backtrack(nowtime, nowpoint);
            
            if(tag)
        	{
	            nowpoint-=cal_point(i, nowtime);
	            nowtime-=point[i][3];
			}
			
			if_reach[i]=0;
        }
        
        for(int i=0; i<count; i++)
        	if_reach[go[i]]=0;
	}	
    else
        if(nowpoint>max_point)
            max_point=nowpoint;
}


int main(void)
{
    scanf(""%d%d%d"", &n, &t, &p);
    
    for(int i=0; i<n; i++)
        for(int j=0; j<5; j++)
        	scanf(""%lld"", &point[i][j]);
    
    backtrack(0, 0);
    
    printf(""%lld"", max_point);
    
    
}"
4,C,C,61489929,2023-03-24 20:44:40,lvzufeng,答案错误,"#include<stdio.h>
struct A{
	int a;
	int b;
	int c;
	int x;
	int y;
	int vis;
}sco[15];
int ans = 0;
int at=0;
int cc = 1;
int anss[400000];
int n,t,p;
int max(int a,int b)
{
	if(a>=b)return a;
	else return b;
}
void change(int a, int b,int anss[]){
	int t;
	t=anss[a];
	anss[a]=anss[b];
	anss[b]= t;
}
void qsort(int l, int r){
	int y = r,x=l;
	int mid= anss[(x+y)/2];
    while(x<=y){
    	while(anss[x]<mid){
    		x++;
		}
		while(anss[y]>mid){
			y--;
		}
		if(x<=y) {
		change(x,y,anss);
		x++;
		y--;}}
	if(l<y)	qsort(l,y);
	if(x<r)	qsort(x,r);
	}
void dfs(int cnt,int t,int ans,int at )
{
	int nt = t-sco[cnt].x;
	if(nt<0) 
	{
		anss[cc++]=ans;	
		return;
	}
	else if(sco[cnt].vis==1) 
	{
		nt = nt+sco[cnt].x;
	}
	else
		{
			sco[cnt].vis = 1;
			at+= sco[cnt].x;
			ans+= max(sco[cnt].c,sco[cnt].a-sco[cnt].b*at-sco[cnt].y*p);
		}
	int i;
	for(i=1;i<=n;i++)
	{
		if(sco[i].vis==0)
		{
		dfs(i,nt,ans,at);
		sco[i].vis = 0;
	}
	}
}
int main()
{
	scanf(""%d%d%d"",&n,&t,&p);
	int i;
	for(i=1;i<=n;i++)
	{
		scanf(""%d%d%d%d%d"",&sco[i].a,&sco[i].b,&sco[i].c,&sco[i].x ,&sco[i].y);
		sco[i].vis = 0;
	}
	for(i=1;i<=n;i++)
	{
		dfs(i,t,ans,at);
		sco[i].vis = 0;	
	}	
	qsort(1,cc-1);
	printf(""%d"",anss[cc-1]);
	
	return 0;
}"
5,C,C,61490222,2023-03-24 20:47:13,lvzufeng,答案错误,"#include<stdio.h>
struct A{
	int a;
	int b;
	int c;
	int x;
	int y;
	int vis;
}sco[15];
long long ans = 0;
int at=0;
int cc = 1;
long long anss[400000];
int n,t,p;
int max(int a,int b)
{
	if(a>=b)return a;
	else return b;
}
void change(int a, int b,long long anss[]){
	long long t;
	t=anss[a];
	anss[a]=anss[b];
	anss[b]= t;
}
void qsort(int l, int r){
	int y = r,x=l;
	int mid= anss[(x+y)/2];
    while(x<=y){
    	while(anss[x]<mid){
    		x++;
		}
		while(anss[y]>mid){
			y--;
		}
		if(x<=y) {
		change(x,y,anss);
		x++;
		y--;}}
	if(l<y)	qsort(l,y);
	if(x<r)	qsort(x,r);
	}
void dfs(int cnt,int t,int ans,int at )
{
	int nt = t-sco[cnt].x;
	if(nt<0) 
	{
		anss[cc++]=ans;	
		return;
	}
	else if(sco[cnt].vis==1) 
	{
		nt = nt+sco[cnt].x;
	}
	else
		{
			sco[cnt].vis = 1;
			at+= sco[cnt].x;
			ans+= max(sco[cnt].c,sco[cnt].a-sco[cnt].b*at-sco[cnt].y*p);
		}
	int i;
	for(i=1;i<=n;i++)
	{
		if(sco[i].vis==0)
		{
		dfs(i,nt,ans,at);
		sco[i].vis = 0;
	}
	}
}
int main()
{
	scanf(""%d%d%d"",&n,&t,&p);
	int i;
	for(i=1;i<=n;i++)
	{
		scanf(""%d%d%d%d%d"",&sco[i].a,&sco[i].b,&sco[i].c,&sco[i].x ,&sco[i].y);
		sco[i].vis = 0;
	}
	for(i=1;i<=n;i++)
	{
		dfs(i,t,ans,at);
		sco[i].vis = 0;	
	}	
	qsort(1,cc-1);
	printf(""%lld"",anss[cc-1]);
	
	return 0;
}"
6,C,C,61491322,2023-03-24 20:56:31,lvzufeng,答案错误,"#include<stdio.h>
struct A{
	int a;
	int b;
	int c;
	int x;
	int y;
	int vis;
}sco[15];
long long ans = 0;
int at=0;
int cc = 1;
long long anss[400000];
int n,t,p;
int max(int a,int b)
{
	if(a>=b)return a;
	else return b;
}
void change(int a, int b,long long anss[]){
	long long t;
	t=anss[a];
	anss[a]=anss[b];
	anss[b]= t;
}
void qsort(int l, int r){
	int y = r,x=l;
	int mid= anss[(x+y)/2];
    while(x<=y){
    	while(anss[x]<mid){
    		x++;
		}
		while(anss[y]>mid){
			y--;
		}
		if(x<=y) {
		change(x,y,anss);
		x++;
		y--;}}
	if(l<y)	qsort(l,y);
	if(x<r)	qsort(x,r);
	}
void dfs(int cnt,int t,int ans,int at )
{
	int nt = t-sco[cnt].x;
	if(nt<0) 
	{
		anss[cc++]=ans;	
		return;
	}
	else if(sco[cnt].vis==1) 
	{
		nt = nt+sco[cnt].x;
	}
	else
		{
			sco[cnt].vis = 1;
			at+= sco[cnt].x;
			ans+= max(sco[cnt].c,sco[cnt].a-sco[cnt].b*at-sco[cnt].y*p);
		}
	int i;
	for(i=1;i<=n;i++)
	{
	if(sco[i].vis==0)
	{
		dfs(i,nt,ans,at);
		sco[i].vis = 0;
	}
	}
}
int main()
{
	scanf(""%d%d%d"",&n,&t,&p);
	int i;
	for(i=1;i<=n;i++)
	{
		scanf(""%d%d%d%d%d"",&sco[i].a,&sco[i].b,&sco[i].c,&sco[i].x ,&sco[i].y);
		sco[i].vis = 0;
	}
	for(i=1;i<=n;i++)
	{
		dfs(i,t,ans,at);
		sco[i].vis = 0;	
	}	
	qsort(1,cc-1);
	printf(""%lld"",anss[cc-1]);
	{
		int i;
		for(i=1;i<=3;i++)
		printf(""%d"",anss[i]);
	}
	
	return 0;
}"
7,C,C,61491373,2023-03-24 20:56:59,lvzufeng,答案错误,"#include<stdio.h>
struct A{
	int a;
	int b;
	int c;
	int x;
	int y;
	int vis;
}sco[15];
long long ans = 0;
int at=0;
int cc = 1;
long long anss[400000];
int n,t,p;
int max(int a,int b)
{
	if(a>=b)return a;
	else return b;
}
void change(int a, int b,long long anss[]){
	long long t;
	t=anss[a];
	anss[a]=anss[b];
	anss[b]= t;
}
void qsort(int l, int r){
	int y = r,x=l;
	int mid= anss[(x+y)/2];
    while(x<=y){
    	while(anss[x]<mid){
    		x++;
		}
		while(anss[y]>mid){
			y--;
		}
		if(x<=y) {
		change(x,y,anss);
		x++;
		y--;}}
	if(l<y)	qsort(l,y);
	if(x<r)	qsort(x,r);
	}
void dfs(int cnt,int t,int ans,int at )
{
	int nt = t-sco[cnt].x;
	if(nt<0) 
	{
		anss[cc++]=ans;	
		return;
	}
	else if(sco[cnt].vis==1) 
	{
		nt = nt+sco[cnt].x;
	}
	else
		{
			sco[cnt].vis = 1;
			at+= sco[cnt].x;
			ans+= max(sco[cnt].c,sco[cnt].a-sco[cnt].b*at-sco[cnt].y*p);
		}
	int i;
	for(i=1;i<=n;i++)
	{
	if(sco[i].vis==0)
	{
		dfs(i,nt,ans,at);
		sco[i].vis = 0;
	}
	}
}
int main()
{
	scanf(""%d%d%d"",&n,&t,&p);
	int i;
	for(i=1;i<=n;i++)
	{
		scanf(""%d%d%d%d%d"",&sco[i].a,&sco[i].b,&sco[i].c,&sco[i].x ,&sco[i].y);
		sco[i].vis = 0;
	}
	for(i=1;i<=n;i++)
	{
		dfs(i,t,ans,at);
		sco[i].vis = 0;	
	}	
	qsort(1,cc-1);
	printf(""%lld"",anss[cc-1]);
	
	return 0;
}"
8,C,C,61497982,2023-03-25 00:49:30,xunmeng,答案正确,"#include <stdio.h>

long long ans;
int a[15] = { 0 };
int n;
long long t, p;
long long tt = 0;
long long temp = 0;

struct ide
{
	long long aa, b, c, x, y;
	long long t;
}bb[15];

long long max(long long x, long long y)
{
	return x > y (?) x : y;
}

int main(void)
{
	void dfs(int nn);
	scanf(""%d %lld %lld"", &n, &t, &p);
	for (int i = 0; i < n; i++)
	{
		scanf(""%lld %lld %lld %lld %lld"", &bb[i].aa, &bb[i].b, &bb[i].c, &bb[i].x, &bb[i].y);
		//bb[i].t = max(bb[i].c, bb[i].aa - bb[i].y * p);
	}
	dfs(n);
	printf(""%lld"", ans);
}

void dfs(int nn)
{
	if (tt > t)
	{
		//ans = max(ans, temp);
		return;
	}
	else
	{
		ans = max(ans, temp);
	}
	if (n == 0)
	{
		ans = max(ans, temp);
		return;
	}
	for (int i = 0; i < n; i++)
	{
		if (a[i] == 0)
		{
			a[i] = 1;
			tt += bb[i].x;
			temp += max(bb[i].c, bb[i].aa - bb[i].y * p - tt * bb[i].b);
			dfs(nn - 1);
			temp -= max(bb[i].c, bb[i].aa - bb[i].y * p - tt * bb[i].b);
			tt -= bb[i].x;
			a[i] = 0;
			
		}
	}
}"
9,C,C,61498735,2023-03-25 09:16:11,牛客20220304118,答案正确,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
long long max=-1;
struct niuniu{
	long long a,b,c,x,y;
};

long long my_max(long long a,long long b){
	return a>b(?)a:b;
}

void dfs(struct niuniu*arr,int n,int t,int p,
int*used,int m,long long sum,long long x){
	if(m==n){
//		printf(""sum=%lld\n"",sum);
		if(max<sum) max=sum;
	}
	int i;
	for(i=0;i<n;i++){
		if(used[i]==1) continue;
		used[i]=1;
		if(t>=arr[i].x){
			dfs(arr,n,t-arr[i].x,p,used,m+1,sum+my_max(arr[i].c,arr[i].a-(x+arr[i].x)*arr[i].b-
			arr[i].y*p),x+arr[i].x);	
		}
		else{
			dfs(arr,n,t,p,used,m+1,sum,x);
		}
		used[i]=0;
	}
}

int main()
{
	int n,t,p,i,j;
	scanf(""%d %d %d"",&n,&t,&p);
	struct niuniu arr[n];
	for(i=0;i<n;i++){
		scanf(""%lld %lld %lld %lld %lld"",&arr[i].a,
		&arr[i].b,&arr[i].c,&arr[i].x,&arr[i].y);
	}
	int used[n];
	memset(used,0,sizeof(used));
	dfs(arr,n,t,p,used,0,0,0);
	printf(""%lld\n"",max);
//	for(i=0;i<n;i++){
//		printf(""%lld %lld %lld %lld %lld\n"",arr[i].a,
//		arr[i].b,arr[i].c,arr[i].x,arr[i].y);
//	}
	return 0;
}"
10,C,C,61524770,2023-03-25 15:28:41,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[10];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,int n,int t,int p)
{
    if(ti[i].x+t1>t)
        return;
    t1=ti[i].x+t1;
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);
    m=max(m,s);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
11,C,C,61525766,2023-03-25 15:37:00,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[10];
int z[10];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,int n,int t,int p)
{
    if(ti[i].x+t1>t||z[i]==0)
        return;
    t1=ti[i].x+t1;
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=0;
    m=max(m,s);
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
12,C,C,61525825,2023-03-25 15:37:29,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,int n,int t,int p)
{
    if(ti[i].x+t1>t||z[i]==0)
        return;
    t1=ti[i].x+t1;
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=0;
    m=max(m,s);
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
13,C,C,61526280,2023-03-25 15:41:31,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,int n,int t,int p)
{
    if(ti[i].x+t1>t||z[i]==0)
        return;
    t1=ti[i].x+t1;
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=0;
    m=max(m,s);
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=0;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
14,C,C,61526286,2023-03-25 15:41:36,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,int n,int t,int p)
{
    if(ti[i].x+t1>t||z[i]==0)
        return;
    t1=ti[i].x+t1;
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=0;
    m=max(m,s);
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
15,C,C,61526694,2023-03-25 15:45:15,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,int n,int t,int p)
{
    if(ti[i].x+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti[i].x+t1;//时间更新
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);//增加分数
    z[i]=0;//标记位置
    
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
16,C,C,61526758,2023-03-25 15:45:49,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(int i,long long int n,long long int t,long long int p)
{
    if(ti[i].x+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti[i].x+t1;//时间更新
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);//增加分数
    z[i]=0;//标记位置
    
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
17,C,C,61526830,2023-03-25 15:46:30,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(long long int i,long long int n,long long int t,long long int p)
{
    if(ti[i].x+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti[i].x+t1;//时间更新
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);//增加分数
    z[i]=0;//标记位置 
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(long long int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
18,C,C,61526851,2023-03-25 15:46:41,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(long long int i,long long int n,long long int t,long long int p)
{
    if(ti[i].x+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti[i].x+t1;//时间更新
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);//增加分数
    z[i]=0;//标记位置 
    for(int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(long long int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(long long int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
19,C,C,61526902,2023-03-25 15:47:10,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
long long int z[105];
long long int s=0,t1=0,m=0;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(long long int i,long long int n,long long int t,long long int p)
{
    if(ti[i].x+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti[i].x+t1;//时间更新
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);//增加分数
    z[i]=0;//标记位置 
    for(long long int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(long long int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(long long int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(long long int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
20,C,C,61526940,2023-03-25 15:47:36,丨阿伟丨,答案错误,"#include<stdio.h>
struct{
    long long int a,b,c,x,y;
}ti[105];
long long int z[105];
long long int s=0,t1=0,m=-1;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(long long int i,long long int n,long long int t,long long int p)
{
    if(ti[i].x+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti[i].x+t1;//时间更新
    s=s+max(ti[i].a-t1*ti[i].b-ti[i].y*p,ti[i].c);//增加分数
    z[i]=0;//标记位置 
    for(long long int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(long long int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti[i].x;
    s=s-max(ti[i].a-ti[i].x*ti[i].b-ti[i].y*p,ti[i].c);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(long long int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti[i].a,&ti[i].b,&ti[i].c,&ti[i].x,&ti[i].y);
        z[i]=1;
    }
    for(long long int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
21,C,C,61529311,2023-03-25 16:08:59,丨阿伟丨,答案错误,"#include<stdio.h>
long long int ti_x[105],ti_a[105],ti_b[105],ti_c[105],ti_y[105];
long long int z[105];
long long int s=0,t1=0,m=-1;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(long long int i,long long int n,long long int t,long long int p)
{
    if(ti_x[i]+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti_x[i]+t1;//时间更新
    s=s+max(ti_a[i]-t1*ti_b[i]-ti_y[i]*p,ti_c[i]);//增加分数
    z[i]=0;//标记位置 
    for(long long int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(long long int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti_x[i];
    s=s-max(ti_a[i]-ti_x[i]*ti_b[i]-ti_y[i]*p,ti_c[i]);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(long long int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti_a[i],&ti_b[i],&ti_c[i],&ti_x[i],&ti_y[i]);
        z[i]=1;
    }
    for(long long int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
22,C,C,61545711,2023-03-26 11:41:42,丨阿伟丨,答案错误,"#include<stdio.h>
long long int ti_x[105],ti_a[105],ti_b[105],ti_c[105],ti_y[105];
long long int z[105];
long long int s=0,t1=0,m=-1;
long long int max(long long int a,long long int b)
{
    return a>b(?)a:b;
}
void dfs(long long int i,long long int n,long long int t,long long int p)
{
    if(ti_x[i]+t1>t||z[i]==0)//时间超过或该点走过
        return;
    t1=ti_x[i]+t1;//时间更新
    s=s+max(ti_a[i]-t1*ti_b[i]-ti_y[i]*p,ti_c[i]);//增加分数
    z[i]=0;//标记位置 
    for(long long int o=i-1;o>=0;o--)
        dfs(o,n,t,p);
    for(long long int o=i+1;o<n;o++)
        dfs(o,n,t,p);
    m=max(m,s);//看哪个大
    t1=t1-ti_x[i];
    s=s-max(ti_a[i]-ti_x[i]*ti_b[i]-ti_y[i]*p,ti_c[i]);
    z[i]=1;
    return;
}
int main()
{
    long long int n,t,p;
    scanf(""%lld %lld %lld"",&n,&t,&p);
    for(long long int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&ti_a[i],&ti_b[i],&ti_c[i],&ti_x[i],&ti_y[i]);
        z[i]=1;
    }
    for(long long int i=0;i<n;i++)
        dfs(i,n,t,p);
    printf(""%lld"",m);
}"
23,C,C,61577698,2023-03-27 15:11:24,拒绝pua的小鱼干很爱吃肉,答案正确,"#include <stdio.h>
#include <string.h>

struct cf
{
    long long int a,b,c,x,y;
}cff[15];

long long max(long long a,long long b)
{
    return a>b(?)a:b;
}

long long int ans=-1;

void dfs(struct cf*cff,int n,int t,int p,int *flag,int m,long long sum,long long x)
{
    if(m==n)
    {
        if(ans<sum) ans=sum;
    }

    for(int i=0;i<n;i++)
    {
        if(flag[i]==1) continue;
        flag[i]=1;
        if(t>=cff[i].x)
        {
            dfs(cff,n,t-cff[i].x,p,flag,m+1,sum+max(cff[i].c,cff[i].a-(x+cff[i].x)*cff[i].b-cff[i].y*p),x+cff[i].x);
        }
        else dfs(cff,n,t,p,flag,m+1,sum,x);
        flag[i]=0;
    }
}
int main()
{
    long int n,t,p;
    scanf(""%ld %ld %ld"",&n,&t,&p);
    
    for(int i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&cff[i].a,&cff[i].b,&cff[i].c,&cff[i].x,&cff[i].y);
    }
    
    int flag[n+5];
    memset(flag,0,sizeof(flag));
    
    dfs(cff,n,t,p,flag,0,0,0);
    
    printf(""%lld"",ans);
    return 0;
}"
24,C,C,61599370,2023-03-28 22:46:34,牛客656472613号,段错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;

	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		t1 = t - niu[i].x;
		if (t1 >= 0) {
			sum = sum + max(niu[i].c, niu[i].a - niu[i].x * niu[i].b - niu[i].y * p);
		}
		for (j = 0; j < n; j++) {
			if (t1 <= 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				sum = sum + max(niu[j].c, niu[j].a - niu[j].x * niu[j].b - niu[j].y * p);
			}
		}
	}
}"
25,C,C,61603336,2023-03-29 14:21:29,牛客656472613号,段错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;

	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		t1 = t - niu[i].x;
		if (t1 >= 0) {
			sum = sum + max(niu[i].c, niu[i].a - niu[i].x * niu[i].b - niu[i].y * p);
		}
		for (j = 0; j < n; j++) {
			if (t1 <= 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				sum = sum + max(niu[j].c, niu[j].a - niu[j].x * niu[j].b - niu[j].y * p);
			}
		}
	}
}"
26,C,C,61603548,2023-03-29 14:33:35,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;

	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum=0;
		t1 = t - niu[i].x;
		if (t1 >= 0) {
			sum = sum + max(niu[i].c, niu[i].a - niu[i].x * niu[i].b - niu[i].y * p);
		}
		maxSum=0;
		for (j = 0; j < n; j++) {
			if (t1 <= 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				sum = sum + max(niu[j].c, niu[j].a - niu[j].x * niu[j].b - niu[j].y * p);
			}
		}
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
27,C,C,61603679,2023-03-29 14:39:17,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;

	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum = 0;
		t1 = t - niu[i].x;
		if (t1 >= 0) {
			sum = sum + max(niu[i].c, niu[i].a - niu[i].x * niu[i].b - niu[i].y * p);
		}
		for (j = 0; j < n; j++) {
			if (t1 <= 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				if (t1 >= 0)
					sum = sum + max(niu[j].c, niu[j].a - niu[j].x * niu[j].b - niu[j].y * p);
			}
		}
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
28,C,C,61604250,2023-03-29 15:12:14,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;
	int t2 = 0;
	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum = 0;
		t1 = t - niu[i].x;
		if (t1 >= 0) {
			t2 = niu[i].x + t2;
			sum = sum + max(niu[i].c, niu[i].a - t2 * niu[i].b - niu[i].y * p);
//			printf(""第一题：%d\n"", sum);
		}
		for (j = 0; j < n; j++) {
			if (t1 < 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				if (t1 >= 0) {
					t2 = niu[j].x + t2;
					sum = sum + max(niu[j].c, niu[j].a - t2 * niu[j].b - niu[j].y * p);
				}

//				printf(""第%d题：%d\n"", j, sum);
			}
		}
//		printf(""-%d-"", sum);
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
29,C,C,61621608,2023-03-30 20:35:57,tx163,答案正确,"typedef long long ll;
typedef double db;
#define MAX(a,b) (a>b(?)a:b)
#define MIN(a,b) (a<b(?)a:b)
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
ll n,t,p,ans,hash[10],path;
void dfs(ll*a,ll*b,ll*c,ll*x,ll*y,ll time,ll index){
    if(index==n||time>=t){
        path=MAX(path,ans);
    }
    for(int i=0;i<n;i++){
        if(hash[i]) continue;
        hash[i]++;
        ll score=0;
        if(time+x[i]<=t) score=MAX(c[i],a[i]-b[i]*(time+x[i])-y[i]*p);
        ans+=score;
        dfs(a,b,c,x,y,time+x[i],index+1);
        hash[i]--;
        ans-=score;
    }
}
int main()
{    
    path=0;ans=0;memset(hash,0,sizeof(hash));
    scanf(""%lld%lld%lld"",&n,&t,&p);
    ll a[10]={0},b[10]={0},c[10]={0},x[10]={0},y[10]={0};
    for(int i=0;i<n;i++) scanf(""%lld%lld%lld%lld%lld"",&a[i],&b[i],&c[i],&x[i],&y[i]);
    dfs(a,b,c,x,y,0,0);
    printf(""%lld"",path);
}"
30,C,C,61621656,2023-03-30 20:37:33,tx163,答案正确,"typedef long long ll;
typedef double db;
#define MAX(a,b) (a>b(?)a:b)
#define MIN(a,b) (a<b(?)a:b)
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
ll n,t,p,ans,hash[10],path;
void dfs(ll*a,ll*b,ll*c,ll*x,ll*y,ll time,ll index){
    if(index==n||time>=t){
        path=MAX(path,ans);
        return;
    }
    for(int i=0;i<n;i++){
        if(hash[i]) continue;
        hash[i]++;
        ll score=0;
        if(time+x[i]<=t) score=MAX(c[i],a[i]-b[i]*(time+x[i])-y[i]*p);
        ans+=score;
        dfs(a,b,c,x,y,time+x[i],index+1);
        hash[i]--;
        ans-=score;
    }
}
int main()
{    
    path=0;ans=0;memset(hash,0,sizeof(hash));
    scanf(""%lld%lld%lld"",&n,&t,&p);
    ll a[10]={0},b[10]={0},c[10]={0},x[10]={0},y[10]={0};
    for(int i=0;i<n;i++) scanf(""%lld%lld%lld%lld%lld"",&a[i],&b[i],&c[i],&x[i],&y[i]);
    dfs(a,b,c,x,y,0,0);
    printf(""%lld"",path);
}"
31,C,C,61622081,2023-03-30 20:57:39,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;
	int t2 = 0;
	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum = 0;
		t1 = t - niu[i].x;
		if (t1 >= 0) {
			t2 = niu[i].x + t2;
			sum = sum + max(niu[i].c, niu[i].a - t2 * niu[i].b - niu[i].y * p);
//			printf(""第一题：%d\n"", sum);
		}
		for (j = 0; j < n; j++) {
			if (t1 < 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				if (t1 >= 0) {
					t2 = niu[j].x + t2;
					sum = sum + max(niu[j].c, niu[j].a - t2 * niu[j].b - niu[j].y * p);
				}

//				printf(""第%d题：%d\n"", j, sum);
			}
		}
//		printf(""-%d-"", sum);
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
32,C,C,61622571,2023-03-30 21:26:36,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;
	int t2 = 0;
	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum = 0;
		t1 = t - niu[i].x;
		t2 = 0;
		if (t1 >= 0) {
			t2 = niu[i].x + t2;
			sum = sum + max(niu[i].c, niu[i].a - t2 * niu[i].b - niu[i].y * p);
			printf(""第一题：%d\n"", sum);
		}
		for (j = 0; j < n; j++) {
			if (t1 < 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				if (t1 >= 0) {
					t2 = niu[j].x + t2;
					sum = sum + max(niu[j].c, niu[j].a - t2 * niu[j].b - niu[j].y * p);
				}

				printf(""第%d题：%d\n"", j + 1, sum);
			}
		}
		printf(""-%d-\n"", sum);
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
33,C,C,61622600,2023-03-30 21:28:02,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;
	int t2 = 0;
	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum = 0;
		t1 = t - niu[i].x;
		t2 = 0;
		if (t1 >= 0) {
			t2 = niu[i].x + t2;
			sum = sum + max(niu[i].c, niu[i].a - t2 * niu[i].b - niu[i].y * p);
//			printf(""第一题：%d\n"", sum);
		}
		for (j = 0; j < n; j++) {
			if (t1 < 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				if (t1 >= 0) {
					t2 = niu[j].x + t2;
					sum = sum + max(niu[j].c, niu[j].a - t2 * niu[j].b - niu[j].y * p);
				}

//				printf(""第%d题：%d\n"", j + 1, sum);
			}
		}
//		printf(""-%d-\n"", sum);
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
34,C,C,61629411,2023-03-31 18:54:16,威严满满大小姐,答案错误,"#include<stdio.h>
#include<string.h>
#include<math.h>
int n;
long long a[20]={0},b[20]={0},c[20]={0},d[20]={0},e[20]={0};
long long xuan[15]={0};
long long t,p;
long long ter=0,ori=0;
long long tt=0;
long long max(long long x,long long y)
{
    return x>y(?)x:y;
}
long long dfs(int nn)
{   int j;
    long long aa;
    if(tt>t)
    {
        return 0;
    }
    else
    {
        ori=max(ori,ter);
    }
    if(n==0)
    {
        ori=max(ori,ter);
        return 0;
    }
    for(j=0;j<nn;j++)
    {   aa=0;
        if(xuan[j]==0)
        {   
            xuan[j]=1;
            tt+=d[j];
            aa=a[j]-b[j]*tt-e[j]*p;
            ter+=max(c[j],aa);
            dfs(nn-1);
            tt-=d[j];
            ter-=max(c[j],aa);
            xuan[j]=0;
        }
    }
 return 0;
}
int main()
{
    scanf(""%d %lld %lld"",&n,&t,&p);
    //printf(""第一行%d,%lld,%lld\n"",n,t,p);
    int i;
    for(i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&a[i],&b[i],&c[i],&d[i],&e[i]);
    }
    dfs(n);
    printf(""%lld"",ori);
}

"
35,C,C,61629425,2023-03-31 18:54:53,威严满满大小姐,答案正确,"#include <stdio.h>

long long ans;
int a[15] = { 0 };
int n;
long long t, p;
long long tt = 0;
long long temp = 0;

struct ide
{
	long long aa, b, c, x, y;
	long long t;
}bb[15];

long long max(long long x, long long y)
{
	return x > y (?) x : y;
}

int main(void)
{
	void dfs(int nn);
	scanf(""%d %lld %lld"", &n, &t, &p);
	for (int i = 0; i < n; i++)
	{
		scanf(""%lld %lld %lld %lld %lld"", &bb[i].aa, &bb[i].b, &bb[i].c, &bb[i].x, &bb[i].y);
		//bb[i].t = max(bb[i].c, bb[i].aa - bb[i].y * p);
	}
	dfs(n);
	printf(""%lld"", ans);
}

void dfs(int nn)
{
	if (tt > t)
	{
		//ans = max(ans, temp);
		return;
	}
	else
	{
		ans = max(ans, temp);
	}
	if (n == 0)
	{
		ans = max(ans, temp);
		return;
	}
	for (int i = 0; i < n; i++)
	{
		if (a[i] == 0)
		{
			a[i] = 1;
			tt += bb[i].x;
			temp += max(bb[i].c, bb[i].aa - bb[i].y * p - tt * bb[i].b);
			dfs(nn - 1);
			temp -= max(bb[i].c, bb[i].aa - bb[i].y * p - tt * bb[i].b);
			tt -= bb[i].x;
			a[i] = 0;
			
		}
	}
}
"
36,C,C,61629488,2023-03-31 18:57:45,威严满满大小姐,答案正确,"#include<stdio.h>
#include<string.h>
#include<math.h>
int n;
long long a[20]={0},b[20]={0},c[20]={0},d[20]={0},e[20]={0};
long long xuan[15]={0};
long long t,p;
long long ter=0,ori=0;
long long tt=0;
long long max(long long x,long long y)
{
    return x>y(?)x:y;
}
long long dfs(int nn)
{   int j;
long long aa;
    if(tt>t)
    {
        return 0;
    }
    else
    {
        ori=max(ori,ter);
    }
    if(n==0)
    {
        ori=max(ori,ter);
        return 0;
    }
    for(j=0;j<n;j++)
    {   aa=0;
        if(xuan[j]==0)
        {   
            xuan[j]=1;
            tt+=d[j];
            aa=a[j]-b[j]*tt-e[j]*p;
            ter+=max(c[j],aa);
            dfs(nn-1);
            tt-=d[j];
            ter-=max(c[j],aa);
            xuan[j]=0;
        }
    }
 return 0;
}
int main()
{
    scanf(""%d %lld %lld"",&n,&t,&p);
    //printf(""第一行%d,%lld,%lld\n"",n,t,p);
    int i;
    for(i=0;i<n;i++)
    {
        scanf(""%lld %lld %lld %lld %lld"",&a[i],&b[i],&c[i],&d[i],&e[i]);
    }
    dfs(n);
    printf(""%lld"",ori);
}"
37,C,C,61700872,2023-04-01 20:17:08,牛客656472613号,答案错误,"#include <stdio.h>

struct NIU {
	int a;
	int b;
	int c;
	int x;
	int y;
};

int max(int a, int b) {
	return a > b (?) a : b;
}
struct NIU niu[100001];

int main() {
	int n, t, p;
	int i, j;
	int sum = 0;
	int maxSum = -1; //用于保存sum的最大值
	scanf(""%d%d%d"", &n, &t, &p);
	int t1 = t;
	int t2 = 0;
	for (i = 0; i < n; i++) {
		scanf(""%d%d%d%d%d"", &niu[i].a, &niu[i].b, &niu[i].c, &niu[i].x, &niu[i].y);
	}
	for (i = 0; i < n; i++) {
		sum = 0;
		t1 = t - niu[i].x;
		t2 = 0;
		if (t1 >= 0) {
			t2 = niu[i].x + t2;
			sum = sum + max(niu[i].c, niu[i].a - t2 * niu[i].b - niu[i].y * p);
//			printf(""第一题：%d\n"", sum);
		}
		for (j = 0; j < n; j++) {
			if (t1 < 0) {
				break;
			}
			if (j == i)
				continue;
			else {
				t1 = t1 - niu[j].x;
				if (t1 >= 0) {
					t2 = niu[j].x + t2;
					sum = sum + max(niu[j].c, niu[j].a - t2 * niu[j].b - niu[j].y * p);
				}

//				printf(""第%d题：%d\n"", j + 1, sum);
			}
		}
//		printf(""-%d-\n"", sum);
		maxSum = max(sum, maxSum);
	}
	printf(""%d\n"", maxSum);
}"
38,C,C(gcc 7.5.0),61752240,2023-04-05 13:20:45,墨初_,答案错误,"#include<stdio.h>
#define N 9
typedef struct score{
    long long a[N];
    long long b[N];
    long long c[N];
    long long x[N];
    long long y[N];
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n=0,t=0,p=0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N],r;
    int i=0,j=0,m=0,q=0;
    long long max=0;
    scanf(""%d%d%d"",&n,&t,&p);
    for(i=0;i<n;i++)
    {
        scanf(""%lld%lld%lld%lld%lld"",&s[i].a[i],&s[i].b[i],&s[i].c[i],&s[i].x[i],&s[i].y[i]);
    }
    for(i=0;i<n-1;i++)
    {
       for(j=i+1;j<n;j++)
        {
           //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
               if(s[i].x[i]>s[j].x[j])
               {
                   r=s[i];
                   s[i]=s[j];
                   s[j]=r;
               }
        }
    }
    /*for(i=0;i<n;i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"",s[i].a[i],s[i].b[i],s[i].c[i],s[i].x[i],s[i].y[i]);    
    }*/
    for(i=0;i<n;i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q+=s[i].x[i];
        if(t>=s[i].x[i])
        {
            max+=(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p);
            t-=s[i].x[i];
            //printf(""%lld\n"",max);
        }else if(t<s[i].x[i])
        {
            break;
        }
    }
    printf(""%lld"",max);
    return 0;
}"
39,C,C(gcc 7.5.0),61752302,2023-04-05 13:29:55,墨初_,答案错误,"#include<stdio.h>
#define N 9
typedef struct score{
    long long a[N];
    long long b[N];
    long long c[N];
    long long x[N];
    long long y[N];
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n=0,t=0,p=0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N],r;
    int i=0,j=0,m=0,q=0;
    long long max=0;
    scanf(""%d%d%d"",&n,&t,&p);
    for(i=0;i<n;i++)
    {
        scanf(""%lld%lld%lld%lld%lld"",&s[i].a[i],&s[i].b[i],&s[i].c[i],&s[i].x[i],&s[i].y[i]);
    }
    for(i=0;i<n-1;i++)
    {
       for(j=i+1;j<n;j++)
        {
           //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
               if(s[i].x[i]>s[j].x[j])
               {
                   r=s[i];
                   s[i]=s[j];
                   s[j]=r;
               }
        }
    }
    /*for(i=0;i<n;i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"",s[i].a[i],s[i].b[i],s[i].c[i],s[i].x[i],s[i].y[i]);    
    }*/
    for(i=0;i<n;i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q+=s[i].x[i];
        //若得分小于保底分则加上保底分
        if(t>=s[i].x[i])
        {
            if(s[i].c[i]<(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p))
            {
                max+=(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p);
            }else if(s[i].c[i]>=(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p))
            {
                max+=s[i].c[i];
            }
                t-=s[i].x[i];
            //printf(""%lld\n"",max);
        }else if(t<s[i].x[i])
        {
            break;
        }
    }
    printf(""%lld"",max);
    return 0;
}"
40,C,C(gcc 7.5.0),61752314,2023-04-05 13:31:15,墨初_,答案错误,"#include<stdio.h>
#define N 9
typedef struct score{
    long long a[N];
    long long b[N];
    long long c[N];
    long long x[N];
    long long y[N];
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n=0,t=0,p=0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N],r;
    int i=0,j=0,m=0,q=0;
    long long max=0;
    scanf(""%d%d%d"",&n,&t,&p);
    for(i=0;i<n;i++)
    {
        scanf(""%lld%lld%lld%lld%lld"",&s[i].a[i],&s[i].b[i],&s[i].c[i],&s[i].x[i],&s[i].y[i]);
        if(s[i].a[i]<s[i].c[i])
        {
            exit(0);
        }
    }
    for(i=0;i<n-1;i++)
    {
       for(j=i+1;j<n;j++)
        {
           //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
               if(s[i].x[i]>s[j].x[j])
               {
                   r=s[i];
                   s[i]=s[j];
                   s[j]=r;
               }
        }
    }
    /*for(i=0;i<n;i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"",s[i].a[i],s[i].b[i],s[i].c[i],s[i].x[i],s[i].y[i]);    
    }*/
    for(i=0;i<n;i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q+=s[i].x[i];
        //若得分小于保底分则加上保底分
        if(t>=s[i].x[i])
        {
            if(s[i].c[i]<(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p))
            {
                max+=(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p);
            }else if(s[i].c[i]>=(s[i].a[i]-q*s[i].b[i]-s[i].y[i]*p))
            {
                max+=s[i].c[i];
            }
                t-=s[i].x[i];
            //printf(""%lld\n"",max);
        }else if(t<s[i].x[i])
        {
            break;
        }
    }
    printf(""%lld"",max);
    return 0;
}"
41,C,C(gcc 7.5.0),61752666,2023-04-05 14:01:56,墨初_,答案错误,"//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 9
typedef struct score {
    long long a[N];
    long long b[N];
    long long c[N];
    long long x[N];
    long long y[N];
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n = 0, t = 0, p = 0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N], r;
    int i = 0, j = 0, m = 0, q = 0;
    long long max = 0;
    scanf(""%d%d%d"", &n, &t, &p);
    for (i = 0; i < n; i++)
    {
        scanf(""%lld%lld%lld%lld%lld"", &s[i].a[i], &s[i].b[i], &s[i].c[i], &s[i].x[i], &s[i].y[i]);
        if (s[i].a[i] < s[i].c[i])
        {
            exit(0);
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
            if (s[i].x[i] > s[j].x[j])
            {
                r.a[i] = s[i].a[i];
                s[i].a[i] = s[j].a[j];
                s[j].a[j] = r.a[i];
                r.b[i] = s[i].b[i];
                s[i].b[i] = s[j].b[j];
                s[j].b[j] = r.b[i];
                r.c[i] = s[i].c[i];
                s[i].c[i] = s[j].c[j];
                s[j].c[j] = r.c[i];
                r.x[i] = s[i].x[i];
                s[i].x[i] = s[j].x[j];
                s[j].x[j] = r.x[i];
                r.y[i] = s[i].y[i];
                s[i].y[i] = s[j].y[j];
                s[j].y[j] = r.y[i];
            }
        }
    }
    /*for (i = 0; i < n; i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"", s[i].a[i], s[i].b[i], s[i].c[i], s[i].x[i], s[i].y[i]);
    }*/
    for (i = 0; i < n; i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q += s[i].x[i];
        //若得分小于保底分则加上保底分
        if (t >= s[i].x[i])
        {
            if (s[i].c[i] < (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p))
            {
                max += (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p);
            }
            else if (s[i].c[i] >= (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p))
            {
                max += s[i].c[i];
            }
            t -= s[i].x[i];
            //printf(""%lld\n"",max);
        }
        else if (t < s[i].x[i])
        {
            break;
        }
    }
    printf(""%lld"", max);
    return 0;
}"
42,C,C(gcc 7.5.0),61752690,2023-04-05 14:03:30,墨初_,答案错误,"//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 9
typedef struct score {
    long long a[N];
    long long b[N];
    long long c[N];
    long long x[N];
    long long y[N];
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n = 0, t = 0, p = 0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N], r;
    int i = 0, j = 0, m = 0, q = 0;
    long long max = 0;
    scanf(""%d%d%d"", &n, &t, &p);
    for (i = 0; i < n; i++)
    {
        scanf(""%lld%lld%lld%lld%lld"", &s[i].a[i], &s[i].b[i], &s[i].c[i], &s[i].x[i], &s[i].y[i]);
        if (s[i].a[i] < s[i].c[i])
        {
            exit(0);
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
            if (s[i].x[i] > s[j].x[j])
            {
                r.a[i] = s[i].a[i];
                s[i].a[i] = s[j].a[j];
                s[j].a[j] = r.a[i];
                r.b[i] = s[i].b[i];
                s[i].b[i] = s[j].b[j];
                s[j].b[j] = r.b[i];
                r.c[i] = s[i].c[i];
                s[i].c[i] = s[j].c[j];
                s[j].c[j] = r.c[i];
                r.x[i] = s[i].x[i];
                s[i].x[i] = s[j].x[j];
                s[j].x[j] = r.x[i];
                r.y[i] = s[i].y[i];
                s[i].y[i] = s[j].y[j];
                s[j].y[j] = r.y[i];
            }
        }
    }
    /*for (i = 0; i < n; i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"", s[i].a[i], s[i].b[i], s[i].c[i], s[i].x[i], s[i].y[i]);
    }*/
    for (i = 0; i < n; i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q += s[i].x[i];
        //若得分小于保底分则加上保底分
        if (t >= s[i].x[i])
        {
            if (s[i].c[i] < (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p))
            {
                max += (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p);
            }
            else if (s[i].c[i] >= (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p))
            {
                max += s[i].c[i];
            }
            t -= s[i].x[i];
            //printf(""%lld\n"",max);
        }
        else if (t < s[i].x[i])
        {
            break;
        }
    }
    printf(""%lld"", max);
    return 0;
}"
43,C,C(gcc 7.5.0),61752871,2023-04-05 14:14:23,墨初_,答案错误,"//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 9
typedef struct score {
    long long a[N];
    long long b[N];
    long long c[N];
    long long x[N];
    long long y[N];
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n = 0, t = 0;
    long long p=0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N], r;
    int i = 0, j = 0, m = 0, q = 0;
    long long max = 0;
    scanf(""%d%d%lld"", &n, &t, &p);
    if(t<1||n<1||n>9)
    {
        exit(0);
    }
    for (i = 0; i < n; i++)
    {
        scanf(""%lld%lld%lld%lld%lld"", &s[i].a[i], &s[i].b[i], &s[i].c[i], &s[i].x[i], &s[i].y[i]);
        if (s[i].a[i] < s[i].c[i])
        {
            exit(0);
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
            if (s[i].x[i] > s[j].x[j])
            {
                r.a[i] = s[i].a[i];
                s[i].a[i] = s[j].a[j];
                s[j].a[j] = r.a[i];
                r.b[i] = s[i].b[i];
                s[i].b[i] = s[j].b[j];
                s[j].b[j] = r.b[i];
                r.c[i] = s[i].c[i];
                s[i].c[i] = s[j].c[j];
                s[j].c[j] = r.c[i];
                r.x[i] = s[i].x[i];
                s[i].x[i] = s[j].x[j];
                s[j].x[j] = r.x[i];
                r.y[i] = s[i].y[i];
                s[i].y[i] = s[j].y[j];
                s[j].y[j] = r.y[i];
            }
        }
    }
    /*for (i = 0; i < n; i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"", s[i].a[i], s[i].b[i], s[i].c[i], s[i].x[i], s[i].y[i]);
    }*/
    for (i = 0; i < n; i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q += s[i].x[i];
        //若得分小于保底分则加上保底分
        if (t >= s[i].x[i])
        {
            if (s[i].c[i] < (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p))
            {
                max += (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p);
            }
            else if (s[i].c[i] >= (s[i].a[i] - q * s[i].b[i] - s[i].y[i] * p))
            {
                max += s[i].c[i];
            }
            t -= s[i].x[i];
            //printf(""%lld\n"",max);
        }
        else if (t < s[i].x[i])
        {
            break;
        }
    }
    printf(""%lld"", max);
    return 0;
}"
44,C,C(gcc 7.5.0),61753080,2023-04-05 14:25:39,墨初_,答案错误,"//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 9
typedef struct score {
    long long a;
    long long b;
    long long c;
    long long x;
    long long y;
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n = 0, t = 0, p = 0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N], r;
    int i = 0, j = 0, m = 0, q = 0;
    long long max = 0;
    scanf(""%d%d%d"", &n, &t, &p);
    for (i = 0; i < n; i++)
    {
        scanf(""%lld%lld%lld%lld%lld"", &s[i].a, &s[i].b, &s[i].c, &s[i].x, &s[i].y);
        if (s[i].a < s[i].c)
        {
            exit(0);
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
            if (s[i].x> s[j].x)
            {
                r = s[i];
                s[i] = s[j];
                s[j] = r;
                /*r.b[i] = s[i].b[i];
                s[i].b[i] = s[j].b[j];
                s[j].b[j] = r.b[i];
                r.c[i] = s[i].c[i];
                s[i].c[i] = s[j].c[j];
                s[j].c[j] = r.c[i];
                r.x[i] = s[i].x[i];
                s[i].x[i] = s[j].x[j];
                s[j].x[j] = r.x[i];
                r.y[i] = s[i].y[i];
                s[i].y[i] = s[j].y[j];
                s[j].y[j] = r.y[i];*/
            }
        }
    }
    /*for (i = 0; i < n; i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"", s[i].a, s[i].b, s[i].c, s[i].x, s[i].y);
    }*/
    for (i = 0; i < n; i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q += s[i].x;
        //若得分小于保底分则加上保底分
        if (t >= s[i].x)
        {
            if (s[i].c < (s[i].a - q * s[i].b - s[i].y * p))
            {
                max += (s[i].a - q * s[i].b - s[i].y * p);
            }
            else if (s[i].c >= (s[i].a - q * s[i].b - s[i].y * p))
            {
                max += s[i].c;
            }
            t -= s[i].x;
            //printf(""%lld\n"",max);
        }
        else if (t < s[i].x)
        {
            break;
        }
    }
    printf(""%lld"", max);
    return 0;
}"
45,C,C(gcc 7.5.0),61753128,2023-04-05 14:28:05,墨初_,答案错误,"//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 9
typedef struct score {
    long long a;
    long long b;
    long long c;
    long long x;
    long long y;
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n = 0, t = 0, p = 0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N], r;
    int i = 0, j = 0, m = 0, q = 0;
    long long max = 0;
    scanf(""%d%d%d"", &n, &t, &p);
    for (i = 0; i < n; i++)
    {
        scanf(""%lld%lld%lld%lld%lld"", &s[i].a, &s[i].b, &s[i].c, &s[i].x, &s[i].y);
        if (s[i].a < s[i].c)
        {
            exit(0);
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
            if (s[i].x> s[j].x)
            {
                r = s[i];
                s[i] = s[j];
                s[j] = r;
            }
        }
    }
    /*for (i = 0; i < n; i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"", s[i].a, s[i].b, s[i].c, s[i].x, s[i].y);
    }*/
    for (i = 0; i < n; i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q += s[i].x;
        //若得分小于保底分则加上保底分
        if (t >= s[i].x)
        {
            if (s[i].c < (s[i].a - q * s[i].b - s[i].y * p))
            {
                max += (s[i].a - q * s[i].b - s[i].y * p);
            }
            else if (s[i].c >= (s[i].a - q * s[i].b - s[i].y * p))
            {
                max += s[i].c;
            }
            t -= q;
            //printf(""%lld\n"",max);
        }
        else if (t < s[i].x)
        {
            break;
        }
    }
    printf(""%lld"", max);
    return 0;
}"
46,C,C(gcc 7.5.0),61753592,2023-04-05 14:53:21,墨初_,答案错误,"//#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 9
typedef struct score {
    long long a;
    long long b;
    long long c;
    long long x;
    long long y;
}scoe;
int main()
{
    //n代表题目个数，t代表比赛时间，p代表错误提交扣分
    int n = 0, t = 0, p = 0;
    //数组a代表每道题满分值，b代表时间系数，c代表保底分
    //x代表多久通过该道题，y代表有几次错误提交
    scoe s[N], r;
    int i = 0, j = 0, m = 0, q = 0;
    long long max = 0;
    scanf(""%d%d%d"", &n, &t, &p);
    for (i = 0; i < n; i++)
    {
        scanf(""%lld%lld%lld%lld%lld"", &s[i].a, &s[i].b, &s[i].c, &s[i].x, &s[i].y);
        if (s[i].a < s[i].c)
        {
            exit(0);
        }
    }
    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //将结构体中花费时间更少的题目排前面，先做时间少的，在做时间多的
            if (s[i].x> s[j].x)
            {
                r = s[i];
                s[i] = s[j];
                s[j] = r;
            }
        }
    }
    /*for (i = 0; i < n; i++)
    {
        //查看是否交换
        printf(""%lld %lld %lld %lld %lld\n"", s[i].a, s[i].b, s[i].c, s[i].x, s[i].y);
    }*/
    for (i = 0; i < n; i++)
    {
        //当剩余时间足够做这道题，则做，否则，不做
        //用来累加做题时间
        q += s[i].x;
        //若得分小于保底分则加上保底分
        if (t >= s[i].x)
        {
            if (s[i].c < (s[i].a - q * s[i].b - s[i].y * p))
            {
                max += (s[i].a - q * s[i].b - s[i].y * p);
            }
            else if (s[i].c >= (s[i].a - q * s[i].b - s[i].y * p))
            {
                max += s[i].c;
            }
            //t -= s[i].x;
            //printf(""%lld\n"",max);
        }
        else if (t < s[i].x)
        {
            break;
        }
        t -= s[i].x;
    }
    printf(""%lld"", max);
    return 0;
}"
