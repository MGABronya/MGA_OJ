,index,languageName,submissionId,submitTime,userName,statusMessage,code
0,C,Java,54834327,2022-11-18 19:44:39,humwawe,答案错误,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.util.Collection;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.Queue;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    TaskC solver = new TaskC();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskC {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
      int n = in.nextInt();
      int m = in.nextInt();
      int r1 = in.nextInt();
      int r2 = in.nextInt();
      int[] p1 = new int[2];
      int[] p2 = new int[2];
      char[][] a = new char[n][m];
      int[][] dist1 = new int[n][m];
      int[][] dist2 = new int[n][m];
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
          dist1[i][j] = -1;
          dist2[i][j] = -1;
          a[i][j] = in.nextCharacter();
          if (a[i][j] == 'M') {
            p1[0] = i;
            p1[1] = j;
            dist1[i][j] = 0;
          }
          if (a[i][j] == 'P') {
            p2[0] = i;
            p2[1] = j;
            dist2[i][j] = 0;
          }
        }
      }
      int[][] fs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};


      Queue<int[]> queue = new ArrayDeque<>();
      queue.add(p1);
      while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        for (int[] f : fs) {
          int x = cur[0] + f[0];
          int y = cur[1] + f[1];
          if (x >= 0 && x < n && y >= 0 && y < m && dist1[x][y] == -1 && a[x][y] != '*') {
            dist1[x][y] = dist1[cur[0]][cur[1]] + 1;
            queue.add(new int[]{x, y});
          }
        }
      }

      queue.add(p2);
      int res = (int) 1e8;
      while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        for (int[] f : fs) {
          int x = cur[0] + f[0];
          int y = cur[1] + f[1];
          if (x >= 0 && x < n && y >= 0 && y < m && helper(x, y, p2) <= r1 && a[x][y] != '*' && dist2[x][y] == -1) {
            dist2[x][y] = dist2[cur[0]][cur[1]] + 1;
            queue.add(new int[]{x, y});
            if (helper(x, y, p1) <= r2) {
              res = Math.min(res, dist1[x][y] + dist2[x][y]);
            }
          }
        }
      }
      if (res == (int) 1e8) {
        out.println(-1);
      } else {
        out.println(res);
      }

    }

    private int helper(int x, int y, int[] p2) {
      return Math.abs(x - p2[0]) + Math.abs(y - p2[1]);
    }

  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void close() {
      writer.close();
    }

    public void println(int i) {
      writer.println(i);
    }

  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private InputReader.SpaceCharFilter filter;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) {
        throw new UnknownError();
      }
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new UnknownError();
        }
        if (numChars <= 0) {
          return -1;
        }
      }
      return buf[curChar++];
    }

    public int nextInt() {
      int c = read();
      while (isSpaceChar(c)) {
        c = read();
      }
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new UnknownError();
        }
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      if (filter != null) {
        return filter.isSpaceChar(c);
      }
      return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public char nextCharacter() {
      int c = read();
      while (isSpaceChar(c)) {
        c = read();
      }
      return (char) c;
    }

    public interface SpaceCharFilter {
      public boolean isSpaceChar(int ch);

    }

  }
}

"
1,C,Java,54834335,2022-11-18 19:44:41,Garett,答案错误,"import java.math.BigInteger;
import java.util.*;
import java.io.*;


/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws IOException {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader sc = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, sc, out);
        out.close();
    }

    static class Task {
        public static final int[] dx=new int[]{-1,1,0,0};
        public static final int[] dy=new int[]{0,0,-1,1};
        public int n;
        public int m;
        public char[][] map;
        public static final int INF=10000000;

        public boolean check(int x,int y){
            return 0<=x&&x<n&&0<=y&&y<m;
        }

        public int[][] bfs(int beginx,int beginy){
            int[][] dis=new int[n][m];
            for(int[] temp:dis)
                Arrays.fill(temp,INF);
            dis[beginx][beginy]=0;
            Queue<int[]> que=new ArrayDeque<>();
            que.add(new int[]{beginx,beginy,0});
            while(!que.isEmpty()){
                int[] temp=que.remove();
                int x=temp[0];
                int y=temp[1];
                int cost=temp[2];
                for(int i=0;i<4;i++){
                    int nowx=x+dx[i];
                    int nowy=y+dy[i];
                    if(!check(nowx,nowy)||map[nowx][nowy]=='*')
                        continue;
                    if(dis[nowx][nowy]>cost+1){
                        dis[nowx][nowy]=cost+1;
                        que.add(new int[]{nowx,nowy,cost+1});
                    }
                }
            }
            return dis;
        }

        public int getDis(int x,int y,int a,int b){
            return Math.abs(x-a)+Math.abs(y-b);
        }

        public void solve(int testNumber, InputReader sc, PrintWriter out) throws IOException {
            n=sc.nextInt();
            m=sc.nextInt();
            int r1=sc.nextInt();
            int r2=sc.nextInt();
            map=new char[n][];
            int x1=0;
            int y1=0;
            int x2=0;
            int y2=0;
            for(int i=0;i<n;i++){
                map[i]=sc.next().toCharArray();
                for(int j=0;j<m;j++){
                    if(map[i][j]=='P'){
                        x1=i;
                        y1=j;
                    }
                    if(map[i][j]=='M'){
                        x2=i;
                        y2=j;
                    }
                }
            }
            int ans=INF;
            int[][] dis1=bfs(x1,y1);
            int[][] dis2=bfs(x2,y2);
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(getDis(i,j,x1,y1)>r1)
                        continue;
                    if(getDis(i,j,x2,y2)<=r2)
                        ans=Math.min(ans,dis1[i][j]+dis2[i][j]);
                }
            }
            if(ans==INF)
                ans=-1;
            out.println(ans);

        }

    }

    static class InputReader {
        private InputStreamReader reader;
        private char[] buf;
        private int len, now;

        public InputReader(InputStream stream) {
            reader = new InputStreamReader(stream);
            buf = new char[1024];
            len = 0;
            now = 0;
        }

        public String next() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            StringBuilder sb = new StringBuilder();
            while (!isSpaceChar(buf[now])) {
                sb.append(buf[now]);
                if (!move()) break;
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            int ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isNum(buf[now])) ans = ans * 10 + buf[now] - '0';
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public String nextLine() throws IOException {
            if (!hasNextLine()) throw new NullPointerException();
            StringBuilder sb = new StringBuilder();
            while (buf[now] != '\n') {
                sb.append(buf[now]);
                if (!move()) return sb.toString();
            }
            now++;
            return sb.toString();
        }

        public long nextLong() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            long ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isNum(buf[now])) ans = ans * 10 + buf[now] - '0';
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int nextHexInt() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            int ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isHex(buf[now])) ans = (ans << 4) + toHex(buf[now]);
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public char nextChar() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            char tmp = buf[now];
            move();
            return tmp;
        }
        public int next(char[] s) throws IOException {
            if (!hasNext()) throw new NullPointerException();
            int len=0;
            while (!isSpaceChar(buf[now])&&len<s.length) {
                s[len++]=buf[now];
                if (!move()) break;
            }
            return len;
        }
        public boolean hasNext() throws IOException {
            return skip();
        }

        public boolean hasNextLine() throws IOException {
            return now < len || refill();
        }

        private boolean move() throws IOException {
            now++;
            return hasNextLine();
        }

        private boolean skip() throws IOException {
            if (!hasNextLine()) return false;
            while (isSpaceChar(buf[now])) {
                if (!move()) return false;
            }
            return true;
        }

        private boolean isSpaceChar(char c) {
            return !(c >= 33 && c <= 126);
        }

        private boolean isNum(char c) {
            return c >= '0' && c <= '9';
        }

        private boolean isHex(char c) {
            return c >= '0' && c <= '9' || c >= 'A' && c <= 'F';
        }

        private int toHex(char c) {
            if (c >= '0' && c <= '9') return c - '0';
            else return c - 'A' + 10;
        }

        private boolean refill() throws IOException {
            len = reader.read(buf);
            now = 0;
            return len > 0;
        }
    }
}
"
2,C,Java,54834583,2022-11-18 19:45:37,232132323,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int n,m;
        int [][] vis = new int[1000][1000];
        char [][] s = new char[1000][1000];
        int px,py,mx,my;
        int [][] xy = {{0,1},{0,-1},{1,0},{-1,0}};
        int r1,r2;
        boolean check(int x,int y){
            if (x >= 0 && x < n && y >= 0 && y < m && vis[x][y] == 0 && (s[x][y] == 'P'||s[x][y] == 'M'||s[x][y] == '.'))
                return true;
            return false;
        }
        int min = Integer.MAX_VALUE;
        void bfs(){
            Queue<Location> q = new LinkedList<>();
            q.offer(new Location(px,py));
            int count = 0;
            while (!q.isEmpty()) {
                int size = q.size();
                while (size-- > 0){
                    Location l = q.poll();
                    if (count == r1){
                        if (Math.abs(l.x-mx) + Math.abs(l.y-my) > r2*r2)
                            continue;
                    }
                    if (l.x == mx && l.y == my){
                        min = count;
                        return;
                    }
                    if (vis[l.x][l.y] == 0){
                        vis[l.x][l.y] = 1;
                        for (int i = 0; i < 4; i++) {
                            int x = l.x + xy[i][0];
                            int y = l.y + xy[i][1];
                            if (check(x,y)){
                                q.offer(new Location(x,y));
                            }
                        }
                    }
                }
                count++;
            }
        }
        class Location{
            int x,y;

            public Location(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String a = in.next();
                for (int j = 0; j < m; j++) {
                    s[i][j] = a.charAt(j);
                    if (s[i][j] == 'P'){
                        px = i;
                        py = j;
                    }
                    else if (s[i][j] == 'M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            bfs();
            if (min == Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(min);
        }
    }


    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}"
3,C,Java,54835143,2022-11-18 19:47:54,humwawe,答案正确,"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.util.Collection;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.Queue;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    TaskC solver = new TaskC();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskC {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
      int n = in.nextInt();
      int m = in.nextInt();
      int r1 = in.nextInt();
      int r2 = in.nextInt();
      int[] p1 = new int[2];
      int[] p2 = new int[2];
      char[][] a = new char[n][m];
      int[][] dist1 = new int[n][m];
      int[][] dist2 = new int[n][m];
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
          dist1[i][j] = -1;
          dist2[i][j] = -1;
          a[i][j] = in.nextCharacter();
          if (a[i][j] == 'M') {
            p1[0] = i;
            p1[1] = j;
            dist1[i][j] = 0;
          }
          if (a[i][j] == 'P') {
            p2[0] = i;
            p2[1] = j;
            dist2[i][j] = 0;
          }
        }
      }
      int[][] fs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};


      Queue<int[]> queue = new ArrayDeque<>();
      queue.add(p1);
      while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        for (int[] f : fs) {
          int x = cur[0] + f[0];
          int y = cur[1] + f[1];
          if (x >= 0 && x < n && y >= 0 && y < m && dist1[x][y] == -1 && a[x][y] != '*') {
            dist1[x][y] = dist1[cur[0]][cur[1]] + 1;
            queue.add(new int[]{x, y});
          }
        }
      }

      queue.add(p2);
      int res = (int) 1e8;
      while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        for (int[] f : fs) {
          int x = cur[0] + f[0];
          int y = cur[1] + f[1];
          if (x >= 0 && x < n && y >= 0 && y < m && helper(x, y, p2) <= r1 && a[x][y] != '*' && dist2[x][y] == -1) {
            dist2[x][y] = dist2[cur[0]][cur[1]] + 1;
            queue.add(new int[]{x, y});
            if (helper(x, y, p1) <= r2 && dist1[x][y] != -1) {
              res = Math.min(res, dist1[x][y] + dist2[x][y]);
            }
          }
        }
      }
      if (res == (int) 1e8) {
        out.println(-1);
      } else {
        out.println(res);
      }

    }

    private int helper(int x, int y, int[] p2) {
      return Math.abs(x - p2[0]) + Math.abs(y - p2[1]);
    }

  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void close() {
      writer.close();
    }

    public void println(int i) {
      writer.println(i);
    }

  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private InputReader.SpaceCharFilter filter;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) {
        throw new UnknownError();
      }
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new UnknownError();
        }
        if (numChars <= 0) {
          return -1;
        }
      }
      return buf[curChar++];
    }

    public int nextInt() {
      int c = read();
      while (isSpaceChar(c)) {
        c = read();
      }
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new UnknownError();
        }
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      if (filter != null) {
        return filter.isSpaceChar(c);
      }
      return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public char nextCharacter() {
      int c = read();
      while (isSpaceChar(c)) {
        c = read();
      }
      return (char) c;
    }

    public interface SpaceCharFilter {
      public boolean isSpaceChar(int ch);

    }

  }
}

"
4,C,Java,54836884,2022-11-18 19:55:15,232132323,答案正确,"import java.io.*;
import java.util.*;
import java.math.*;
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int n,m;
        int [][] vis = new int[1000][1000];
        char [][] s = new char[1000][1000];
        int px,py,mx,my;
        int [][] xy = {{0,1},{0,-1},{1,0},{-1,0}};
        int r1,r2;
        boolean check(int x,int y){
            if (x >= 0 && x < n && y >= 0 && y < m && vis[x][y] == 0 && (s[x][y] == 'P'||s[x][y] == 'M'||s[x][y] == '.'))
                return true;
            return false;
        }
        int min = Integer.MAX_VALUE;
        void bfs(){
            Queue<Location> q = new LinkedList<>();
            q.offer(new Location(px,py));
            int count = 0;
            while (!q.isEmpty()) {
                int size = q.size();
                while (size-- > 0){
                    Location l = q.poll();
//                    System.out.println(l.x + "" "" + l.y);
                    if (count == r1){
//                        System.out.println(l.x + "" "" + l.y + "" hnkijdsnfkjsadnfkjsan"");
                        if (Math.abs(l.x-mx) + Math.abs(l.y-my) > r2)
                            continue;
                    }
                    if (l.x == mx && l.y == my){
                        min = count;
                        return;
                    }
                    if (vis[l.x][l.y] == 0){
                        vis[l.x][l.y] = 1;
                        for (int i = 0; i < 4; i++) {
                            int x = l.x + xy[i][0];
                            int y = l.y + xy[i][1];
                            if (check(x,y)){
//                                System.out.println(""dsaguyhsagfjhgag"" +l.x + "" "" + l.y +"" "" + x + "" "" + y);
                                q.offer(new Location(x,y));
                            }
                        }
                    }
                }
//                System.out.println(""=================================="");
                count++;
            }
        }
        class Location{
            int x,y;

            public Location(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String a = in.next();
                for (int j = 0; j < m; j++) {
                    s[i][j] = a.charAt(j);
                    if (s[i][j] == 'P'){
                        px = i;
                        py = j;
                    }
                    else if (s[i][j] == 'M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            bfs();
            if (min == Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(min);
        }
    }


    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}"
5,C,Java,54837502,2022-11-18 19:57:51,牛客489187966号,答案错误,"
import java.io.*;
import java.util.*;

public class Main {

    static int N = 1010, sx, sy, ex, ey, INF = 0x3f3f3f3f;
    static char[][] map = new char[N][N];
    static int[][] step = new int[N][N];
    static int[][] df = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    public static void main(String[] args) throws IOException {
        initReader();
        int n = nextInt();
        int m = nextInt();
        int r1 = nextInt();
        int r2 = nextInt();

        for (int i = 1; i <= n; i++) {
            String s = next();
            char[] chars = s.toCharArray();
            for (int j = 1; j <= m; j++) {
                map[i][j] = chars[j - 1];
                if (map[i][j] == 'P') {
                    sx = i;
                    sy = j;
                }
                if (map[i][j] == 'M') {
                    ex = i;
                    ey = j;
                }
            }
        }

        int dis1 = INF;
        int tx = 0, ty = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{sx, sy});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            if (Math.abs(sx - x) + Math.abs(sy - y) > r1) {
                break;
            }

            if (Math.abs(ex - x) + Math.abs(ey - y) <= r2) {
                dis1 = step[x][y];
                tx = x;
                ty = y;
                break;
            }
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && step[nx][ny] == 0) {
                    queue.add(new int[]{nx, ny});
                    step[nx][ny] = step[x][y] + 1;
                }
            }
        }

        if (dis1 == INF) {
            pw.println(""-1"");
            pw.close();
            return;
        }

        for (int i = 0; i < N; i++) Arrays.fill(step[i], 0);
        queue.clear();
        queue.add(new int[]{ex, ey});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            if (x == tx &&y == ty) break;
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && step[nx][ny] == 0) {
                    queue.add(new int[]{nx,ny});
                    step[nx][ny] = step[x][y] + 1;
                }
            }
        }
        pw.println(dis1 + step[tx][ty]);


        pw.close();
    }


    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter pw;

    public static void initReader() throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = new StringTokenizer("""");
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    }


    public static boolean hasNext() {
        try {
            while (!tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(reader.readLine());
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        try {
            return reader.readLine();
        } catch (Exception e) {
            return null;
        }
    }

    public static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    public static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

    public static char nextChar() throws IOException {
        return next().charAt(0);
    }
}
"
6,C,Java,54838748,2022-11-18 20:03:46,牛客489187966号,答案错误,"
import java.io.*;
import java.util.*;

public class Main {

    static int N = 1010, sx, sy, ex, ey, INF = 0x3f3f3f3f;
    static char[][] map = new char[N][N];
    static int[][] step = new int[N][N];
    static int[][] df = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    public static void main(String[] args) throws IOException {
        initReader();
        int n = nextInt();
        int m = nextInt();
        int r1 = nextInt();
        int r2 = nextInt();

        for (int i = 1; i <= n; i++) {
            String s = next();
            char[] chars = s.toCharArray();
            for (int j = 1; j <= m; j++) {
                map[i][j] = chars[j - 1];
                if (map[i][j] == 'P') {
                    sx = i;
                    sy = j;
                }
                if (map[i][j] == 'M') {
                    ex = i;
                    ey = j;
                }
            }
        }

        int dis1 = INF;
        int tx = 0, ty = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{sx, sy});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            if (Math.abs(ex - x) + Math.abs(ey - y) <= r2) {
                dis1 = step[x][y];
                tx = x;
                ty = y;
                break;
            }
            if (Math.abs(sx - x) + Math.abs(sy - y) > r1) {
                break;
            }

        
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && step[nx][ny] == 0) {
                    queue.add(new int[]{nx, ny});
                    step[nx][ny] = step[x][y] + 1;
                }
            }
        }

        if (dis1 == INF) {
            pw.println(""-1"");
            pw.close();
            return;
        }

        for (int i = 0; i < N; i++) Arrays.fill(step[i], 0);
        queue.clear();
        queue.add(new int[]{ex, ey});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            if (x == tx &&y == ty) break;
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && step[nx][ny] == 0) {
                    queue.add(new int[]{nx,ny});
                    step[nx][ny] = step[x][y] + 1;
                }
            }
        }
        pw.println(dis1 + step[tx][ty]);


        pw.close();
    }


    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter pw;

    public static void initReader() throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = new StringTokenizer("""");
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    }


    public static boolean hasNext() {
        try {
            while (!tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(reader.readLine());
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        try {
            return reader.readLine();
        } catch (Exception e) {
            return null;
        }
    }

    public static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    public static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

    public static char nextChar() throws IOException {
        return next().charAt(0);
    }
}
"
7,C,Java,54838913,2022-11-18 20:04:36,Garett,答案正确,"import java.math.BigInteger;
import java.util.*;
import java.io.*;


/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws IOException {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader sc = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, sc, out);
        out.close();
    }

    static class Task {
        public static final int[] dx=new int[]{-1,1,0,0};
        public static final int[] dy=new int[]{0,0,-1,1};
        public int n;
        public int m;
        public char[][] map;
        public static final int INF=10000000;
        public int r1;
        public int r2;

        public boolean check(int x,int y){
            return 0<=x&&x<n&&0<=y&&y<m;
        }

        public int[][] bfs(int beginx,int beginy,int mx,int my,int px,int py){
            int[][] dis=new int[n][m];
            for(int[] temp:dis)
                Arrays.fill(temp,INF);
            dis[beginx][beginy]=0;
            Queue<int[]> que=new ArrayDeque<>();
            que.add(new int[]{beginx,beginy,0});
            while(!que.isEmpty()){
                int[] temp=que.remove();
                int x=temp[0];
                int y=temp[1];
                int cost=temp[2];
                for(int i=0;i<4;i++){
                    int nowx=x+dx[i];
                    int nowy=y+dy[i];
                    if(!check(nowx,nowy)||map[nowx][nowy]=='*')
                        continue;
                    if(px!=-1&&getDis(px,py,nowx,nowy)>r1)
                        continue;
                    if(dis[nowx][nowy]>cost+1){
                        dis[nowx][nowy]=cost+1;
//                         if(mx!=-1&&getDis(mx,my,nowx,nowy)>r2)
                            que.add(new int[]{nowx,nowy,cost+1});
                    }
                }
            }
            return dis;
        }

        public int getDis(int x,int y,int a,int b){
            return Math.abs(x-a)+Math.abs(y-b);
        }

        public void solve(int testNumber, InputReader sc, PrintWriter out) throws IOException {
            n=sc.nextInt();
            m=sc.nextInt();
            r1=sc.nextInt();
            r2=sc.nextInt();
            map=new char[n][];
            int x1=0;
            int y1=0;
            int x2=0;
            int y2=0;
            for(int i=0;i<n;i++){
                map[i]=sc.next().toCharArray();
                for(int j=0;j<m;j++){
                    if(map[i][j]=='P'){
                        x1=i;
                        y1=j;
                    }
                    if(map[i][j]=='M'){
                        x2=i;
                        y2=j;
                    }
                }
            }
            int ans=INF;
            int[][] dis1=bfs(x1,y1,x2,y2,x1,y1);
            int[][] dis2=bfs(x2,y2,-1,-1,-1,-1);
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(getDis(i,j,x1,y1)>r1)
                        continue;
                    if(getDis(i,j,x2,y2)<=r2)
                        ans=Math.min(ans,dis1[i][j]+dis2[i][j]);
                }
            }
            if(ans==INF)
                ans=-1;
            out.println(ans);

        }

    }

    static class InputReader {
        private InputStreamReader reader;
        private char[] buf;
        private int len, now;

        public InputReader(InputStream stream) {
            reader = new InputStreamReader(stream);
            buf = new char[1024];
            len = 0;
            now = 0;
        }

        public String next() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            StringBuilder sb = new StringBuilder();
            while (!isSpaceChar(buf[now])) {
                sb.append(buf[now]);
                if (!move()) break;
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            int ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isNum(buf[now])) ans = ans * 10 + buf[now] - '0';
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public String nextLine() throws IOException {
            if (!hasNextLine()) throw new NullPointerException();
            StringBuilder sb = new StringBuilder();
            while (buf[now] != '\n') {
                sb.append(buf[now]);
                if (!move()) return sb.toString();
            }
            now++;
            return sb.toString();
        }

        public long nextLong() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            long ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isNum(buf[now])) ans = ans * 10 + buf[now] - '0';
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int nextHexInt() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            int ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isHex(buf[now])) ans = (ans << 4) + toHex(buf[now]);
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public char nextChar() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            char tmp = buf[now];
            move();
            return tmp;
        }
        public int next(char[] s) throws IOException {
            if (!hasNext()) throw new NullPointerException();
            int len=0;
            while (!isSpaceChar(buf[now])&&len<s.length) {
                s[len++]=buf[now];
                if (!move()) break;
            }
            return len;
        }
        public boolean hasNext() throws IOException {
            return skip();
        }

        public boolean hasNextLine() throws IOException {
            return now < len || refill();
        }

        private boolean move() throws IOException {
            now++;
            return hasNextLine();
        }

        private boolean skip() throws IOException {
            if (!hasNextLine()) return false;
            while (isSpaceChar(buf[now])) {
                if (!move()) return false;
            }
            return true;
        }

        private boolean isSpaceChar(char c) {
            return !(c >= 33 && c <= 126);
        }

        private boolean isNum(char c) {
            return c >= '0' && c <= '9';
        }

        private boolean isHex(char c) {
            return c >= '0' && c <= '9' || c >= 'A' && c <= 'F';
        }

        private int toHex(char c) {
            if (c >= '0' && c <= '9') return c - '0';
            else return c - 'A' + 10;
        }

        private boolean refill() throws IOException {
            len = reader.read(buf);
            now = 0;
            return len > 0;
        }
    }
}
"
8,C,Java,54838961,2022-11-18 20:04:50,刘映辰,答案错误,"import java.util.*;
import java.lang.*;

public class Main {
    static int[][] direction = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    static int n = 0;
    static int m = 0;
    
    public static void bfs(char[][] grid, int[][] array, int[] index, int distance){
        Deque<int[]> queue = new ArrayDeque<>();
        array[index[0]][index[1]] = 0;
        queue.add(index);
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if((Math.abs(new_x - current[0]) + Math.abs(new_y - current[1])) <= distance && dis < array[new_x][new_y]){
                            array[new_x][new_y] = dis;
                            queue.addLast(new int[]{new_x, new_y});
                        }
                    }
                }
            }
            dis += 1;
        }
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        int r1 = in.nextInt();
        int r2 = in.nextInt();
        in.nextLine();
        
        char[][] grid = new char[n][m];
        int[] person_index = new int[2];
        int[] cat_index = new int[2];
        
        for(int i = 0; i < n; i++){
            String temp = in.nextLine();
            for(int j = 0; j < m; j++){
                grid[i][j] = temp.charAt(j);
                if(grid[i][j] == 'P'){
                    person_index[0] = i;
                    person_index[1] = j;
                }
                
                if(grid[i][j] == 'M'){
                    cat_index[0] = i;
                    cat_index[1] = j;
                }
            }
        }
        
        int[][] person = new int[n][m];
        int[][] cat = new int[n][m];
        for(int i = 0; i < n; i++){
            Arrays.fill(person[i], 1000000001);
            Arrays.fill(cat[i], 1000000001);
        }
        
        bfs(grid, person, person_index, r1);
        bfs(grid, cat, cat_index ,r2);
        
        int result = 2000000002;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if((Math.abs(i - person_index[0]) + Math.abs(j - person_index[1])) <= r1 && (Math.abs(i - cat_index[0]) + Math.abs(j - cat_index[1])) <= r2){
                    result = Math.min(result, person[i][j] + cat[i][j]);
                }     
            }
        }
        
        if(result >= 2000000002){
            result = -1;
        }
        
        System.out.println(result);
    }
}"
9,C,Java,54838995,2022-11-18 20:04:59,Garett,答案错误,"import java.math.BigInteger;
import java.util.*;
import java.io.*;


/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws IOException {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader sc = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, sc, out);
        out.close();
    }

    static class Task {
        public static final int[] dx=new int[]{-1,1,0,0};
        public static final int[] dy=new int[]{0,0,-1,1};
        public int n;
        public int m;
        public char[][] map;
        public static final int INF=10000000;
        public int r1;
        public int r2;

        public boolean check(int x,int y){
            return 0<=x&&x<n&&0<=y&&y<m;
        }

        public int[][] bfs(int beginx,int beginy,int mx,int my,int px,int py){
            int[][] dis=new int[n][m];
            for(int[] temp:dis)
                Arrays.fill(temp,INF);
            dis[beginx][beginy]=0;
            Queue<int[]> que=new ArrayDeque<>();
            que.add(new int[]{beginx,beginy,0});
            while(!que.isEmpty()){
                int[] temp=que.remove();
                int x=temp[0];
                int y=temp[1];
                int cost=temp[2];
                for(int i=0;i<4;i++){
                    int nowx=x+dx[i];
                    int nowy=y+dy[i];
                    if(!check(nowx,nowy)||map[nowx][nowy]=='*')
                        continue;
//                     if(px!=-1&&getDis(px,py,nowx,nowy)>r1)
//                         continue;
                    if(dis[nowx][nowy]>cost+1){
                        dis[nowx][nowy]=cost+1;
//                         if(mx!=-1&&getDis(mx,my,nowx,nowy)>r2)
                            que.add(new int[]{nowx,nowy,cost+1});
                    }
                }
            }
            return dis;
        }

        public int getDis(int x,int y,int a,int b){
            return Math.abs(x-a)+Math.abs(y-b);
        }

        public void solve(int testNumber, InputReader sc, PrintWriter out) throws IOException {
            n=sc.nextInt();
            m=sc.nextInt();
            r1=sc.nextInt();
            r2=sc.nextInt();
            map=new char[n][];
            int x1=0;
            int y1=0;
            int x2=0;
            int y2=0;
            for(int i=0;i<n;i++){
                map[i]=sc.next().toCharArray();
                for(int j=0;j<m;j++){
                    if(map[i][j]=='P'){
                        x1=i;
                        y1=j;
                    }
                    if(map[i][j]=='M'){
                        x2=i;
                        y2=j;
                    }
                }
            }
            int ans=INF;
            int[][] dis1=bfs(x1,y1,x2,y2,x1,y1);
            int[][] dis2=bfs(x2,y2,-1,-1,-1,-1);
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(getDis(i,j,x1,y1)>r1)
                        continue;
                    if(getDis(i,j,x2,y2)<=r2)
                        ans=Math.min(ans,dis1[i][j]+dis2[i][j]);
                }
            }
            if(ans==INF)
                ans=-1;
            out.println(ans);

        }

    }

    static class InputReader {
        private InputStreamReader reader;
        private char[] buf;
        private int len, now;

        public InputReader(InputStream stream) {
            reader = new InputStreamReader(stream);
            buf = new char[1024];
            len = 0;
            now = 0;
        }

        public String next() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            StringBuilder sb = new StringBuilder();
            while (!isSpaceChar(buf[now])) {
                sb.append(buf[now]);
                if (!move()) break;
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            int ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isNum(buf[now])) ans = ans * 10 + buf[now] - '0';
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public String nextLine() throws IOException {
            if (!hasNextLine()) throw new NullPointerException();
            StringBuilder sb = new StringBuilder();
            while (buf[now] != '\n') {
                sb.append(buf[now]);
                if (!move()) return sb.toString();
            }
            now++;
            return sb.toString();
        }

        public long nextLong() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            long ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isNum(buf[now])) ans = ans * 10 + buf[now] - '0';
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int nextHexInt() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            boolean x = false;
            if (buf[now] == '-') {
                x = true;
                if (!move()) throw new NumberFormatException();
            }
            int ans = 0;
            while (!isSpaceChar(buf[now])) {
                if (isHex(buf[now])) ans = (ans << 4) + toHex(buf[now]);
                else throw new NumberFormatException();
                if (!move()) break;
            }
            return (x ? -1 : 1) * ans;
        }

        public char nextChar() throws IOException {
            if (!hasNext()) throw new NullPointerException();
            char tmp = buf[now];
            move();
            return tmp;
        }
        public int next(char[] s) throws IOException {
            if (!hasNext()) throw new NullPointerException();
            int len=0;
            while (!isSpaceChar(buf[now])&&len<s.length) {
                s[len++]=buf[now];
                if (!move()) break;
            }
            return len;
        }
        public boolean hasNext() throws IOException {
            return skip();
        }

        public boolean hasNextLine() throws IOException {
            return now < len || refill();
        }

        private boolean move() throws IOException {
            now++;
            return hasNextLine();
        }

        private boolean skip() throws IOException {
            if (!hasNextLine()) return false;
            while (isSpaceChar(buf[now])) {
                if (!move()) return false;
            }
            return true;
        }

        private boolean isSpaceChar(char c) {
            return !(c >= 33 && c <= 126);
        }

        private boolean isNum(char c) {
            return c >= '0' && c <= '9';
        }

        private boolean isHex(char c) {
            return c >= '0' && c <= '9' || c >= 'A' && c <= 'F';
        }

        private int toHex(char c) {
            if (c >= '0' && c <= '9') return c - '0';
            else return c - 'A' + 10;
        }

        private boolean refill() throws IOException {
            len = reader.read(buf);
            now = 0;
            return len > 0;
        }
    }
}
"
10,C,Java,54839455,2022-11-18 20:07:16,刘映辰,答案错误,"import java.util.*;
import java.lang.*;

public class Main {
    static int[][] direction = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    static int n = 0;
    static int m = 0;
    
    public static void bfs(char[][] grid, int[][] array, int[] index, int distance){
        Deque<int[]> queue = new ArrayDeque<>();
        array[index[0]][index[1]] = 0;
        queue.add(index);
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if((Math.abs(new_x - index[0]) + Math.abs(new_y - index[1])) <= distance && dis < array[new_x][new_y]){
                            array[new_x][new_y] = dis;
                            queue.addLast(new int[]{new_x, new_y});
                        }
                    }
                }
            }
            dis += 1;
        }
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        int r1 = in.nextInt();
        int r2 = in.nextInt();
        in.nextLine();
        
        char[][] grid = new char[n][m];
        int[] person_index = new int[2];
        int[] cat_index = new int[2];
        
        for(int i = 0; i < n; i++){
            String temp = in.nextLine();
            for(int j = 0; j < m; j++){
                grid[i][j] = temp.charAt(j);
                if(grid[i][j] == 'P'){
                    person_index[0] = i;
                    person_index[1] = j;
                }
                
                if(grid[i][j] == 'M'){
                    cat_index[0] = i;
                    cat_index[1] = j;
                }
            }
        }
        
        int[][] person = new int[n][m];
        int[][] cat = new int[n][m];
        for(int i = 0; i < n; i++){
            Arrays.fill(person[i], 1000000001);
            Arrays.fill(cat[i], 1000000001);
        }
        
        bfs(grid, person, person_index, r1);
        bfs(grid, cat, cat_index ,r2);
        
        int result = 2000000002;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if((Math.abs(i - person_index[0]) + Math.abs(j - person_index[1])) <= r1 && (Math.abs(i - cat_index[0]) + Math.abs(j - cat_index[1])) <= r2){
                    result = Math.min(result, person[i][j] + cat[i][j]);
                }     
            }
        }
        
        if(result >= 2000000002){
            result = -1;
        }
        
        System.out.println(result);
    }
}"
11,C,Java,54840014,2022-11-18 20:09:43,刘映辰,答案错误,"import java.util.*;
import java.lang.*;

public class Main {
    static int[][] direction = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    static int n = 0;
    static int m = 0;
    
    public static void bfs(char[][] grid, int[][] array, int[] index, int distance){
        Deque<int[]> queue = new ArrayDeque<>();
        array[index[0]][index[1]] = 0;
        queue.add(index);
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if((Math.abs(new_x - index[0]) + Math.abs(new_y - index[1])) <= distance && dis < array[new_x][new_y]){
                            array[new_x][new_y] = dis;
                            queue.addLast(new int[]{new_x, new_y});
                        }
                    }
                }
            }
            dis += 1;
        }
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        int r1 = in.nextInt();
        int r2 = in.nextInt();
        in.nextLine();
        
        char[][] grid = new char[n][m];
        int[] person_index = new int[2];
        int[] cat_index = new int[2];
        
        for(int i = 0; i < n; i++){
            String temp = in.nextLine();
            for(int j = 0; j < m; j++){
                grid[i][j] = temp.charAt(j);
                if(grid[i][j] == 'P'){
                    person_index[0] = i;
                    person_index[1] = j;
                }
                
                if(grid[i][j] == 'M'){
                    cat_index[0] = i;
                    cat_index[1] = j;
                }
            }
        }
        
        int[][] person = new int[n][m];
        int[][] cat = new int[n][m];
        for(int i = 0; i < n; i++){
            Arrays.fill(person[i], 1000000001);
            Arrays.fill(cat[i], 1000000001);
        }
        
        bfs(grid, person, person_index, r1);
        bfs(grid, cat, cat_index ,r2);
        
        int result = 2000000002;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(person[i][j] != 1000000001 && cat[i][j] != 1000000001 && (Math.abs(i - person_index[0]) + Math.abs(j - person_index[1])) <= r1 && (Math.abs(i - cat_index[0]) + Math.abs(j - cat_index[1])) <= r2){
                    result = Math.min(result, person[i][j] + cat[i][j]);
                }     
            }
        }
        
        if(result >= 2000000002){
            result = -1;
        }
        
        System.out.println(result);
    }
}"
12,C,Java,54840219,2022-11-18 20:10:48,刘映辰,答案错误,"import java.util.*;
import java.lang.*;

public class Main {
    static int[][] direction = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    static int n = 0;
    static int m = 0;
    
    public static void bfs(char[][] grid, int[][] array, int[] index, int distance){
        Deque<int[]> queue = new ArrayDeque<>();
        array[index[0]][index[1]] = 0;
        queue.add(index);
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if((Math.abs(new_x - index[0]) + Math.abs(new_y - index[1])) <= distance && dis < array[new_x][new_y]){
                            array[new_x][new_y] = dis;
                            queue.addLast(new int[]{new_x, new_y});
                        }
                    }
                }
            }
            dis += 1;
        }
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        int r1 = in.nextInt();
        int r2 = in.nextInt();
        in.nextLine();
        
        char[][] grid = new char[n][m];
        int[] person_index = new int[2];
        int[] cat_index = new int[2];
        
        for(int i = 0; i < n; i++){
            String temp = in.nextLine();
            for(int j = 0; j < m; j++){
                grid[i][j] = temp.charAt(j);
                if(grid[i][j] == 'P'){
                    person_index[0] = i;
                    person_index[1] = j;
                }
                
                if(grid[i][j] == 'M'){
                    cat_index[0] = i;
                    cat_index[1] = j;
                }
            }
        }
        
        int[][] person = new int[n][m];
        int[][] cat = new int[n][m];
        int max_step = 1000000001;
        for(int i = 0; i < n; i++){
            Arrays.fill(person[i], max_step);
            Arrays.fill(cat[i], max_step);
        }
        
        bfs(grid, person, person_index, r1);
        bfs(grid, cat, cat_index ,r2);
        
        int result = max_step;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(person[i][j] != max_step && cat[i][j] != max_step && (Math.abs(i - person_index[0]) + Math.abs(j - person_index[1])) <= r1 && (Math.abs(i - cat_index[0]) + Math.abs(j - cat_index[1])) <= r2){
                    result = Math.min(result, person[i][j] + cat[i][j]);
                }     
            }
        }
        
        if(result >= max_step){
            result = -1;
        }
        
        System.out.println(result);
    }
}"
13,C,Java,54840575,2022-11-18 20:12:33,皮皮猪小飞侠,答案错误,"import java.util.*;

/**
 * @author xjf
 * @date 2022/11/18 18:49:44
 */
public class Main {
    public static int[][] dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();
        int r1 = scan.nextInt(), r2 = scan.nextInt();
        scan.nextLine();
        char[][] map = new char[n][m];
        int[] plmm = new int[2], cat = new int[2];
        for (int i = 0; i < n; i++) {
            String temp = scan.nextLine();
            for (int j = 0; j < m; j++) {
                map[i][j] = temp.charAt(j);
                if(map[i][j] == 'P') {
                    plmm[0] = i;plmm[1] = j;
                }else if(map[i][j] == 'M'){
                    cat[0] = i;cat[1] = j;
                }
            }
        }
        int[][] dis1 = BFS(map, plmm[0], plmm[1], r1);
        int[][] dis2 = BFS(map, cat[0], cat[1], r2);
        List<int[]> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
//                if(map[i][j] != '*' && Math.abs(i - plmm[0]) + Math.abs(j - plmm[1]) <= r1 &&
//                        Math.abs(i - cat[0]) + Math.abs(j - cat[1]) <= r2){
//                    list.add(new int[]{i, j});
//                }
                if(dis1[i][j] != -1 && dis2[i][j] != -1){
                    list.add(new int[]{i,j});
                }
            }
        }
        if(list.isEmpty()) {
            System.out.println(-1);
            return;
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < list.size(); i++) {
            res = Math.min(dis1[list.get(i)[0]][list.get(i)[1]] + dis2[list.get(i)[0]][list.get(i)[1]], res);
        }
        System.out.println(res);

    }

    private static int[][] BFS(char[][] map, int x, int y, int r) {
        int n = map.length, m = map[0].length;
        int dis[][] = new int[n][m];
        boolean[][] vis = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(map[i][j] == '*' || Math.abs(i - x) + Math.abs(j - y) > r){
                    dis[i][j] = -1;
                    vis[i][j] = true;
                }
            }
        }
        Queue<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{x,y});vis[x][y] = true;
        int len = 1;int cnt = 0;
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            dis[cur[0]][cur[1]] = cnt;
            len--;
            for (int i = 0; i < dir.length; i++) {
                x = cur[0] + dir[i][0];y = cur[1] + dir[i][1];
                if(isVaild(x, y, n, m) && map[x][y] != '*' && !vis[x][y]){
                    queue.offer(new int[]{x,y});
                    vis[x][y] = true;
                }
            }
            if(len == 0){
                len = queue.size();
                cnt++;
            }
        }
        return dis;

    }

    private static boolean isVaild(int x, int y, int n, int m) {
        if(x >= n || x < 0) return false;
        if(y >= m || y < 0) return false;
        return true;
    }
}
"
14,C,Java,54841204,2022-11-18 20:15:38,刘映辰,答案错误,"import java.util.*;
import java.lang.*;

public class Main {
    static int[][] direction = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    static int n = 0;
    static int m = 0;
    
    public static void bfs(char[][] grid, int[][] array, int[] index, int distance){
        Deque<int[]> queue = new ArrayDeque<>();
        array[index[0]][index[1]] = 0;
        queue.add(index);
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if(dis < array[new_x][new_y]){
                            array[new_x][new_y] = dis;
                            queue.addLast(new int[]{new_x, new_y});
                        }
                    }
                }
            }
            dis += 1;
        }
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        int r1 = in.nextInt();
        int r2 = in.nextInt();
        in.nextLine();
        
        char[][] grid = new char[n][m];
        int[] person_index = new int[2];
        int[] cat_index = new int[2];
        
        for(int i = 0; i < n; i++){
            String temp = in.nextLine();
            for(int j = 0; j < m; j++){
                grid[i][j] = temp.charAt(j);
                if(grid[i][j] == 'P'){
                    person_index[0] = i;
                    person_index[1] = j;
                }
                
                if(grid[i][j] == 'M'){
                    cat_index[0] = i;
                    cat_index[1] = j;
                }
            }
        }
        
        int[][] person = new int[n][m];
        int[][] cat = new int[n][m];
        int max_step = 0x3f3f3f3f;
        for(int i = 0; i < n; i++){
            Arrays.fill(person[i], max_step);
            Arrays.fill(cat[i], max_step);
        }
        
        bfs(grid, person, person_index, r1);
        bfs(grid, cat, cat_index, r2);
        
        int result = max_step;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(person[i][j] != max_step && cat[i][j] != max_step && (Math.abs(i - person_index[0]) + Math.abs(j - person_index[1])) <= r1 && (Math.abs(i - cat_index[0]) + Math.abs(j - cat_index[1])) <= r2){
                    result = Math.min(result, person[i][j] + cat[i][j]);
                }     
            }
        }
        
        if(result >= max_step){
            result = -1;
        }
        
        System.out.println(result);
    }
}"
15,C,Java,54841239,2022-11-18 20:15:49,皮皮猪小飞侠,答案错误,"import java.util.*;

/**
 * @author xjf
 * @date 2022/11/18 18:49:44
 */
public class Main {
    public static int[][] dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();
        int r1 = scan.nextInt(), r2 = scan.nextInt();
        scan.nextLine();
        char[][] map = new char[n][m];
        int[] plmm = new int[2], cat = new int[2];
        for (int i = 0; i < n; i++) {
            String temp = scan.nextLine();
            for (int j = 0; j < m; j++) {
                map[i][j] = temp.charAt(j);
                if(map[i][j] == 'P') {
                    plmm[0] = i;plmm[1] = j;
                }else if(map[i][j] == 'M'){
                    cat[0] = i;cat[1] = j;
                }
            }
        }
        int[][] dis1 = BFS(map, plmm[0], plmm[1], r1);
        int[][] dis2 = BFS(map, cat[0], cat[1], Math.max(n,m));
        List<int[]> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
//                if(map[i][j] != '*' && Math.abs(i - plmm[0]) + Math.abs(j - plmm[1]) <= r1 &&
//                        Math.abs(i - cat[0]) + Math.abs(j - cat[1]) <= r2){
//                    list.add(new int[]{i, j});
//                }
                if(dis1[i][j] != -1 &&  Math.abs(i - cat[0]) + Math.abs(j - cat[1]) <= r2){
                    list.add(new int[]{i,j});
                }
            }
        }
        if(list.isEmpty()) {
            System.out.println(-1);
            return;
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < list.size(); i++) {
            res = Math.min(dis1[list.get(i)[0]][list.get(i)[1]] + dis2[list.get(i)[0]][list.get(i)[1]], res);
        }
        System.out.println(res);

    }

    private static int[][] BFS(char[][] map, int x, int y, int r) {
        int n = map.length, m = map[0].length;
        int dis[][] = new int[n][m];
        boolean[][] vis = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(map[i][j] == '*' || Math.abs(i - x) + Math.abs(j - y) > r){
                    dis[i][j] = -1;
                    vis[i][j] = true;
                }
            }
        }
        Queue<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{x,y});vis[x][y] = true;
        int len = 1;int cnt = 0;
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            dis[cur[0]][cur[1]] = cnt;
            len--;
            for (int i = 0; i < dir.length; i++) {
                x = cur[0] + dir[i][0];y = cur[1] + dir[i][1];
                if(isVaild(x, y, n, m) && map[x][y] != '*' && !vis[x][y]){
                    queue.offer(new int[]{x,y});
                    vis[x][y] = true;
                }
            }
            if(len == 0){
                len = queue.size();
                cnt++;
            }
        }
        return dis;

    }

    private static boolean isVaild(int x, int y, int n, int m) {
        if(x >= n || x < 0) return false;
        if(y >= m || y < 0) return false;
        return true;
    }
}
"
16,C,Java,54841514,2022-11-18 20:17:10,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,mx,my,px,py;
        int[] x = {-1,0,1,0};
        int[] y = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] map1 = new int[1005][1005];
        int[][] map2 = new int[1005][1005];

        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];

        Deque<Node> q = new ArrayDeque<>();
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        void bfs(int givex,int givey,int id){
            int[][] vis = new int[1005][1005];
            vis[givex][givey] = 1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1&&map1[now.x][now.y]==1&&map2[now.x][now.y]==2){
                    cnt1[now.x][now.y]=cnt1[now.x][now.y]==0?now.step:Math.min(cnt1[now.x][now.y],now.step);
                }
                if(id==2&&map2[now.x][now.y]==2){
                    cnt2[now.x][now.y]=cnt2[now.x][now.y]==0?now.step:Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+x[i];
                    int ny = now.y+y[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                    else if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    int c1 = Math.abs(i-mx)+Math.abs(j-my);
                    int c2 = Math.abs(i-px)+Math.abs(j-py);
                    if(c1>=0&&c1<=r2)
                        map1[i][j]=1;
                    if(c2>=0&&c2<=r1)
                        map2[i][j]=2;
                }
            }
            q.offer(new Node(mx,my,0));
            bfs(mx,my,1);
            q.clear();
            q.offer(new Node(px,py,0));
            bfs(px,py,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map1[i][j]==1&&map2[i][j]==2&&(cnt1[i][j]!=0||cnt2[i][j]!=0)){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.println(map1[i][j]+"" ""+map2[i][j]+"" ""+cnt1[i][j]+"" ""+cnt2[i][j]);
//                }
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);




        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
17,C,Java,54842586,2022-11-18 20:22:50,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,mx,my,px,py;
        int[] x = {-1,0,1,0};
        int[] y = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] map1 = new int[1005][1005];
        int[][] map2 = new int[1005][1005];

        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];

        Deque<Node> q = new ArrayDeque<>();
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        void bfs(int givex,int givey,int id){
            int[][] vis = new int[1005][1005];
            vis[givex][givey] = 1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1&&map1[now.x][now.y]==1&&map2[now.x][now.y]==2){
                    cnt1[now.x][now.y]=cnt1[now.x][now.y]==-1?now.step:Math.min(cnt1[now.x][now.y],now.step);
                }
                if(id==2&&map2[now.x][now.y]==2){
                    cnt2[now.x][now.y]=cnt2[now.x][now.y]==-1?now.step:Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+x[i];
                    int ny = now.y+y[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                    else if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    cnt1[i][j]=-1;
                    cnt2[i][j]=-1;
                    int c1 = Math.abs(i-mx)+Math.abs(j-my);
                    int c2 = Math.abs(i-px)+Math.abs(j-py);
                    if(c1>=0&&c1<=r2)
                        map1[i][j]=1;
                    if(c2>=0&&c2<=r1)
                        map2[i][j]=2;
                }
            }
            q.offer(new Node(mx,my,0));
            bfs(mx,my,1);
            q.clear();
            q.offer(new Node(px,py,0));
            bfs(px,py,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map1[i][j]==1&&map2[i][j]==2&&cnt1[i][j]!=-1&&cnt2[i][j]!=-1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.println(map1[i][j]+"" ""+map2[i][j]+"" ""+cnt1[i][j]+"" ""+cnt2[i][j]);
//                }
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);




        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
18,C,Java,54842820,2022-11-18 20:24:00,牛客935801330号（人工智能3211吴华聪）,运行超时,"


import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int vis[][]=new int[1003][1003];
        int n=0,m=0,r1=0,r2=0;
        char map[][]=new char[n+1][m+1];
        int x1=0,y1=0,x2=0,y2=0,min=10000000,f=0;
        int d[][]={{1,0},{-1,0},{0,1},{0,-1}};
        boolean check(int x,int y){
            if(x<=0||x>n||y<=0||y>m||vis[x][y]==1||map[x][y]=='*'){
                return false;
            }
            else {
                return true;
            }
        }
        void dfs(int x,int y,int r,int sum){
            if(x==x2&&y==y2){
                f=1;
                min=Math.min(min,sum);
                return;
            }
            int xx=Math.abs(x-x2);
            int yy=Math.abs(y-y2);
            int zz=xx+yy;
            if(zz>=0&&zz<=r2){
                r=1;
            }
            for (int i = 0; i <4 ; i++) {
              int x4=x+d[i][0];
              int y4=y+d[i][1];
              if(r==1){
                  if(check(x4,y4)){
                      vis[x4][y4]=1;
                      dfs(x4,y4,r,sum+1);
                      vis[x4][y4]=0;
                  }
              }
              else {

                  int x5=Math.abs(x4-x1);
                  int y5=Math.abs(y4-y1);
                  int z5=x5+y5;
                  if(z5>=0&&z5<=r1){
                      if(check(x4,y4)){
                          vis[x4][y4]=1;
                          dfs(x4,y4,r,sum+1);
                          vis[x4][y4]=0;
                      }
                  }
                  else {

                  }
              }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n=in.nextInt();
            m=in.nextInt();
            r1= in.nextInt();
            r2=in.nextInt();
            map=new char[n+1][m+1];
            for (int i = 0; i < n; i++) {
                String s=in.next();
                for (int j = 0; j <m ; j++) {
                    map[i+1][j+1]=s.charAt(j);
                    if(s.charAt(j)=='M'){
                        x2=i+1;
                        y2=j+1;
                    }
                    else if(s.charAt(j)=='P'){
                        x1=i+1;
                        y1=j+1;
                    }
                }
            }
            dfs(x1,y1,0,0);
            if(f==1){
                out.println(min);
            }
            else {
                out.println(-1);
            }
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}"
19,C,Java,54843670,2022-11-18 20:29:05,可爱抱抱呀😥,答案错误,"//Java快读快写模板，不定时更新优化内容
//@可爱抱抱呀
import java.util.*;
import java.io.*;
import java.math.*;
import java.text.*;
public class Main{
    static int move[][]={{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String args[]) throws IOException{
        Read sc=new Read();
        int n=sc.nextInt();
        int m=sc.nextInt();
        int r1=sc.nextInt();
        int r2=sc.nextInt();
        char c[][]=new char[n][];
        for(int i=0;i<n;i++){
            c[i]=sc.next().toCharArray();
        }
        //两个人的位置
        int mm[]=find(c,'M');
        int pp[]=find(c,'P');
        int dm[][]=dis(c,mm,m*n+1);
        int dp[][]=dis(c,pp,r1);
        if(Math.abs(mm[0]-pp[0])+Math.abs(mm[1]-pp[1])<=r1){
            sc.println(dm[pp[0]][pp[1]]);
        }
        else{
            int ans=10000000;
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(Math.abs(i-mm[0])+Math.abs(j-mm[1])==r2&&dm[i][j]!=-1&&dp[i][j]!=-1){
                        ans=Math.min(ans,dm[i][j]+dp[i][j]);
                    }
                }
            }
            sc.println(ans==10000000?-1:ans);
        }
        //sc.print(0);
        sc.bw.flush();
        sc.bw.close();
    }
    static int[][] dis(char c[][],int pp[],int max){
        int ans[][]=new int[c.length][c[0].length];
        for(int i=0;i<c.length;i++){
            Arrays.fill(ans[i],-1);
        }
        ans[pp[0]][pp[1]]=0;
        Queue<int[]> q=new LinkedList<>();
        q.add(pp);
        while(q.size()>0){
            int aa[]=q.poll();
            if(ans[aa[0]][aa[1]]>=max){
                continue;
            }
            for(int m[]:move){
                int x=aa[0]+m[0],y=aa[1]+m[1];
                if(x<0||x==c.length||y<0||y==c[0].length||ans[x][y]!=-1||c[x][y]=='*'){
                    continue;
                }
                ans[x][y]=ans[aa[0]][aa[1]]+1;
                q.add(new int[]{x,y});
            }
        }
        return ans;
    }
    public static int[] find(char c[][],char ch){
        for(int i=0;i<c.length;i++){
            for(int j=0;j<c[0].length;j++){
                if(c[i][j]==ch){
                    return new int[]{i,j};
                }
            }
        }
        return new int[]{-1,-1};
    }
}
//记住看数字范围，需要开long吗，需要用BigInteger吗，需要手动处理字符串吗，复杂度数量级控制在1e7或者以下了吗
//开数组的数据范围最高 @可爱抱抱 不能超过1e7，数据范围再大就要用哈希表离散化了
//基本数据类型不能自定义sort排序，二维数组就可以了，顺序排序的时候是小减大，注意返回值应该是int
class Read{
    BufferedReader bf;
    StringTokenizer st;
    BufferedWriter bw;
    public Read(){
        bf=new BufferedReader(new InputStreamReader(System.in));
        st=new StringTokenizer("""");
        bw=new BufferedWriter(new OutputStreamWriter(System.out));
        //什么时候才能持续稳定ak力扣、AcWing呢？
        //什么时候才能ak cf的div2，div1呢？才能打div2不计rating呢？
        //什么时候才能ak  abc  不计rating呢？
        //什么时候才能ak 牛客练习赛不计rating呢?
    }
    public String nextLine() throws IOException{
        return bf.readLine();
    }
    public String next() throws IOException{
        while(!st.hasMoreTokens()){
            st=new StringTokenizer(bf.readLine());
        }
        return st.nextToken();
    }
    public char nextChar() throws IOException{
        // 确定下一个@可爱抱抱 只有一个字符的时候再用
        return next().charAt(0);
    }
    public int nextInt() throws IOException{
        return Integer.parseInt(next());
    }
    public long nextLong() throws IOException{
        return Long.parseLong(next());
    }
    public double nextDouble() throws IOException{
        return Double.parseDouble(next());
    }
    public BigInteger nextBigInteger() throws IOException{
        return new BigInteger(next());
    }
    public void println(int a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
    public void print(int a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void println(String a) throws IOException{
        bw.write(a);
        bw.newLine();
        return;
    }
    public void print(String a) throws IOException{
        bw.write(a);
        return;
    }
    public void println(long a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
    public void print(long a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void println(double a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
    public void print(double a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void print(BigInteger a) throws IOException{
        bw.write(a.toString());
        return;
    }
    public void print(char a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void println(char a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
}"
20,C,Java,54843671,2022-11-18 20:29:05,刘映辰,答案正确,"import java.util.*;
import java.lang.*;

public class Main {
    static int[][] direction = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    static int n = 0;
    static int m = 0;
    static int r1 = 0;
    static int r2 = 0;
    static char[][] grid;
    static int[] person_index;
    static int[] cat_index;
    static int[][] person;
    static int[][] cat;
    
    public static void person_function(){
        Deque<int[]> queue = new ArrayDeque<>();
        
        person[person_index[0]][person_index[1]] = 0;
        queue.add(person_index);
        
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if(dis < person[new_x][new_y]){
                            person[new_x][new_y] = dis;
                            if((Math.abs(new_x - cat_index[0]) + Math.abs(new_y - cat_index[1])) > r2){
                                queue.addLast(new int[]{new_x, new_y});
                            }
                        }
                    }
                }
            }
            dis += 1;
        }
    }
    
    public static void cat_function(){
        Deque<int[]> queue = new ArrayDeque<>();
        
        cat[cat_index[0]][cat_index[1]] = 0;
        queue.add(cat_index);
        
        int dis = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] current = queue.pollFirst();
                for(int j = 0; j < 4; j++){
                    int new_x = current[0] + direction[j][0];
                    int new_y = current[1] + direction[j][1];
                    if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < m && grid[new_x][new_y] != '*'){
                        if(dis < cat[new_x][new_y]){
                            cat[new_x][new_y] = dis;
                            queue.addLast(new int[]{new_x, new_y});
                        }
                    }
                }
            }
            dis += 1;
        }
    }	
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        r1 = in.nextInt();
        r2 = in.nextInt();
        in.nextLine();
        
        grid = new char[n][m];
        person_index = new int[2];
        cat_index = new int[2];
        
        for(int i = 0; i < n; i++){
            String temp = in.nextLine();
            for(int j = 0; j < m; j++){
                grid[i][j] = temp.charAt(j);
                if(grid[i][j] == 'P'){
                    person_index[0] = i;
                    person_index[1] = j;
                }
                
                if(grid[i][j] == 'M'){
                    cat_index[0] = i;
                    cat_index[1] = j;
                }
            }
        }
        
        person = new int[n][m];
        cat = new int[n][m];
        int max_step = 0x3f3f3f3f;
        for(int i = 0; i < n; i++){
            Arrays.fill(person[i], max_step);
            Arrays.fill(cat[i], max_step);
        }
        
        person_function();
        cat_function();
        
        int result = max_step;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(person[i][j] != max_step && cat[i][j] != max_step && (Math.abs(i - person_index[0]) + Math.abs(j - person_index[1])) <= r1 && (Math.abs(i - cat_index[0]) + Math.abs(j - cat_index[1])) <= r2){
                    result = Math.min(result, person[i][j] + cat[i][j]);
                }     
            }
        }
        
        if(result >= max_step){
            result = -1;
        }
        
        System.out.println(result);
    }
}"
21,C,Java,54844087,2022-11-18 20:31:20,我不叫jhy,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n= in.nextInt();
            int m= in.nextInt();
            int r1= in.nextInt();
            int r2= in.nextInt();
            int mx=0,my=0,px=0,py=0;
            int[][]dt=new int[m+2][n+2];
            int[][]vt=new int[m+2][n+2];
            int[][]pt=new int[m+2][n+2];
            int[]fx={1,-1,0,0};
            int[]fy= {0,0,1,-1};
            for (int i = 0; i <n; i++) {
                String z= in.next();
                for (int j = 0; j <m; j++) {
                    if (z.charAt(j)==46)dt[j+1][i+1]=1;
                    else if (z.charAt(j)==77){
                        mx=j+1;my=i+1;
                        vt[j+1][i+1]=-1;
                    }
                    else if (z.charAt(j)==80){
                        dt[j+1][i+1]=1;
                        pt[j+1][i+1]=-1;
                        px=j+1;py=i+1;
                    }
                }
            }
            ArrayList<ArrayList<A>>bfs=new ArrayList<>();
            A a=new A();
            a.x=mx;
            a.y=my;
            ArrayList<A>al=new ArrayList<>();
            al.add(a);
            int i=0;
            ArrayList<A>cd=new ArrayList<>();
            while (vt[px][py]==0&&!al.isEmpty()) {
                bfs.add(al);
                al = new ArrayList<>();
                for (A a1 : bfs.get(i)) {
                    for (int j = 0; j <4; j++) {
                        int jx=fx[j];
                        int jy=fy[j];
                        a=new A();
                        a.x=a1.x+jx;
                        a.y=a1.y+jy;
                        if (dt[a.x][a.y]!=0&&vt[a.x][a.y]==0&&Math.abs(a.x-mx)+Math.abs(a.y-my)<=r2){
                            al.add(a);
                            vt[a.x][a.y]=i+1;
                            if (Math.abs(a.x-mx)+Math.abs(a.y-my)==r2)cd.add(a);
                        }
                    }
                }
                i++;
            }
            bfs=new ArrayList<>();
            a=new A();
            a.x=px;
            a.y=py;
            al=new ArrayList<>();
            al.add(a);
            i=0;
            int min=n*m;
            while (!al.isEmpty()&&vt[px][py]==0) {
                bfs.add(al);
                al = new ArrayList<>();
                for (A a1 : bfs.get(i)) {
                    for (int j = 0; j <4; j++) {
                        int jx=fx[j];
                        int jy=fy[j];
                        a=new A();
                        a.x=a1.x+jx;
                        a.y=a1.y+jy;
                        if (dt[a.x][a.y]!=0&&pt[a.x][a.y]==0&&Math.abs(a.x-px)+Math.abs(a.y-py)<=r1){
                            al.add(a);
                            pt[a.x][a.y]=i+1;
                            if (vt[a.x][a.y]!=0&&pt[a.x][a.y]+vt[a.x][a.y]<min)min=pt[a.x][a.y]+vt[a.x][a.y];
                        }
                    }
                }
                i++;
            }
            if (vt[px][py]!=0) System.out.println(vt[px][py]);
else if (min!=n*m) System.out.println(min);
else System.out.println(-1);

        }class A{
            int x,y;
        }


        }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}"
22,C,Java,54844097,2022-11-18 20:31:24,陈力明,答案错误,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandles;
import java.util.*;



import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
 
public class Main{
 
static int []f;
//static int []f2;
static int []size;
//static int []size2;
//static int []a=new int [500001];
static int max=Integer.MAX_VALUE;

static Set<Integer>set;
static int k;
static long mod= 998244353;
static int res=1;
static int n,m;
static int x1,y1;
 static List<Integer>[]ans;
 static char [][]c;
 private static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
	public static void main(String []args) {
		MyScanner s=new MyScanner();
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		n=s.nextInt();
		m=s.nextInt();
		int r1=s.nextInt();
		int r2=s.nextInt();
		c=new char [n][m];
		for(int i=0;i<n;i++)
			c[i]=s.next().toCharArray();
		int x1=0,y1=0,y2=0,x2=0;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if(c[i][j]=='M')
				{
					x1=i;
					y1=j;
				}
				if(c[i][j]=='P')
				{
					x2=i;
					y2=j;		
				}
			}
		}
		int [][]a=new int [n][m];
		int [][]b=new int [n][m];
		for(int i=0;i<n;i++)
		{
			Arrays.fill(a[i], -1);
			Arrays.fill(b[i], -1);
		}
		bfs(a,x2,y2);
		bfs(b,x1,y1);
		int max=Integer.MAX_VALUE;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if(Math.abs(x2-i)+Math.abs(y2-j)<=r1&&Math.abs(x1-i)+Math.abs(y1-j)<=r2&&a[i][j]!=-1&&b[i][j]!=-1)
				{
					max=Math.min(max, a[i][j]+b[i][j]);
				}
			}
		}
			if(max==Integer.MAX_VALUE)out.println(-1);
			else out.println(max);
		
		
	
	out.close();
	}
	 private static void bfs(int[][] st, int a, int b) {
	        Queue<int[]> q = new LinkedList<>();
	        q.add(new int[]{a, b});
	        st[a][b] = 0;
	        while (!q.isEmpty()) {
	            int[] t = q.poll();
	            int x = t[0], y = t[1];
	            for (int i = 0; i < 4; i++) {
	                int nx = x + dx[i];
	                int ny = y + dy[i];
	                if (nx <n && nx >= 0 && ny <m && ny >= 0 && c[nx][ny] != '*' && st[nx][ny] == -1) {
	                    q.add(new int[]{nx, ny});
	                    st[nx][ny] = st[x][y] + 1;
	                }
	            }
	        }
	    }
	public static boolean is(String a,String b)
	{
		for(int i=0;i<=b.length()-a.length();i++)
		{
			if(b.substring(i,i+a.length()).equals(a))
				return true;
		}
		return false;
		
	}
	public  static void dfs(int u,int k,List <Integer>[]list)
	{
		res=Math.max(res,k);
		for(int x:list [u])
		{
			boolean c=false;
			int kk=0;
			int min=Math.min(f[u], f[x]);
			for(int b:ans[min])
			{
				if(f[u]%b==0&&f[x]%b==0)
				{
					kk++;
					if(kk>=2) {
					c=true;break;
					}
					
				}
				
			}
			if(c)
				dfs(x,k+1,list);
			else dfs(x,1,list);
		}
				
			
		
		
	}
	
	
	  public static boolean is(long n) {
		    if (n <= 3) {
		        return n > 1;
		    }
		    // 只有6x-1和6x+1的数才有可能是质数
		    if (n % 6 != 1 && n % 6 != 5) {
		        return false;
		    }
		    // 判断这些数能否被小于sqrt(n)的奇数整除
		    int sqrt = (int) Math.sqrt(n);
		    for (int i = 5; i <= sqrt; i += 6) {
		        if (n % i == 0 || n % (i + 2) == 0) {
		            return false;
		        }
		    }
		    return true;
		}
	public static  long find(long k)
	{
		long l=0;long r=(long)2e7;
		while(l<r)
		{
			long mid=l+r>>1;
			if(mid*mid>=k)r=mid;
			else l=mid+1;
		}
		return l;
	}
	public static boolean is(int x,int y,int k,int [][]f)
	{
		int ans=1;
		
		for(int i=x-1;i>=0;i--)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1;i<f.length;i++)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=y-1;i>=0;i--)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		for(int i=y+1;i<f[0].length;i++)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y-1;i>=0&&j>=0;i--,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y+1;i<f.length&&j<f[0].length;i++,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y+1;i>=0&&j<f[0].length;i--,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y-1;i<f.length&&j>=0;i++,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		return false;
	}
	
		
	
	
public static void dfs(int x,int y,char [][]c,int [][]v){
	if(v[x][y]!=0)
	{
		return ;
	}
	int []dx={1,-1,0,0};
	
	int []dy= {0,0,1,-1};
	
	v[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int x1=x+dx[i];
		
		int y1=y+dy[i];
		if(x1<0||x1>=v.length||y1<0||y1>=v[0].length||v[x1][y1]==1||c[x1][y1]=='#')continue;
		dfs(x1,y1,c,v);
		
	}
		
		
}	
public static void swap(int []a) {
		int l=0,r=a.length-1;
		while(l<r) {
			int t=a[l];
			a[l]=a[r];
			a[r]=t;
			l++;r--;
		}
	}
public static boolean is(int j) {
		for(int i=2;i<=(int )Math.sqrt(j);i++) {
			if(j%i==0)return false;
		}
		return true;
	}
	 
public static int find (int []father,int x) {
		if(x!=father[x])
			x=find(father,father[x]);
		return father[x];
	}
public static void union(int []father,int x,int y,int []size) {
	x=find(father,x);
	y=find(father,y);
	if(x==y)
		return ;
	if(size[x]<size[y]) {
		 int tem=x;
         x=y;
         y=tem;
	}
	father[y]=x;
	size[x]+=size[y];
return ;
}
		
					
public static void shufu(int []f) {
		for(int i=0;i<f.length;i++) {
			int k=(int)(Math.random()*(f.length));
			int t=f[k];
			
			f[k]=f[0];
			f[0]=t;
			
		}
	}
public static void shufu1(long []f) {
	for(int i=0;i<f.length;i++) {
		int k=(int)(Math.random()*(f.length));
		long t=f[k];
		f[k]=f[0];
		f[0]=t;
	}
}
public  static int  gcd(int x,int y) {
		return y==0?x:gcd(y,x%y);
	}
 
 
public  static int  lcm(int x,int y) {
		
		return x*y/gcd(x,y);
}
		
	
	
		
		
	
	
		
	
/*					
public static void buildertree(int k,int l,int r) {
		if(l==r)
		{
			f[k]=a[l];
			return ;
		}
		int m=l+r>>1;
		buildertree(k+k,l,m);
		buildertree(k+k+1,m+1,r);
		f[k]=	
	
	}
public static	void update(int u,int l,int r,int x,int c)
{
    if(l==x && r==x)
    {
        f[u]=c;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)update(u<<1,l,mid,x,c);
    else if(x>=mid+1)update(u<<1|1,mid+1,r,x,c);
   	f[u]=Math.max(f[u+u], f[u+u+1]);
}
	
public static int query(int k,int l,int r,int x,int y) {
		if(x==l&&y==r) {
			return f[k];
		}
		int m=l+r>>1;
		if(y<=m) {
			return query(k+k,l,m,x,y);
		}
		else if(x>m)return query(k+k+1,m+1,r,x,y);
		else  {
			int i=query(k+k,l,m,x,m),j=query(k+k+1,m+1,r,m+1,y);
		return Math.max(j, Math.max(i+j, i));
		
		}
	}
	
public static void calc(int k,int l,int r,int x,int z) {
 
			f[k]+=z;
			if(l==r) {
				return ;
			}
			int m=l+r>>1;
    		if(x<=m)
    			calc(k+k,l,m,x,z);
    		else calc(k+k+1,m+1,r,x,z);
			
			
		}
	
				
			
 
		*/
		
				
	
			
	
			
	
 
	public static class MyScanner {
	    BufferedReader br;
	    StringTokenizer st;
	 
	    public MyScanner() {
	      try {
	        final String USERDIR = System.getProperty(""user.dir"");
	        String cname = MethodHandles.lookup().lookupClass().getCanonicalName().replace("".MyScanner"", """");
	        cname = cname.lastIndexOf('.') > 0 ? cname.substring(cname.lastIndexOf('.') + 1) : cname;
	        final File fin = new File(USERDIR + ""/io/c"" + cname.substring(1,5) + ""/"" + cname + "".in"");
	        br = new BufferedReader(new InputStreamReader(fin.exists()
	            ? new FileInputStream(fin) : System.in));
	      } catch (Exception e) {
	        br = new BufferedReader(new InputStreamReader(System.in));
	      }
	    }
	 
	    public String next() {
	      try {
	        while (st == null || !st.hasMoreElements()) {
	          st = new StringTokenizer(br.readLine());
	        }
	        return st.nextToken();
	      } catch (Exception e) {
	        throw new RuntimeException(e);
	      }
	    }
	 
	    public int nextInt() {
	      return Integer.parseInt(next());
	    }
	 
	    public long nextLong() {
	      return Long.parseLong(next());
	    }
	  }
	
		}"
23,C,Java,54844264,2022-11-18 20:32:17,牛客489187966号,答案错误,"
import java.io.*;
import java.util.*;

public class Main {

    static int N = 1010, sx, sy, ex, ey, INF = 0x3f3f3f3f;
    static char[][] map = new char[N][N];
    static int[][] step = new int[N][N];
    static int[][] df = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    public static void main(String[] args) throws IOException {
        initReader();
        int n = nextInt();
        int m = nextInt();
        int r1 = nextInt();
        int r2 = nextInt();

        for (int i = 1; i <= n; i++) {
            String s = next();
            char[] chars = s.toCharArray();
            for (int j = 1; j <= m; j++) {
                map[i][j] = chars[j - 1];
                if (map[i][j] == 'P') {
                    sx = i;
                    sy = j;
                }
                if (map[i][j] == 'M') {
                    ex = i;
                    ey = j;
                }
            }
        }

        int dis1 = INF;
        int tx = 0, ty = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{sx, sy});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            if (Math.abs(ex - x) + Math.abs(ey - y) <= r2) {
                dis1 = step[x][y];
                tx = x;
                ty = y;
                break;
            }
            if (Math.abs(sx - x) + Math.abs(sy - y) > r1) {
                break;
            }

        
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && step[nx][ny] == 0) {
                    queue.add(new int[]{nx, ny});
                    step[nx][ny] = step[x][y] + 1;
                }
            }
        }

        if (dis1 == INF) {
            pw.println(""-1"");
            pw.close();
            return;
        }

        for (int i = 0; i < N; i++) Arrays.fill(step[i], 0);
        queue.clear();
        queue.add(new int[]{ex, ey});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            if (x == tx &&y == ty) break;
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && step[nx][ny] == 0) {
                    queue.add(new int[]{nx,ny});
                    step[nx][ny] = step[x][y] + 1;
                }
            }
        }
        if (step[tx][ty] == 0) {
            pw.println(""-1"");
            pw.close();
            return;
        }
        pw.println(dis1 + step[tx][ty]);


        pw.close();
    }


    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter pw;

    public static void initReader() throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = new StringTokenizer("""");
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    }


    public static boolean hasNext() {
        try {
            while (!tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(reader.readLine());
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        try {
            return reader.readLine();
        } catch (Exception e) {
            return null;
        }
    }

    public static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    public static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

    public static char nextChar() throws IOException {
        return next().charAt(0);
    }
}
"
24,C,Java,54844524,2022-11-18 20:33:50,可爱抱抱呀😥,答案正确,"//Java快读快写模板，不定时更新优化内容
//@可爱抱抱呀
import java.util.*;
import java.io.*;
import java.math.*;
import java.text.*;
public class Main{
    static int move[][]={{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String args[]) throws IOException{
        Read sc=new Read();
        int n=sc.nextInt();
        int m=sc.nextInt();
        int r1=sc.nextInt();
        int r2=sc.nextInt();
        char c[][]=new char[n][];
        for(int i=0;i<n;i++){
            c[i]=sc.next().toCharArray();
        }
        //两个人的位置
        int mm[]=find(c,'M');
        int pp[]=find(c,'P');
        int dm[][]=dis(c,mm,m*n+1);
        int dp[][]=dis(c,pp,r1);
        if(Math.abs(mm[0]-pp[0])+Math.abs(mm[1]-pp[1])<=r2){
            sc.println(dm[pp[0]][pp[1]]);
        }
        else{
            int ans=10000000;
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(Math.abs(i-mm[0])+Math.abs(j-mm[1])==r2&&dm[i][j]!=-1&&dp[i][j]!=-1){
                        ans=Math.min(ans,dm[i][j]+dp[i][j]);
                    }
                }
            }
            sc.println(ans==10000000?-1:ans);
        }
        //sc.print(0);
        sc.bw.flush();
        sc.bw.close();
    }
    static int[][] dis(char c[][],int pp[],int max){
        int ans[][]=new int[c.length][c[0].length];
        for(int i=0;i<c.length;i++){
            Arrays.fill(ans[i],-1);
        }
        ans[pp[0]][pp[1]]=0;
        Queue<int[]> q=new LinkedList<>();
        q.add(pp);
        while(q.size()>0){
            int aa[]=q.poll();
            if(ans[aa[0]][aa[1]]>=max){
                continue;
            }
            for(int m[]:move){
                int x=aa[0]+m[0],y=aa[1]+m[1];
                if(x<0||x==c.length||y<0||y==c[0].length||ans[x][y]!=-1||c[x][y]=='*'){
                    continue;
                }
                ans[x][y]=ans[aa[0]][aa[1]]+1;
                q.add(new int[]{x,y});
            }
        }
        return ans;
    }
    public static int[] find(char c[][],char ch){
        for(int i=0;i<c.length;i++){
            for(int j=0;j<c[0].length;j++){
                if(c[i][j]==ch){
                    return new int[]{i,j};
                }
            }
        }
        return new int[]{-1,-1};
    }
}
//记住看数字范围，需要开long吗，需要用BigInteger吗，需要手动处理字符串吗，复杂度数量级控制在1e7或者以下了吗
//开数组的数据范围最高 @可爱抱抱 不能超过1e7，数据范围再大就要用哈希表离散化了
//基本数据类型不能自定义sort排序，二维数组就可以了，顺序排序的时候是小减大，注意返回值应该是int
class Read{
    BufferedReader bf;
    StringTokenizer st;
    BufferedWriter bw;
    public Read(){
        bf=new BufferedReader(new InputStreamReader(System.in));
        st=new StringTokenizer("""");
        bw=new BufferedWriter(new OutputStreamWriter(System.out));
        //什么时候才能持续稳定ak力扣、AcWing呢？
        //什么时候才能ak cf的div2，div1呢？才能打div2不计rating呢？
        //什么时候才能ak  abc  不计rating呢？
        //什么时候才能ak 牛客练习赛不计rating呢?
    }
    public String nextLine() throws IOException{
        return bf.readLine();
    }
    public String next() throws IOException{
        while(!st.hasMoreTokens()){
            st=new StringTokenizer(bf.readLine());
        }
        return st.nextToken();
    }
    public char nextChar() throws IOException{
        // 确定下一个@可爱抱抱 只有一个字符的时候再用
        return next().charAt(0);
    }
    public int nextInt() throws IOException{
        return Integer.parseInt(next());
    }
    public long nextLong() throws IOException{
        return Long.parseLong(next());
    }
    public double nextDouble() throws IOException{
        return Double.parseDouble(next());
    }
    public BigInteger nextBigInteger() throws IOException{
        return new BigInteger(next());
    }
    public void println(int a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
    public void print(int a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void println(String a) throws IOException{
        bw.write(a);
        bw.newLine();
        return;
    }
    public void print(String a) throws IOException{
        bw.write(a);
        return;
    }
    public void println(long a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
    public void print(long a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void println(double a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
    public void print(double a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void print(BigInteger a) throws IOException{
        bw.write(a.toString());
        return;
    }
    public void print(char a) throws IOException{
        bw.write(String.valueOf(a));
        return;
    }
    public void println(char a) throws IOException{
        bw.write(String.valueOf(a));
        bw.newLine();
        return;
    }
}"
25,C,Java,54844963,2022-11-18 20:36:35,皮皮猪小飞侠,答案正确,"
import java.util.*;

/**
 * @author xjf
 * @date 2022/11/18 18:49:44
 */
public class Main {
    public static int[][] dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();
        int r1 = scan.nextInt(), r2 = scan.nextInt();
        scan.nextLine();
        char[][] map = new char[n][m];
        int[] plmm = new int[2], cat = new int[2];
        for (int i = 0; i < n; i++) {
            String temp = scan.nextLine();
            for (int j = 0; j < m; j++) {
                map[i][j] = temp.charAt(j);
                if(map[i][j] == 'P') {
                    plmm[0] = i;plmm[1] = j;
                }else if(map[i][j] == 'M'){
                    cat[0] = i;cat[1] = j;
                }
            }
        }
        int[][] dis1 = BFS(map, plmm[0], plmm[1], r1);
        int[][] dis2 = BFS(map, cat[0], cat[1], Math.max(n,m));
        List<int[]> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
//                if(map[i][j] != '*' && Math.abs(i - plmm[0]) + Math.abs(j - plmm[1]) <= r1 &&
//                        Math.abs(i - cat[0]) + Math.abs(j - cat[1]) <= r2){
//                    list.add(new int[]{i, j});
//                }
                if(dis1[i][j] != -1 &&  Math.abs(i - cat[0]) + Math.abs(j - cat[1]) <= r2){
                    list.add(new int[]{i,j});
                }
            }
        }
//        System.out.println(list.get(0)[0] + "" "" +list.get(0)[1]);
//        System.out.println(dis2[list.get(0)[0]][list.get(0)[1]]);
//        for (int i = 0; i < dis2.length; i++) {
//            for (int j = 0; j < dis2[0].length; j++) {
//                System.out.print(dis2[i][j] + "" "");
//            }
//            System.out.println();
//        }
        if(list.isEmpty()) {
            System.out.println(-1);
            return;
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < list.size(); i++) {
            if(dis2[list.get(i)[0]][list.get(i)[1]] != -1)
                res = Math.min(dis1[list.get(i)[0]][list.get(i)[1]] + dis2[list.get(i)[0]][list.get(i)[1]], res);
        }
        if(res == Integer.MAX_VALUE) {
            System.out.println(-1);
            return;
        }
        System.out.println(res);

    }

    private static int[][] BFS(char[][] map, int x, int y, int r) {
        int n = map.length, m = map[0].length;
        int xx = x, yy = y;
        int dis[][] = new int[n][m];
        boolean[][] vis = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(map[i][j] == '*' || Math.abs(i - x) + Math.abs(j - y) > r){
                    dis[i][j] = -1;
                    vis[i][j] = true;
                }
            }
        }
        Queue<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{x,y});vis[x][y] = true;
        int len = 1;int cnt = 0;
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            dis[cur[0]][cur[1]] = cnt;
            len--;
            for (int i = 0; i < dir.length; i++) {
                x = cur[0] + dir[i][0];y = cur[1] + dir[i][1];
                if(isVaild(x, y, n, m) && map[x][y] != '*' && !vis[x][y]){
                    queue.offer(new int[]{x,y});
                    vis[x][y] = true;
                }
            }
            if(len == 0){
                len = queue.size();
                cnt++;
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(dis[i][j] == 0 && !(i == xx && j == yy)){
                    dis[i][j] = -1;
                }
            }
        }
        return dis;

    }

    private static boolean isVaild(int x, int y, int n, int m) {
        if(x >= n || x < 0) return false;
        if(y >= m || y < 0) return false;
        return true;
    }
}
"
26,C,Java,54845196,2022-11-18 20:37:54,我不叫jhy,答案正确,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n= in.nextInt();
            int m= in.nextInt();
            int r1= in.nextInt();
            int r2= in.nextInt();
            int mx=0,my=0,px=0,py=0;
            int[][]dt=new int[m+2][n+2];
            int[][]vt=new int[m+2][n+2];
            int[][]pt=new int[m+2][n+2];
            int[]fx={1,-1,0,0};
            int[]fy= {0,0,1,-1};
            for (int i = 0; i <n; i++) {
                String z= in.next();
                for (int j = 0; j <m; j++) {
                    if (z.charAt(j)==46)dt[j+1][i+1]=1;
                    else if (z.charAt(j)==77){
                        mx=j+1;my=i+1;
                        vt[j+1][i+1]=-1;
                    }
                    else if (z.charAt(j)==80){
                        dt[j+1][i+1]=1;
                        pt[j+1][i+1]=-1;
                        px=j+1;py=i+1;
                    }
                }
            }
            ArrayList<ArrayList<A>>bfs=new ArrayList<>();
            A a=new A();
            a.x=mx;
            a.y=my;
            ArrayList<A>al=new ArrayList<>();
            al.add(a);
            int i=0;
            ArrayList<A>cd=new ArrayList<>();
            while (vt[px][py]==0&&!al.isEmpty()) {
                bfs.add(al);
                al = new ArrayList<>();
                for (A a1 : bfs.get(i)) {
                    for (int j = 0; j <4; j++) {
                        int jx=fx[j];
                        int jy=fy[j];
                        a=new A();
                        a.x=a1.x+jx;
                        a.y=a1.y+jy;
                        if (dt[a.x][a.y]!=0&&vt[a.x][a.y]==0){
                            al.add(a);
                            vt[a.x][a.y]=i+1;
                            if (Math.abs(a.x-mx)+Math.abs(a.y-my)==r2)cd.add(a);
                        }
                    }
                }
                i++;
            }
            bfs=new ArrayList<>();
            a=new A();
            a.x=px;
            a.y=py;
            al=new ArrayList<>();
            al.add(a);
            i=0;
            int min=n*m;
            while (!al.isEmpty()) {
                bfs.add(al);
                al = new ArrayList<>();
                for (A a1 : bfs.get(i)) {
                    for (int j = 0; j <4; j++) {
                        int jx=fx[j];
                        int jy=fy[j];
                        a=new A();
                        a.x=a1.x+jx;
                        a.y=a1.y+jy;
                        if (dt[a.x][a.y]!=0&&pt[a.x][a.y]==0&&Math.abs(a.x-px)+Math.abs(a.y-py)<=r1){
                            al.add(a);
                            pt[a.x][a.y]=i+1;
                            if (vt[a.x][a.y]!=0&&pt[a.x][a.y]+vt[a.x][a.y]<min&&Math.abs(a.x-mx)+Math.abs(a.y-my)<=r2)min=pt[a.x][a.y]+vt[a.x][a.y];
                        }
                    }
                }
                i++;
            }
            if (vt[px][py]!=0&&Math.abs(px-mx)+Math.abs(py-my)<=r2) System.out.println(vt[px][py]);
else if (min!=n*m) System.out.println(min);
else System.out.println(-1);
           // Math.abs(a.x-mx)+Math.abs(a.y-my)<=r2
        }class A{
            int x,y;
        }


        }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}"
27,C,Java,54845227,2022-11-18 20:38:03,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,mx,my,px,py;
        int[] x = {-1,0,1,0};
        int[] y = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] map1 = new int[1005][1005];
        int[][] map2 = new int[1005][1005];

        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];

        Deque<Node> q = new ArrayDeque<>();
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        void bfs(int givex,int givey,int id){
            int[][] vis = new int[1005][1005];
            vis[givex][givey] = 1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1&&map1[now.x][now.y]==1&&map2[now.x][now.y]==2){
                    cnt1[now.x][now.y]=cnt1[now.x][now.y]==-1?now.step:Math.min(cnt1[now.x][now.y],now.step);
                }
                if(id==2&&map1[now.x][now.y]==1&&map2[now.x][now.y]==2){
                    cnt2[now.x][now.y]=cnt2[now.x][now.y]==-1?now.step:Math.min(cnt2[now.x][now.y],now.step);
                }

                for (int i = 0; i < 4; i++) {
                    int nx = now.x+x[i];
                    int ny = now.y+y[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        if (vis[nx][ny] == 0&&map1[nx][ny]==1) {
                            vis[nx][ny] = 1;
                            q.offer(new Node(nx, ny, now.step + 1));
                        }
                    }
                    else if(id==2){
                        if (vis[nx][ny] == 0&&map2[nx][ny]==2) {
                            vis[nx][ny] = 1;
                            q.offer(new Node(nx, ny, now.step + 1));
                        }
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                    else if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    int c1 = Math.abs(i-mx)+Math.abs(j-my);
                    int c2 = Math.abs(i-px)+Math.abs(j-py);
                    if(c1>=0&&c1<=r2)
                        map1[i][j]=1;
                    if(c2>=0&&c2<=r1)
                        map2[i][j]=2;
                    cnt1[i][j]=-1;
                    cnt2[i][j]=-1;
                }
            }
            q.offer(new Node(mx,my,0));
            bfs(mx,my,1);
            q.clear();
            q.offer(new Node(px,py,0));
            bfs(px,py,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(cnt1[i][j]!=-1&&cnt2[i][j]!=-1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(cnt1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(cnt2[i][j]+"" "");
//                }
//                out.println();
//            }

//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.println(map1[i][j]+"" ""+map2[i][j]+"" ""+cnt1[i][j]+"" ""+cnt2[i][j]);
//                }
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);




        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
28,C,Java,54845637,2022-11-18 20:40:20,陈力明,答案错误,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandles;
import java.util.*;



import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
 
public class Main{
 
static int []f;
//static int []f2;
static int []size;
//static int []size2;
//static int []a=new int [500001];
static int max=Integer.MAX_VALUE;

static Set<Integer>set;
static int k;
static long mod= 998244353;
static int res=1;
static int n,m;
static int x1,y1;
 static List<Integer>[]ans;
 static char [][]c;
 private static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
	public static void main(String []args) {
		MyScanner s=new MyScanner();
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		n=s.nextInt();
		m=s.nextInt();
		int r1=s.nextInt();
		int r2=s.nextInt();
		c=new char [n][m];
		for(int i=0;i<n;i++)
			c[i]=s.next().toCharArray();
		int x1=0,y1=0,y2=0,x2=0;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if(c[i][j]=='M')
				{
					x1=i;
					y1=j;
				}
				if(c[i][j]=='P')
				{
					x2=i;
					y2=j;		
				}
			}
		}
		int [][]a=new int [n][m];
		int [][]b=new int [n][m];
		for(int i=0;i<n;i++)
		{
			Arrays.fill(a[i], -1);
			Arrays.fill(b[i], -1);
		}
		bfs(a,x2,y2);
		bfs(b,x1,y1);
		int max=Integer.MAX_VALUE;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if((Math.abs(x2-i)+Math.abs(y2-j))<=r1&&(Math.abs(x1-i)+Math.abs(y1-j))<=r2&&a[i][j]!=-1&&b[i][j]!=-1)
				{
					max=Math.min(max, a[i][j]+b[i][j]);
				}
			}
		}
			if(max==Integer.MAX_VALUE)out.println(-1);
			else out.println(max);
		
		
	
	out.close();
	}
	 private static void bfs(int[][] st, int a, int b) {
	        Queue<int[]> q = new LinkedList<>();
	        q.add(new int[]{a, b});
	        st[a][b] = 0;
	        while (!q.isEmpty()) {
	            int[] t = q.poll();
	            int x = t[0], y = t[1];
	            for (int i = 0; i < 4; i++) {
	                int nx = x + dx[i];
	                int ny = y + dy[i];
	                if (nx <n && nx >= 0 && ny <m && ny >= 0 && c[nx][ny] != '*' && st[nx][ny] == -1) {
	                    q.add(new int[]{nx, ny});
	                    st[nx][ny] = st[x][y] + 1;
	                }
	            }
	        }
	    }
	public static boolean is(String a,String b)
	{
		for(int i=0;i<=b.length()-a.length();i++)
		{
			if(b.substring(i,i+a.length()).equals(a))
				return true;
		}
		return false;
		
	}
	public  static void dfs(int u,int k,List <Integer>[]list)
	{
		res=Math.max(res,k);
		for(int x:list [u])
		{
			boolean c=false;
			int kk=0;
			int min=Math.min(f[u], f[x]);
			for(int b:ans[min])
			{
				if(f[u]%b==0&&f[x]%b==0)
				{
					kk++;
					if(kk>=2) {
					c=true;break;
					}
					
				}
				
			}
			if(c)
				dfs(x,k+1,list);
			else dfs(x,1,list);
		}
				
			
		
		
	}
	
	
	  public static boolean is(long n) {
		    if (n <= 3) {
		        return n > 1;
		    }
		    // 只有6x-1和6x+1的数才有可能是质数
		    if (n % 6 != 1 && n % 6 != 5) {
		        return false;
		    }
		    // 判断这些数能否被小于sqrt(n)的奇数整除
		    int sqrt = (int) Math.sqrt(n);
		    for (int i = 5; i <= sqrt; i += 6) {
		        if (n % i == 0 || n % (i + 2) == 0) {
		            return false;
		        }
		    }
		    return true;
		}
	public static  long find(long k)
	{
		long l=0;long r=(long)2e7;
		while(l<r)
		{
			long mid=l+r>>1;
			if(mid*mid>=k)r=mid;
			else l=mid+1;
		}
		return l;
	}
	public static boolean is(int x,int y,int k,int [][]f)
	{
		int ans=1;
		
		for(int i=x-1;i>=0;i--)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1;i<f.length;i++)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=y-1;i>=0;i--)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		for(int i=y+1;i<f[0].length;i++)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y-1;i>=0&&j>=0;i--,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y+1;i<f.length&&j<f[0].length;i++,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y+1;i>=0&&j<f[0].length;i--,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y-1;i<f.length&&j>=0;i++,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		return false;
	}
	
		
	
	
public static void dfs(int x,int y,char [][]c,int [][]v){
	if(v[x][y]!=0)
	{
		return ;
	}
	int []dx={1,-1,0,0};
	
	int []dy= {0,0,1,-1};
	
	v[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int x1=x+dx[i];
		
		int y1=y+dy[i];
		if(x1<0||x1>=v.length||y1<0||y1>=v[0].length||v[x1][y1]==1||c[x1][y1]=='#')continue;
		dfs(x1,y1,c,v);
		
	}
		
		
}	
public static void swap(int []a) {
		int l=0,r=a.length-1;
		while(l<r) {
			int t=a[l];
			a[l]=a[r];
			a[r]=t;
			l++;r--;
		}
	}
public static boolean is(int j) {
		for(int i=2;i<=(int )Math.sqrt(j);i++) {
			if(j%i==0)return false;
		}
		return true;
	}
	 
public static int find (int []father,int x) {
		if(x!=father[x])
			x=find(father,father[x]);
		return father[x];
	}
public static void union(int []father,int x,int y,int []size) {
	x=find(father,x);
	y=find(father,y);
	if(x==y)
		return ;
	if(size[x]<size[y]) {
		 int tem=x;
         x=y;
         y=tem;
	}
	father[y]=x;
	size[x]+=size[y];
return ;
}
		
					
public static void shufu(int []f) {
		for(int i=0;i<f.length;i++) {
			int k=(int)(Math.random()*(f.length));
			int t=f[k];
			
			f[k]=f[0];
			f[0]=t;
			
		}
	}
public static void shufu1(long []f) {
	for(int i=0;i<f.length;i++) {
		int k=(int)(Math.random()*(f.length));
		long t=f[k];
		f[k]=f[0];
		f[0]=t;
	}
}
public  static int  gcd(int x,int y) {
		return y==0?x:gcd(y,x%y);
	}
 
 
public  static int  lcm(int x,int y) {
		
		return x*y/gcd(x,y);
}
		
	
	
		
		
	
	
		
	
/*					
public static void buildertree(int k,int l,int r) {
		if(l==r)
		{
			f[k]=a[l];
			return ;
		}
		int m=l+r>>1;
		buildertree(k+k,l,m);
		buildertree(k+k+1,m+1,r);
		f[k]=	
	
	}
public static	void update(int u,int l,int r,int x,int c)
{
    if(l==x && r==x)
    {
        f[u]=c;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)update(u<<1,l,mid,x,c);
    else if(x>=mid+1)update(u<<1|1,mid+1,r,x,c);
   	f[u]=Math.max(f[u+u], f[u+u+1]);
}
	
public static int query(int k,int l,int r,int x,int y) {
		if(x==l&&y==r) {
			return f[k];
		}
		int m=l+r>>1;
		if(y<=m) {
			return query(k+k,l,m,x,y);
		}
		else if(x>m)return query(k+k+1,m+1,r,x,y);
		else  {
			int i=query(k+k,l,m,x,m),j=query(k+k+1,m+1,r,m+1,y);
		return Math.max(j, Math.max(i+j, i));
		
		}
	}
	
public static void calc(int k,int l,int r,int x,int z) {
 
			f[k]+=z;
			if(l==r) {
				return ;
			}
			int m=l+r>>1;
    		if(x<=m)
    			calc(k+k,l,m,x,z);
    		else calc(k+k+1,m+1,r,x,z);
			
			
		}
	
				
			
 
		*/
		
				
	
			
	
			
	
 
	public static class MyScanner {
	    BufferedReader br;
	    StringTokenizer st;
	 
	    public MyScanner() {
	      try {
	        final String USERDIR = System.getProperty(""user.dir"");
	        String cname = MethodHandles.lookup().lookupClass().getCanonicalName().replace("".MyScanner"", """");
	        cname = cname.lastIndexOf('.') > 0 ? cname.substring(cname.lastIndexOf('.') + 1) : cname;
	        final File fin = new File(USERDIR + ""/io/c"" + cname.substring(1,5) + ""/"" + cname + "".in"");
	        br = new BufferedReader(new InputStreamReader(fin.exists()
	            ? new FileInputStream(fin) : System.in));
	      } catch (Exception e) {
	        br = new BufferedReader(new InputStreamReader(System.in));
	      }
	    }
	 
	    public String next() {
	      try {
	        while (st == null || !st.hasMoreElements()) {
	          st = new StringTokenizer(br.readLine());
	        }
	        return st.nextToken();
	      } catch (Exception e) {
	        throw new RuntimeException(e);
	      }
	    }
	 
	    public int nextInt() {
	      return Integer.parseInt(next());
	    }
	 
	    public long nextLong() {
	      return Long.parseLong(next());
	    }
	  }
	
		}"
29,C,Java,54845866,2022-11-18 20:41:38,rookie1号,执行出错,"import java.io.*;
import java.util.*;
public class Main {
    
    static PrintWriter out = new PrintWriter(System.out);
    static Scanner in = new Scanner(System.in);
    static BufferedReader re = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out));
    //String[] strs = re.readLine().split("" ""); int a = Integer.parseInt(strs[0]);
    
    static int[][] dir={{1,0},{-1,0},{0,1},{0,-1}};
    static int n,m,xxx,yyy,x1,y1,r1,r2;
    static int ans[][];static char arr[][];
    static int vis[][];
    static int ans1[][];
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        //String[] strs = re.readLine().split("" "");
        //int T=Integer.parseInt(strs[0]);
        
        //int T=in.nextInt();
        int T=1;
        while(T>0){
            //String[] strs1 = re.readLine().split("" "");
            //int n=Integer.parseInt(strs1[0]);
            //String s=re.readLine();
            //char arr[]=s.toCharArray();

            //long[][] p = new long[n][2];//对 long 二维数组排序
            //Arrays.sort(p, (a, b) -> a[0] <= b[0] ? -1 : 1);
            //Set<Integer>set=new HashSet<>();
            //Map<Long,Integer>map=new HashMap<>();
            //Map<Integer,List<Integer>>map=new HashMap<>();
            //TreeSet<Integer> set = new TreeSet<>();
            //int max=0;int min=2100000000;
            n=in.nextInt();
            m=in.nextInt();
            r1=in.nextInt();
            r2=in.nextInt();
            arr=new char[n][m];
            xxx=0;yyy=0;
            x1=0;y1=0;
            for(int i=0;i<n;i++){
                String s=in.next();
                arr[i]=s.toCharArray();
                for(int j=0;j<m;j++){
                    if(arr[i][j]=='P'){
                        xxx=i;yyy=j;
                    }
                    if(arr[i][j]=='M'){
                        x1=i;y1=i;
                    }
                }
            }
            //out.println(xx+"" ""+yy);
            ans=new int [n][m];
            ans1=new int [n][m];
            bfs(x1,y1);
            bfs1(xxx,yyy);
            int res=9999999;
            int qqq=0;
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(ans1[i][j]!=0&&ans[i][j]!=0){
                        if(ans[i][j]+ans1[i][j]<res){
                            res=ans[i][j]+ans1[i][j];
                            qqq++;
                        
                        }
                    }
                    //out.print(ans[i][j]+"" "");
                }
                //out.println();
            }
            if(qqq==0)out.println(""-1"");
            else out.println(res);
            T--;
            }
        out.flush();
    }
    static void bfs(int xx,int yy){
        vis=new int[n][m];
        Queue<Node> q=new LinkedList<>();
        q.offer(new Node(xx,yy,0));
        vis[xx][yy]=1;
        while (!q.isEmpty()){
            Node head = q.poll();
            //int x=head.x;
            //int y=head.y;
            for (int i = 0; i < 4; i++) {
                int x=head.x+dir[i][0];
                int y=head.y+dir[i][1];
                if (x>=0&&x<n&&y>=0&&y<m&&arr[x][y]!='*'&&vis[x][y]==0){
                    vis[x][y]=1;
                    if((Math.abs(x-x1)+Math.abs(y-y1))<=r2)ans[x][y]+=head.dis+1;
                    q.offer(new Node(x,y,head.dis+1));
                }
            }
        }
    }
    static void bfs1(int xx,int yy){
        vis=new int[n][m];
        Queue<Node> q=new LinkedList<>();
        q.offer(new Node(xx,yy,0));
        vis[xx][yy]=1;
        while (!q.isEmpty()){
            Node head = q.poll();
            //int x=head.x;
            //int y=head.y;
            for (int i = 0; i < 4; i++) {
                int x=head.x+dir[i][0];
                int y=head.y+dir[i][1];
                if (x>=0&&x<n&&y>=0&&y<m&&arr[x][y]!='*'&&vis[x][y]==0){
                    vis[x][y]=1;
                    if(Math.abs(x-xxx)+Math.abs(y-yyy)<=r1)ans1[x][y]+=head.dis+1;
                    q.offer(new Node(x,y,head.dis+1));
                }
            }
        }
    }
    static class Node{
        int x,y,dis;
        public Node(int x, int y,int dis) {
            this.x = x;
            this.y = y;
            this.dis=dis;
        }
    }
}"
30,C,Java,54845889,2022-11-18 20:41:45,爱踢球的程序员,答案正确,"

import java.util.*;

public class Main {
    static int n, m, r1, r2, N = 1010, x1, x2, y1, y2,res=Integer.MAX_VALUE;
    static int[][] dir = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}},d=new int[N][N],st=new int[N][N];
    static char[][] c = new char[N][N];
    static boolean a=false;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        r1 = sc.nextInt();
        r2 = sc.nextInt();
        sc.nextLine();
        for (int i = 0; i < n; i++) {
            c[i] = sc.nextLine().toCharArray();
            for (int j = 0; j < m; j++) {
                if (c[i][j]=='P'){
                    x1=i;y1=j;
                }
                if (c[i][j]=='M'){
                    x2=i;y2=j;
                }
            }
        }
        bfs();
//        for (int i = 0; i < n; i++) {
//            for (int j = 0; j < m; j++) {
//                System.out.print(d[i][j]+"" "");
//            }
//            System.out.println();
//        }
        if (a) bfsm();
        System.out.println(res==Integer.MAX_VALUE?-1:res);
    }
    static void bfs(){
        Queue<Node> q=new LinkedList<>();
        int[][] vis=new int[N][N];
        q.offer(new Node(x1,y1,0));
        vis[x1][y1]=1;
        while (!q.isEmpty()){
            Node head = q.poll();
            for (int i = 0; i < 4; i++) {
                int x=head.x+dir[i][0];
                int y=head.y+dir[i][1];
                if (x>=0&&x<n&&Math.abs(x1-x)+Math.abs(y1-y)<=r1&&y>=0&&y<m
                        &&c[x][y]!='*'&&vis[x][y]!=1){
                    vis[x][y]=1;
                    if (Math.abs(x-x2)+Math.abs(y-y2)<=r2) {
                        d[x][y]=head.s+1;
                        st[x][y]=1;
                        a=true;
                        continue;
                    }
                    q.offer(new Node(x,y,head.s+1));
                }
            }
        }
    }

    static void bfsm(){
        Queue<Node> q=new LinkedList<>();
        int[][] vis=new int[N][N];
        q.offer(new Node(x2,y2,0));
        vis[x2][y2]=1;
        while (!q.isEmpty()){
            Node head = q.poll();
            for (int i = 0; i < 4; i++) {
                int x=head.x+dir[i][0];
                int y=head.y+dir[i][1];
                if (x>=0&&x<n&&y>=0&&y<m &&c[x][y]!='*'&&vis[x][y]!=1){
                    vis[x][y]=1;
                    if (st[x][y]==1){
                        d[x][y]+=head.s+1;
                        res=Math.min(res,d[x][y]);
                    }
                    q.offer(new Node(x,y,head.s+1));
                }
            }
        }
    }

    static class Node{
        int x,y,s;

        public Node(int x, int y, int s) {
            this.x = x;
            this.y = y;
            this.s = s;
        }
    }
}
"
31,C,Java,54846176,2022-11-18 20:43:36,闵其其,答案错误,"
import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int[][] next = {{1,0},{-1,0},{0,1},{0,-1}};
        char[][] map;
        int[][] smell;
        boolean[][] visit;
        int px,py,cx,cy,n,m,r1,r2;
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        void bfs(){
            Queue<Node> q = new LinkedList<Node>();
            q.offer(new Node(px,py,0));
            visit[px][py] = true;
            while(!q.isEmpty()){
                int x = q.element().x;
                int y = q.element().y;
                int step = q.element().step;
                q.poll();
                for (int i = 0; i < 4; i++) {
                    int tx = x + next[i][0];
                    int ty = y + next[i][1];
                    int temp = step + 1;
                    if(tx>=0&&tx<n&&ty>=0&&ty<m){
                        if((Math.abs(px-tx)+Math.abs(py-ty))>r1)
                            continue;
                        else {
                            if (!visit[tx][ty] && map[tx][ty] != '*') {
                                visit[tx][ty] = true;
                                if ((Math.abs(cx - tx) + Math.abs(cy - ty)) <= r2) {
                                    smell[tx][ty] = temp;
                                } else {
                                    q.offer(new Node(tx, ty, temp));
                                }
                            }
                        }
                    }
                }
            }
        }
        int bfss(int ex,int ey){
            Queue<Node> q = new LinkedList<Node>();
            q.offer(new Node(cx,cy,0));
            visit[cx][cy] = true;
            while(!q.isEmpty()) {
                int x = q.element().x;
                int y = q.element().y;
                int step = q.element().step;
                q.poll();
                for (int i = 0; i < 4; i++) {
                    int tx = x + next[i][0];
                    int ty = y + next[i][1];
                    int temp = step + 1;
                    if (tx >= 0 && tx < n && ty >= 0 && ty < m) {
                        if(!visit[tx][ty] && map[tx][ty] != '*'){
                            if(tx==ex&&ty==ey){
                                return temp;
                            }
                            else{
                                q.offer(new Node(tx,ty,temp));
                                visit[tx][ty] = true;
                            }
                        }
                    }
                }
            }
            return -1;
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            map = new char[n][m];
            smell = new int[n][m];
            visit = new boolean[n][m];
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        cx = i;
                        cy = j;
                    }
                }
            }
            int res = Integer.MAX_VALUE;
            if((Math.abs(cx - px) + Math.abs(cy - py)) <= r2){
                res = bfss(px,py);
                out.println(res);
            }
            else {
                bfs();
                visit = new boolean[n][m];
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < m; j++) {
                        if(smell[i][j]!=0){
                            int t = bfss(i,j);
                            if(t!=-1)
                                res = Math.min(res,smell[i][j]+t);
                        }
                    }
                }
                if(res == Integer.MAX_VALUE)
                    out.println(""-1"");
                else
                    out.println(res);
            }
        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}
"
32,C,Java,54846338,2022-11-18 20:44:45,陈力明,答案错误,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandles;
import java.util.*;



import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
 
public class Main{
 
static int []f;
//static int []f2;
static int []size;
//static int []size2;
//static int []a=new int [500001];
static int max=Integer.MAX_VALUE;

static Set<Integer>set;
static int k;
static long mod= 998244353;
static int res=1;
static int n,m;
static int x1,y1;
 static List<Integer>[]ans;
 static char [][]c;
 private static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
	public static void main(String []args) {
		MyScanner s=new MyScanner();
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		n=s.nextInt();
		m=s.nextInt();
		int r1=s.nextInt();
		int r2=s.nextInt();
		c=new char [n][m];
		for(int i=0;i<n;i++)
			c[i]=s.next().toCharArray();
		int x1=0,y1=0,y2=0,x2=0;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if(c[i][j]=='M')
				{
					x1=i;
					y1=j;
				}
				if(c[i][j]=='P')
				{
					x2=i;
					y2=j;		
				}
			}
		}
		int [][]a=new int [n][m];
		int [][]b=new int [n][m];
		for(int i=0;i<n;i++)
		{
			Arrays.fill(a[i], -1);
			Arrays.fill(b[i], -1);
		}
		bfs(a,x2,y2);
		bfs(b,x1,y1);
		int max=Integer.MAX_VALUE;
        if(Math.abs(x1-x2)+Math.abs(y1-y2)<=r2)
        {
            if(b[x2][y2]!=-1)
                 out.println(b[x2][y2]);
            else out.println(-1);
                
            
        }
        else{
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if((Math.abs(x2-i)+Math.abs(y2-j))<=r1&&(Math.abs(x1-i)+Math.abs(y1-j))<=r2&&a[i][j]!=-1&&b[i][j]!=-1)
				{
					max=Math.min(max, a[i][j]+b[i][j]);
				}
			}
		}
			if(max==Integer.MAX_VALUE)out.println(-1);
			else out.println(max);
        }
		
	
	out.close();
	}
	 private static void bfs(int[][] st, int a, int b) {
	        Queue<int[]> q = new LinkedList<>();
	        q.add(new int[]{a, b});
	        st[a][b] = 0;
	        while (!q.isEmpty()) {
	            int[] t = q.poll();
	            int x = t[0], y = t[1];
	            for (int i = 0; i < 4; i++) {
	                int nx = x + dx[i];
	                int ny = y + dy[i];
	                if (nx <n && nx >= 0 && ny <m && ny >= 0 && c[nx][ny] != '*' && st[nx][ny] == -1) {
	                    q.add(new int[]{nx, ny});
	                    st[nx][ny] = st[x][y] + 1;
	                }
	            }
	        }
	    }
	public static boolean is(String a,String b)
	{
		for(int i=0;i<=b.length()-a.length();i++)
		{
			if(b.substring(i,i+a.length()).equals(a))
				return true;
		}
		return false;
		
	}
	public  static void dfs(int u,int k,List <Integer>[]list)
	{
		res=Math.max(res,k);
		for(int x:list [u])
		{
			boolean c=false;
			int kk=0;
			int min=Math.min(f[u], f[x]);
			for(int b:ans[min])
			{
				if(f[u]%b==0&&f[x]%b==0)
				{
					kk++;
					if(kk>=2) {
					c=true;break;
					}
					
				}
				
			}
			if(c)
				dfs(x,k+1,list);
			else dfs(x,1,list);
		}
				
			
		
		
	}
	
	
	  public static boolean is(long n) {
		    if (n <= 3) {
		        return n > 1;
		    }
		    // 只有6x-1和6x+1的数才有可能是质数
		    if (n % 6 != 1 && n % 6 != 5) {
		        return false;
		    }
		    // 判断这些数能否被小于sqrt(n)的奇数整除
		    int sqrt = (int) Math.sqrt(n);
		    for (int i = 5; i <= sqrt; i += 6) {
		        if (n % i == 0 || n % (i + 2) == 0) {
		            return false;
		        }
		    }
		    return true;
		}
	public static  long find(long k)
	{
		long l=0;long r=(long)2e7;
		while(l<r)
		{
			long mid=l+r>>1;
			if(mid*mid>=k)r=mid;
			else l=mid+1;
		}
		return l;
	}
	public static boolean is(int x,int y,int k,int [][]f)
	{
		int ans=1;
		
		for(int i=x-1;i>=0;i--)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1;i<f.length;i++)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=y-1;i>=0;i--)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		for(int i=y+1;i<f[0].length;i++)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y-1;i>=0&&j>=0;i--,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y+1;i<f.length&&j<f[0].length;i++,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y+1;i>=0&&j<f[0].length;i--,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y-1;i<f.length&&j>=0;i++,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		return false;
	}
	
		
	
	
public static void dfs(int x,int y,char [][]c,int [][]v){
	if(v[x][y]!=0)
	{
		return ;
	}
	int []dx={1,-1,0,0};
	
	int []dy= {0,0,1,-1};
	
	v[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int x1=x+dx[i];
		
		int y1=y+dy[i];
		if(x1<0||x1>=v.length||y1<0||y1>=v[0].length||v[x1][y1]==1||c[x1][y1]=='#')continue;
		dfs(x1,y1,c,v);
		
	}
		
		
}	
public static void swap(int []a) {
		int l=0,r=a.length-1;
		while(l<r) {
			int t=a[l];
			a[l]=a[r];
			a[r]=t;
			l++;r--;
		}
	}
public static boolean is(int j) {
		for(int i=2;i<=(int )Math.sqrt(j);i++) {
			if(j%i==0)return false;
		}
		return true;
	}
	 
public static int find (int []father,int x) {
		if(x!=father[x])
			x=find(father,father[x]);
		return father[x];
	}
public static void union(int []father,int x,int y,int []size) {
	x=find(father,x);
	y=find(father,y);
	if(x==y)
		return ;
	if(size[x]<size[y]) {
		 int tem=x;
         x=y;
         y=tem;
	}
	father[y]=x;
	size[x]+=size[y];
return ;
}
		
					
public static void shufu(int []f) {
		for(int i=0;i<f.length;i++) {
			int k=(int)(Math.random()*(f.length));
			int t=f[k];
			
			f[k]=f[0];
			f[0]=t;
			
		}
	}
public static void shufu1(long []f) {
	for(int i=0;i<f.length;i++) {
		int k=(int)(Math.random()*(f.length));
		long t=f[k];
		f[k]=f[0];
		f[0]=t;
	}
}
public  static int  gcd(int x,int y) {
		return y==0?x:gcd(y,x%y);
	}
 
 
public  static int  lcm(int x,int y) {
		
		return x*y/gcd(x,y);
}
		
	
	
		
		
	
	
		
	
/*					
public static void buildertree(int k,int l,int r) {
		if(l==r)
		{
			f[k]=a[l];
			return ;
		}
		int m=l+r>>1;
		buildertree(k+k,l,m);
		buildertree(k+k+1,m+1,r);
		f[k]=	
	
	}
public static	void update(int u,int l,int r,int x,int c)
{
    if(l==x && r==x)
    {
        f[u]=c;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)update(u<<1,l,mid,x,c);
    else if(x>=mid+1)update(u<<1|1,mid+1,r,x,c);
   	f[u]=Math.max(f[u+u], f[u+u+1]);
}
	
public static int query(int k,int l,int r,int x,int y) {
		if(x==l&&y==r) {
			return f[k];
		}
		int m=l+r>>1;
		if(y<=m) {
			return query(k+k,l,m,x,y);
		}
		else if(x>m)return query(k+k+1,m+1,r,x,y);
		else  {
			int i=query(k+k,l,m,x,m),j=query(k+k+1,m+1,r,m+1,y);
		return Math.max(j, Math.max(i+j, i));
		
		}
	}
	
public static void calc(int k,int l,int r,int x,int z) {
 
			f[k]+=z;
			if(l==r) {
				return ;
			}
			int m=l+r>>1;
    		if(x<=m)
    			calc(k+k,l,m,x,z);
    		else calc(k+k+1,m+1,r,x,z);
			
			
		}
	
				
			
 
		*/
		
				
	
			
	
			
	
 
	public static class MyScanner {
	    BufferedReader br;
	    StringTokenizer st;
	 
	    public MyScanner() {
	      try {
	        final String USERDIR = System.getProperty(""user.dir"");
	        String cname = MethodHandles.lookup().lookupClass().getCanonicalName().replace("".MyScanner"", """");
	        cname = cname.lastIndexOf('.') > 0 ? cname.substring(cname.lastIndexOf('.') + 1) : cname;
	        final File fin = new File(USERDIR + ""/io/c"" + cname.substring(1,5) + ""/"" + cname + "".in"");
	        br = new BufferedReader(new InputStreamReader(fin.exists()
	            ? new FileInputStream(fin) : System.in));
	      } catch (Exception e) {
	        br = new BufferedReader(new InputStreamReader(System.in));
	      }
	    }
	 
	    public String next() {
	      try {
	        while (st == null || !st.hasMoreElements()) {
	          st = new StringTokenizer(br.readLine());
	        }
	        return st.nextToken();
	      } catch (Exception e) {
	        throw new RuntimeException(e);
	      }
	    }
	 
	    public int nextInt() {
	      return Integer.parseInt(next());
	    }
	 
	    public long nextLong() {
	      return Long.parseLong(next());
	    }
	  }
	
		}"
33,C,Java,54846380,2022-11-18 20:45:00,rookie1号,答案正确,"import java.io.*;
import java.util.*;
public class Main {
    
    static PrintWriter out = new PrintWriter(System.out);
    static Scanner in = new Scanner(System.in);
    static BufferedReader re = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out));
    //String[] strs = re.readLine().split("" ""); int a = Integer.parseInt(strs[0]);
    
    static int[][] dir={{1,0},{-1,0},{0,1},{0,-1}};
    static int n,m,xxx,yyy,x1,y1,r1,r2;
    static int ans[][];static char arr[][];
    static int vis[][];
    static int ans1[][];
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        //String[] strs = re.readLine().split("" "");
        //int T=Integer.parseInt(strs[0]);
        
        //int T=in.nextInt();
        int T=1;
        while(T>0){
            //String[] strs1 = re.readLine().split("" "");
            //int n=Integer.parseInt(strs1[0]);
            //String s=re.readLine();
            //char arr[]=s.toCharArray();

            //long[][] p = new long[n][2];//对 long 二维数组排序
            //Arrays.sort(p, (a, b) -> a[0] <= b[0] ? -1 : 1);
            //Set<Integer>set=new HashSet<>();
            //Map<Long,Integer>map=new HashMap<>();
            //Map<Integer,List<Integer>>map=new HashMap<>();
            //TreeSet<Integer> set = new TreeSet<>();
            //int max=0;int min=2100000000;
            n=in.nextInt();
            m=in.nextInt();
            r1=in.nextInt();
            r2=in.nextInt();
            arr=new char[n+1][m+1];
            xxx=0;yyy=0;
            x1=0;y1=0;
            for(int i=0;i<n;i++){
                String s=in.next();
                arr[i]=s.toCharArray();
                for(int j=0;j<m;j++){
                    if(arr[i][j]=='P'){
                        xxx=i;yyy=j;
                    }
                    if(arr[i][j]=='M'){
                        x1=i;y1=j;
                    }
                }
            }
            //out.println(xx+"" ""+yy);
            ans=new int [n+1][m+1];
            ans1=new int [n+1][m+1];
            bfs(x1,y1);
            bfs1(xxx,yyy);
            int res=9999999;
            int qqq=0;
            for(int i=0;i<n;i++){
                for(int j=0;j<m;j++){
                    if(ans1[i][j]!=0&&ans[i][j]!=0){
                        if(ans[i][j]+ans1[i][j]<res){
                            res=ans[i][j]+ans1[i][j];
                            qqq++;
                        
                        }
                    }
                    //out.print(ans[i][j]+"" "");
                }
                //out.println();
            }
            if(qqq==0)out.println(""-1"");
            else out.println(res);
            T--;
            }
        out.flush();
    }
    static void bfs(int xx,int yy){
        vis=new int[n+1][m+1];
        Queue<Node> q=new LinkedList<>();
        q.offer(new Node(xx,yy,0));
        vis[xx][yy]=1;
        while (!q.isEmpty()){
            Node head = q.poll();
            //int x=head.x;
            //int y=head.y;
            for (int i = 0; i < 4; i++) {
                int x=head.x+dir[i][0];
                int y=head.y+dir[i][1];
                if (x>=0&&x<n&&y>=0&&y<m&&arr[x][y]!='*'&&vis[x][y]==0){
                    vis[x][y]=1;
                    if((Math.abs(x-x1)+Math.abs(y-y1))<=r2)ans[x][y]+=head.dis+1;
                    q.offer(new Node(x,y,head.dis+1));
                }
            }
        }
    }
    static void bfs1(int xx,int yy){
        vis=new int[n+1][m+1];
        Queue<Node> q=new LinkedList<>();
        q.offer(new Node(xx,yy,0));
        vis[xx][yy]=1;
        while (!q.isEmpty()){
            Node head = q.poll();
            //int x=head.x;
            //int y=head.y;
            for (int i = 0; i < 4; i++) {
                int x=head.x+dir[i][0];
                int y=head.y+dir[i][1];
                if (x>=0&&x<n&&y>=0&&y<m&&arr[x][y]!='*'&&vis[x][y]==0){
                    vis[x][y]=1;
                    if(Math.abs(x-xxx)+Math.abs(y-yyy)<=r1)ans1[x][y]+=head.dis+1;
                    q.offer(new Node(x,y,head.dis+1));
                }
            }
        }
    }
    static class Node{
        int x,y,dis;
        public Node(int x, int y,int dis) {
            this.x = x;
            this.y = y;
            this.dis=dis;
        }
    }
}"
34,C,Java,54846737,2022-11-18 20:47:05,陈力明,答案正确,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandles;
import java.util.*;



import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
 
public class Main{
 
static int []f;
//static int []f2;
static int []size;
//static int []size2;
//static int []a=new int [500001];
static int max=Integer.MAX_VALUE;

static Set<Integer>set;
static int k;
static long mod= 998244353;
static int res=1;
static int n,m;
static int x1,y1;
 static List<Integer>[]ans;
 static char [][]c;
 private static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
	public static void main(String []args) {
		MyScanner s=new MyScanner();
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		n=s.nextInt();
		m=s.nextInt();
		int r1=s.nextInt();
		int r2=s.nextInt();
		c=new char [n][m];
		for(int i=0;i<n;i++)
			c[i]=s.next().toCharArray();
		int x1=0,y1=0,y2=0,x2=0;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if(c[i][j]=='M')
				{
					x1=i;
					y1=j;
				}
				if(c[i][j]=='P')
				{
					x2=i;
					y2=j;		
				}
			}
		}
		int [][]a=new int [n][m];
		int [][]b=new int [n][m];
		for(int i=0;i<n;i++)
		{
			Arrays.fill(a[i], -1);
			Arrays.fill(b[i], -1);
		}
		bfs(a,x2,y2);
		bfs(b,x1,y1);
		int max=Integer.MAX_VALUE;
        if(Math.abs(x1-x2)+Math.abs(y1-y2)<=r2)
        {
            if(b[x2][y2]!=-1)
                 out.println(b[x2][y2]);
            else out.println(-1);
                
            
        }
        else{
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				if((Math.abs(x2-i)+Math.abs(y2-j))<=r1&&(Math.abs(x1-i)+Math.abs(y1-j))==r2&&a[i][j]!=-1&&b[i][j]!=-1)
				{
					max=Math.min(max, a[i][j]+b[i][j]);
				}
			}
		}
			if(max==Integer.MAX_VALUE)out.println(-1);
			else out.println(max);
        }
		
	
	out.close();
	}
	 private static void bfs(int[][] st, int a, int b) {
	        Queue<int[]> q = new LinkedList<>();
	        q.add(new int[]{a, b});
	        st[a][b] = 0;
	        while (!q.isEmpty()) {
	            int[] t = q.poll();
	            int x = t[0], y = t[1];
	            for (int i = 0; i < 4; i++) {
	                int nx = x + dx[i];
	                int ny = y + dy[i];
	                if (nx <n && nx >= 0 && ny <m && ny >= 0 && c[nx][ny] != '*' && st[nx][ny] == -1) {
	                    q.add(new int[]{nx, ny});
	                    st[nx][ny] = st[x][y] + 1;
	                }
	            }
	        }
	    }
	public static boolean is(String a,String b)
	{
		for(int i=0;i<=b.length()-a.length();i++)
		{
			if(b.substring(i,i+a.length()).equals(a))
				return true;
		}
		return false;
		
	}
	public  static void dfs(int u,int k,List <Integer>[]list)
	{
		res=Math.max(res,k);
		for(int x:list [u])
		{
			boolean c=false;
			int kk=0;
			int min=Math.min(f[u], f[x]);
			for(int b:ans[min])
			{
				if(f[u]%b==0&&f[x]%b==0)
				{
					kk++;
					if(kk>=2) {
					c=true;break;
					}
					
				}
				
			}
			if(c)
				dfs(x,k+1,list);
			else dfs(x,1,list);
		}
				
			
		
		
	}
	
	
	  public static boolean is(long n) {
		    if (n <= 3) {
		        return n > 1;
		    }
		    // 只有6x-1和6x+1的数才有可能是质数
		    if (n % 6 != 1 && n % 6 != 5) {
		        return false;
		    }
		    // 判断这些数能否被小于sqrt(n)的奇数整除
		    int sqrt = (int) Math.sqrt(n);
		    for (int i = 5; i <= sqrt; i += 6) {
		        if (n % i == 0 || n % (i + 2) == 0) {
		            return false;
		        }
		    }
		    return true;
		}
	public static  long find(long k)
	{
		long l=0;long r=(long)2e7;
		while(l<r)
		{
			long mid=l+r>>1;
			if(mid*mid>=k)r=mid;
			else l=mid+1;
		}
		return l;
	}
	public static boolean is(int x,int y,int k,int [][]f)
	{
		int ans=1;
		
		for(int i=x-1;i>=0;i--)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1;i<f.length;i++)
		{
			if(f[i][y]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=y-1;i>=0;i--)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		for(int i=y+1;i<f[0].length;i++)
		{
			if(f[x][i]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y-1;i>=0&&j>=0;i--,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y+1;i<f.length&&j<f[0].length;i++,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		ans=1;
		for(int i=x-1,j=y+1;i>=0&&j<f[0].length;i--,j++)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		for(int i=x+1,j=y-1;i<f.length&&j>=0;i++,j--)
		{
			if(f[i][j]==f[x][y])
				ans++;
			else break;
		}
		if(ans>=k)return true;
		return false;
	}
	
		
	
	
public static void dfs(int x,int y,char [][]c,int [][]v){
	if(v[x][y]!=0)
	{
		return ;
	}
	int []dx={1,-1,0,0};
	
	int []dy= {0,0,1,-1};
	
	v[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int x1=x+dx[i];
		
		int y1=y+dy[i];
		if(x1<0||x1>=v.length||y1<0||y1>=v[0].length||v[x1][y1]==1||c[x1][y1]=='#')continue;
		dfs(x1,y1,c,v);
		
	}
		
		
}	
public static void swap(int []a) {
		int l=0,r=a.length-1;
		while(l<r) {
			int t=a[l];
			a[l]=a[r];
			a[r]=t;
			l++;r--;
		}
	}
public static boolean is(int j) {
		for(int i=2;i<=(int )Math.sqrt(j);i++) {
			if(j%i==0)return false;
		}
		return true;
	}
	 
public static int find (int []father,int x) {
		if(x!=father[x])
			x=find(father,father[x]);
		return father[x];
	}
public static void union(int []father,int x,int y,int []size) {
	x=find(father,x);
	y=find(father,y);
	if(x==y)
		return ;
	if(size[x]<size[y]) {
		 int tem=x;
         x=y;
         y=tem;
	}
	father[y]=x;
	size[x]+=size[y];
return ;
}
		
					
public static void shufu(int []f) {
		for(int i=0;i<f.length;i++) {
			int k=(int)(Math.random()*(f.length));
			int t=f[k];
			
			f[k]=f[0];
			f[0]=t;
			
		}
	}
public static void shufu1(long []f) {
	for(int i=0;i<f.length;i++) {
		int k=(int)(Math.random()*(f.length));
		long t=f[k];
		f[k]=f[0];
		f[0]=t;
	}
}
public  static int  gcd(int x,int y) {
		return y==0?x:gcd(y,x%y);
	}
 
 
public  static int  lcm(int x,int y) {
		
		return x*y/gcd(x,y);
}
		
	
	
		
		
	
	
		
	
/*					
public static void buildertree(int k,int l,int r) {
		if(l==r)
		{
			f[k]=a[l];
			return ;
		}
		int m=l+r>>1;
		buildertree(k+k,l,m);
		buildertree(k+k+1,m+1,r);
		f[k]=	
	
	}
public static	void update(int u,int l,int r,int x,int c)
{
    if(l==x && r==x)
    {
        f[u]=c;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)update(u<<1,l,mid,x,c);
    else if(x>=mid+1)update(u<<1|1,mid+1,r,x,c);
   	f[u]=Math.max(f[u+u], f[u+u+1]);
}
	
public static int query(int k,int l,int r,int x,int y) {
		if(x==l&&y==r) {
			return f[k];
		}
		int m=l+r>>1;
		if(y<=m) {
			return query(k+k,l,m,x,y);
		}
		else if(x>m)return query(k+k+1,m+1,r,x,y);
		else  {
			int i=query(k+k,l,m,x,m),j=query(k+k+1,m+1,r,m+1,y);
		return Math.max(j, Math.max(i+j, i));
		
		}
	}
	
public static void calc(int k,int l,int r,int x,int z) {
 
			f[k]+=z;
			if(l==r) {
				return ;
			}
			int m=l+r>>1;
    		if(x<=m)
    			calc(k+k,l,m,x,z);
    		else calc(k+k+1,m+1,r,x,z);
			
			
		}
	
				
			
 
		*/
		
				
	
			
	
			
	
 
	public static class MyScanner {
	    BufferedReader br;
	    StringTokenizer st;
	 
	    public MyScanner() {
	      try {
	        final String USERDIR = System.getProperty(""user.dir"");
	        String cname = MethodHandles.lookup().lookupClass().getCanonicalName().replace("".MyScanner"", """");
	        cname = cname.lastIndexOf('.') > 0 ? cname.substring(cname.lastIndexOf('.') + 1) : cname;
	        final File fin = new File(USERDIR + ""/io/c"" + cname.substring(1,5) + ""/"" + cname + "".in"");
	        br = new BufferedReader(new InputStreamReader(fin.exists()
	            ? new FileInputStream(fin) : System.in));
	      } catch (Exception e) {
	        br = new BufferedReader(new InputStreamReader(System.in));
	      }
	    }
	 
	    public String next() {
	      try {
	        while (st == null || !st.hasMoreElements()) {
	          st = new StringTokenizer(br.readLine());
	        }
	        return st.nextToken();
	      } catch (Exception e) {
	        throw new RuntimeException(e);
	      }
	    }
	 
	    public int nextInt() {
	      return Integer.parseInt(next());
	    }
	 
	    public long nextLong() {
	      return Long.parseLong(next());
	    }
	  }
	
		}"
35,C,Java,54847086,2022-11-18 20:49:18,牛客935801330号（人工智能3211吴华聪）,答案正确,"


import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int vis[][]=new int[1003][1003];
        int n=0,m=0,r1=0,r2=0;
        char map[][]=new char[n+1][m+1];
        int x1=0,y1=0,x2=0,y2=0,f=0,sum=0;
        int d[][]={{1,0},{-1,0},{0,1},{0,-1}};
        boolean check(int x,int y){
            if(x<=0||x>n||y<=0||y>m||vis[x][y]==1||map[x][y]=='*'){
                return false;
            }
            else {
                return true;
            }
        }

void bfs(){
  String s=x1+"" ""+y1+"" ""+0;
  Queue <String>q=new LinkedList();
  q.offer(s);
  vis[x1][y1]=1;
  while (!q.isEmpty()) {
      int t = q.size();
      while (t-- > 0) {
          String s1 = q.poll();
//          System.out.println(s1);
          String s2[] = s1.split("" "");
          int z[] = new int[3];
          for (int i = 0; i < 3; i++) {
              z[i] = Integer.parseInt(s2[i]);
          }
          if (z[0] == x2 && z[1] == y2) {
              f = 1;
              return;
          }
          int yy1 = Math.abs(z[0] - x2);
          int yy2 = Math.abs(z[1] - y2);
          int yy3 = yy1 + yy2;
          if(yy3>=0&&yy3<=r2){
              z[2]=1;
          }
          for (int i = 0; i < 4; i++) {
              int z2 = z[0] + d[i][0];
              int z3 = z[1] + d[i][1];
              if (check(z2, z3)) {
                  if (z[2] == 1) {
                      String ss = z2 + "" "" + z3 + "" "" + z[2];
//                      System.out.println(ss+""*"");
                          q.offer(ss);
                          vis[z2][z3]=1;
                  }
                  else {
                      int y2 = Math.abs(z[0] - x1);
                      int y3 = Math.abs(z[1] - y1);
                      int y4 = y2 + y3;
                      if (y4 >= 0 && y4 <= r1) {
                              String ss = z2 + "" "" + z3 + "" "" + z[2];
//                          System.out.println(ss+""**"");
                              q.offer(ss);
                          vis[z2][z3]=1;
                      }
                  }
              }
              else {
                  continue;
              }
          }

      }
      sum++;
  }
}
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n=in.nextInt();
            m=in.nextInt();
            r1= in.nextInt();
            r2=in.nextInt();
            map=new char[n+1][m+1];
            for (int i = 0; i < n; i++) {
                String s=in.next();
                for (int j = 0; j <m ; j++) {
                    map[i+1][j+1]=s.charAt(j);
                    if(s.charAt(j)=='M'){
                        x2=i+1;
                        y2=j+1;
                    }
                    else if(s.charAt(j)=='P'){
                        x1=i+1;
                        y1=j+1;
                    }
                }
            }
            bfs();
            if(f==1){
                out.println(sum);
            }
            else {
                out.println(-1);
            }
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}"
36,C,Java,54847941,2022-11-18 20:54:38,霖酱,答案错误,"import java.util.*;
import java.math.*;
import java.io.*;

public class Main {
    
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static final int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public static void main(String[] args) throws Exception{
        
        String[] params = in.readLine().split("" "");
        int n = Integer.parseInt(params[0]), m = Integer.parseInt(params[1]);
        
        params = in.readLine().split("" "");
        int r1 = Integer.parseInt(params[0]), r2 = Integer.parseInt(params[1]);

        String[] grid = new String[n];
        for (int i = 0; i < n; i++) {
            grid[i] = in.readLine();
        }
        
        Deque<int[]> q = new LinkedList<>();
        int px = -1, py = -1, cx = -1, cy = -1;
        for (int i = 0; i < n; i++) {
            String row = grid[i];
            for (int j = 0; j < m; j++) {
                if (row.charAt(j) == 'P') {
                    px = i; py = j;
                }
                if (row.charAt(j) == 'M') {
                    cx = i; cy = j;
                    q.offer(new int[]{cx, cy, 0});
                }
            }
        }
        
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(dist[i], -1);
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            
            dist[x][y] = step;    
            if (step > r2) continue;
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' || 
                    dist[nx][ny] != -1) {
                    continue;
                }
                q.offer(new int[]{nx, ny, step + 1});
            }
        }
        
        int res = 0x3f3f3f3f;
        boolean[][] visited = new boolean[n][m];
        q.offer(new int[]{px, py, 0});
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            visited[x][y] = true;
            if (step >= r1) continue;
            
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' ||
                    visited[nx][ny]) {
                    continue;
                }
                
                if (dist[nx][ny] != -1) {
                    res = Math.min(res, step + 1 + dist[nx][ny]);
                } else {
                    q.offer(new int[]{nx, ny, step + 1});
                }
            }
        }
            
        out.println(res == 0x3f3f3f3f ? -1 : res);
            
        out.flush();
        in.close();
    }  
}
"
37,C,Java,54848795,2022-11-18 20:59:18,摆摆摆摆摆摆摆摆摆,答案错误,"import java.util.*;
import java.io.*;
import java.math.BigInteger;

public class Main
{
	static class FastScanner// 用于快速读入大量数据
	{
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(
				InputStream in
		)
		{
			br = new BufferedReader(new InputStreamReader(in), 16384);
			eat("""");
		}

		public void eat(
				String s
		)
		{
			st = new StringTokenizer(s);
		}

		public String nextLine()
		{
			try
			{
				return br.readLine();
			} catch (IOException e)
			{
				return null;
			}
		}

		public boolean hasNext()
		{
			while (!st.hasMoreTokens())
			{
				String s = nextLine();
				if (s == null)
					return false;
				eat(s);
			}
			return true;
		}

		public String next()
		{
			hasNext();
			return st.nextToken();
		}

		public int nextInt()
		{
			return Integer.parseInt(next());
		}

		public long nextLong()
		{
			return Long.parseLong(next());
		}

		public double nextDouble()
		{
			return Double.parseDouble(next());
		}
	}

	static FastScanner in = new FastScanner(System.in);// 快读
	static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));// 快速输出

	static int gcd(
			int a, int b
	)
	{
		return b == 0 ? a : gcd(b, a % b);
	}

	static int lcm(
			int a, int b
	)
	{
		return (a * b) / gcd(a, b);
	}

	static int mod = 1000000007;
	public static List<int[]> list = new LinkedList<>();;
//    static int dx[] = { -1, 1, 0, 0, -1, -1, 1, 1 },dy[] = { 0, 0, -1, 1, -1, 1, -1, 1 };
	static int ax[] =
	{ -1, 0, 1, 0 }, ay[] =
	{ 0, 1, 0, -1 };

	public static long ksm(long a, long k)
	{
		long ans = 1;
		while (k > 0)
		{
			if ((k & 1) == 1)
			{
				ans = ans * a % mod;
			}
			k >>= 1;
			a = a * a % mod;
		}
		return ans;
	}

	public static int cnt = 0;

	public static int ans=Integer.MAX_VALUE,r1,r2,px=0,py=0,mx=0,my=0,n,m;
	public static char[][] g=new char[1000+10][1000+10];
	public static int [][] step=new int[1000+10][1000+10];
	public static boolean[][] isb=new boolean[1000+10][1000+10];
	public static boolean[][] is=new boolean[1000+10][1000+10];
	public static void main(String[] args)
	{
		n=in.nextInt();
		m=in.nextInt();
		r1=in.nextInt();
		r2=in.nextInt();
		for(int i=1;i<=n;i++)
		{
			g[i]=("" ""+in.next()).toCharArray();
			for(int j=1;j<=m;j++)
			{
				if(g[i][j]=='M')
				{
					mx=i;
					my=j;
				}else if(g[i][j]=='P')
				{
					g[i][j]='.';
					px=i;
					py=j;
				}
			}
		}
		isb[mx][my]=true;
		for(int a=Math.max(1, mx-r2);a<=Math.min(n, mx+r2);a++)
		{
			for(int b=Math.max(1, my-r2);b<=Math.min(m, my+r2);b++)
			{
				isb[a][b]=true;
			}
		}
//		for(int i=1;i<=n;i++)
//		{
//			for(int j=1;j<=m;j++)
//			{
//				if(isb[i][j])
//				{
//					System.out.print(1+"" "");
//				}else
//				{
//					System.out.print(""0 "");
//				}
//			}
//			System.out.println();
//		}
		Queue<int []> q=new LinkedList<int []>();
		q.add(new int[] {px,py,0});
		while(!q.isEmpty())
		{
			int index[]=q.poll();
			for(int i=0;i<4;i++)
			{
				for(int j=0;j<4;j++)
				{
					int dx=ax[i]+index[0];
					int dy=ay[j]+index[1];
					if(dx>=Math.max(1, px-r1) && dx<=Math.min(n, px+r1) && dy>=Math.max(1, py-r2) && dy<=Math.min(m, py+r2) && g[dx][dy]!='*' &&!is[dx][dy])
					{
						if(isb[dx][dy])
						{
							ans=Math.min(ans, step[index[0]][index[1]]+1 + Math.abs(dx-mx)+Math.abs(dy-my));
						}else
						{
							is[dx][dy]=true;
							step[dx][dy]=step[index[0]][index[1]]+1;
							q.add(new int[] {dx,dy,step[index[0]][index[1]]+1});
						}
					}
				}
			}
		}
		System.out.println(ans==Integer.MAX_VALUE?""-1"":ans);
	}
}"
38,C,Java,54849315,2022-11-18 21:01:47,闵其其,运行超时,"
import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int[][] next = {{1,0},{-1,0},{0,1},{0,-1}};
        char[][] map;
        int[][] smell;
        boolean[][] visit;
        int px,py,cx,cy,n,m,r1,r2;
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        void bfs(){
            Queue<Node> q = new LinkedList<Node>();
            q.offer(new Node(px,py,0));
            visit[px][py] = true;
            while(!q.isEmpty()){
                int x = q.element().x;
                int y = q.element().y;
                int step = q.element().step;
                q.poll();
                for (int i = 0; i < 4; i++) {
                    int tx = x + next[i][0];
                    int ty = y + next[i][1];
                    int temp = step + 1;
                    if(tx>=0&&tx<n&&ty>=0&&ty<m){
                        if((Math.abs(px-tx)+Math.abs(py-ty))>r1)
                            continue;
                        else {
                            if (!visit[tx][ty] && map[tx][ty] != '*') {
                                visit[tx][ty] = true;
                                if ((Math.abs(cx - tx) + Math.abs(cy - ty)) <= r2) {
                                    smell[tx][ty] = temp;
                                } else {
                                    q.offer(new Node(tx, ty, temp));
                                }
                            }
                        }
                    }
                }
            }
        }
        int bfss(int ex,int ey){
            Queue<Node> q = new LinkedList<Node>();
            visit = new boolean[n][m];
            q.offer(new Node(cx,cy,0));
            visit[cx][cy] = true;
            while(!q.isEmpty()) {
                int x = q.element().x;
                int y = q.element().y;
                int step = q.element().step;
                q.poll();
                for (int i = 0; i < 4; i++) {
                    int tx = x + next[i][0];
                    int ty = y + next[i][1];
                    int temp = step + 1;
                    if (tx >= 0 && tx < n && ty >= 0 && ty < m) {
                        if(!visit[tx][ty] && map[tx][ty] != '*'){
                            if(tx==ex&&ty==ey){
                                return temp;
                            }
                            else{
                                q.offer(new Node(tx,ty,temp));
                                visit[tx][ty] = true;
                            }
                        }
                    }
                }
            }
            return -1;
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            map = new char[n][m];
            smell = new int[n][m];
            visit = new boolean[n][m];
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        cx = i;
                        cy = j;
                    }
                }
            }
            int res = Integer.MAX_VALUE;
            if((Math.abs(cx - px) + Math.abs(cy - py)) <= r2){
                res = bfss(px,py);
                out.println(res);
            }
            else {
                bfs();
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < m; j++) {
                        if(smell[i][j]!=0){
                            int t = bfss(i,j);
                            if(t!=-1) {
                                res = Math.min(res, smell[i][j] + t);
                            }
                        }
                    }
                }
                if(res == Integer.MAX_VALUE)
                    out.println(""-1"");
                else
                    out.println(res);
            }
        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public BigInteger nextBigInteger()
        {
            return new BigInteger(next());
        }
        public BigDecimal nextBigDecimal()
        {
            return new BigDecimal(next());
        }

    }
}
"
39,C,Java,54849428,2022-11-18 21:02:30,Mosyi.,答案错误,"import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        int n,m,r1,r2;
        char[][] a;
        int[][] vis;
        int[][] viss;
        int px,py,mx,my;
        static class A{
            int x,y;
            int sum;
            A(int x,int y,int sum){
                this.x = x;
                this.y = y;
                this.sum = sum;
            }
        }
        int res = 0;
        int f = 0;
        public void bfs(int xx,int yy,int ss,int[][] vis){
            A lmy = new A(xx,yy,ss);
            Queue<A> q = new LinkedList<>();
            q.add(lmy);
            vis[xx][yy] = 1;
            while (!q.isEmpty()){
                A mo = new A(q.peek().x,q.peek().y,q.poll().sum);
                if(f == 0) {
                    if (Math.abs(mo.x - mx) + Math.abs(mo.y - my) == r2) {
                        f = 1;
                        px = mo.x;
                        py = mo.y;
                        res = mo.sum;
                        return;
                    }
                    if (mo.sum > r1) {
                        f = -1;
                        return;
                    }
                }else{
                    if(mo.x == px && mo.y == py){
                        res += mo.sum;
                        return;
                    }
                }
                for (int i = 0; i < 4; i++) {
                    if(i == 0){
                        A next = new A(mo.x,mo.y,mo.sum);
                        if(mo.x - 1 >= 1 && a[mo.x - 1][mo.y] != '*'){
                            next.x = mo.x - 1;
                            next.y = mo.y;
                        }
                        if(vis[next.x][next.y] == 0) {
                            vis[next.x][next.y] = 1;
                            next.sum = mo.sum + 1;
                            q.add(next);
                        }
                    }else if(i == 1){
                        A next = new A(mo.x,mo.y,mo.sum);
                        if(mo.y - 1 >= 1 && a[mo.x][mo.y - 1] != '*'){
                            next.y = mo.y - 1;
                            next.x = mo.x;
                        }
                        if(vis[next.x][next.y] == 0) {
                            vis[next.x][next.y] = 1;
                            next.sum = mo.sum + 1;
                            q.add(next);
                        }
                    }else if(i == 2){
                        A next = new A(mo.x,mo.y,mo.sum);
                        if(mo.x + 1 <= n && a[mo.x + 1][mo.y] != '*'){
                            next.x = mo.x + 1;
                            next.y = mo.y;
                        }
                        if(vis[next.x][next.y] == 0) {
                            vis[next.x][next.y] = 1;
                            next.sum = mo.sum + 1;
                            q.add(next);
                        }
                    }else if(i == 3){
                        A next = new A(mo.x,mo.y,mo.sum);
                        if(mo.y + 1 <= m && a[mo.x][mo.y + 1] != '*'){
                            next.y = mo.y + 1;
                            next.x = mo.x;
                        }
                        if(vis[next.x][next.y] == 0) {
                            vis[next.x][next.y] = 1;
                            next.sum = mo.sum + 1;
                            q.add(next);
                        }
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            a = new char[n+1][m+1];
            for (int i = 1; i <= n; i++) {
                String s = in.next();
                for (int j = 1; j <= m; j++) {
                    a[i][j] = s.charAt(j-1);
                    if(a[i][j] == 'P'){
                        px = i;
                        py = j;
                    }
                    if(a[i][j] == 'M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            vis = new int[n+1][m+1];
            bfs(px,py,0,vis);
            if(f == -1){
                out.println(""-1"");
            }else if(f == 1){
                viss = new int[n+1][m+1];
                bfs(mx,my,0,viss);
                if(f == -1){
                    out.println(""-1"");
                }else{
                    out.println(res);
                }
            }
        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        boolean hasNext()
        {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
            {
                try
                {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e)
                {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public String nextLine()
        {
            String str = null;
            try
            {
                str = reader.readLine();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }

    }
}"
40,C,Java,54850349,2022-11-18 21:09:07,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,mx,my,px,py;
        int[] x = {-1,0,1,0,1,-1,1,-1};
        int[] y = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] map1 = new int[1005][1005];
        int[][] map2 = new int[1005][1005];

        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];

        Deque<Node> q = new ArrayDeque<>();
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+x[i],ty+y[i])){
                        if(map[tx+x[i]][ty+y[i]]=='*')
                            break;
                        int c = Math.abs(tx-x[i])+Math.abs(ty-y[i]);
                        if(c>=0&&c<=r2){
                            tx+=x[i];
                            ty+=y[i];
                            map1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+x[i],ty+y[i])){
                        if(map[tx+x[i]][ty+y[i]]=='*')
                            break;
                        int c = Math.abs(tx-x[i])+Math.abs(ty-y[i]);
                        if(c>=0&&c<=r1){
                            tx+=x[i];
                            ty+=y[i];
                            map2[tx][ty]=2;
                        }
                        else
                            break;
                    }
                }
            }
        }
        void bfs(int givex,int givey,int id){
            int[][] vis = new int[1005][1005];
            vis[givex][givey] = 1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y],now.step);
                }
                if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y],now.step);
                }

                for (int i = 0; i < 4; i++) {
                    int nx = now.x+x[i];
                    int ny = now.y+y[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if (vis[nx][ny] == 0) {
                        vis[nx][ny] = 1;
                        q.offer(new Node(nx, ny, now.step + 1));
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                    else if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                }
            }
            test(mx,my,1);
            test(px,py,2);
            q.offer(new Node(mx,my,0));
            bfs(mx,my,1);
            q.clear();
            q.offer(new Node(px,py,0));
            bfs(px,py,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map1[i][j]==1&&map2[i][j]==2){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(map1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(map2[i][j]+"" "");
//                }
//                out.println();
//            }

//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.println(map1[i][j]+"" ""+map2[i][j]+"" ""+cnt1[i][j]+"" ""+cnt2[i][j]);
//                }
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);




        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
41,C,Java,54850363,2022-11-18 21:09:11,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,mx,my,px,py;
        int[] x = {-1,0,1,0,1,-1,1,-1};
        int[] y = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] map1 = new int[1005][1005];
        int[][] map2 = new int[1005][1005];

        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];

        Deque<Node> q = new ArrayDeque<>();
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+x[i],ty+y[i])){
                        if(map[tx+x[i]][ty+y[i]]=='*')
                            break;
                        int c = Math.abs(tx-x[i])+Math.abs(ty-y[i]);
                        if(c>=0&&c<=r2){
                            tx+=x[i];
                            ty+=y[i];
                            map1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+x[i],ty+y[i])){
                        if(map[tx+x[i]][ty+y[i]]=='*')
                            break;
                        int c = Math.abs(tx-x[i])+Math.abs(ty-y[i]);
                        if(c>=0&&c<=r1){
                            tx+=x[i];
                            ty+=y[i];
                            map2[tx][ty]=2;
                        }
                        else
                            break;
                    }
                }
            }
        }
        void bfs(int givex,int givey,int id){
            int[][] vis = new int[1005][1005];
            vis[givex][givey] = 1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y],now.step);
                }
                if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y],now.step);
                }

                for (int i = 0; i < 4; i++) {
                    int nx = now.x+x[i];
                    int ny = now.y+y[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if (vis[nx][ny] == 0) {
                        vis[nx][ny] = 1;
                        q.offer(new Node(nx, ny, now.step + 1));
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                    else if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                }
            }
            test(mx,my,1);
            test(px,py,2);
            q.offer(new Node(mx,my,0));
            bfs(mx,my,1);
            q.clear();
            q.offer(new Node(px,py,0));
            bfs(px,py,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map1[i][j]==1&&map2[i][j]==2){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(map1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(map2[i][j]+"" "");
//                }
//                out.println();
//            }

//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.println(map1[i][j]+"" ""+map2[i][j]+"" ""+cnt1[i][j]+"" ""+cnt2[i][j]);
//                }
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);




        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
42,C,Java,54850622,2022-11-18 21:10:59,霖酱,运行超时,"import java.util.*;
import java.math.*;
import java.io.*;

public class Main {
    
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static final int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public static void main(String[] args) throws Exception{
        
        String[] params = in.readLine().split("" "");
        int n = Integer.parseInt(params[0]), m = Integer.parseInt(params[1]);
        
        params = in.readLine().split("" "");
        int r1 = Integer.parseInt(params[0]), r2 = Integer.parseInt(params[1]);

        String[] grid = new String[n];
        for (int i = 0; i < n; i++) {
            grid[i] = in.readLine();
        }
        
        Deque<int[]> q = new LinkedList<>();
        int px = -1, py = -1, cx = -1, cy = -1;
        for (int i = 0; i < n; i++) {
            String row = grid[i];
            for (int j = 0; j < m; j++) {
                if (row.charAt(j) == 'P') {
                    px = i; py = j;
                }
                if (row.charAt(j) == 'M') {
                    cx = i; cy = j;
                    q.offer(new int[]{cx, cy, 0});
                }
            }
        }
        
        int[][] dist = new int[n][m];
        boolean[][] canFeel = new boolean[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(dist[i], -1);
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            if (Math.abs(x - cx) + Math.abs(y - cy) <= r2) canFeel[x][y] = true;
            dist[x][y] = step;    
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' || 
                    dist[nx][ny] != -1) {
                    continue;
                }
                q.offer(new int[]{nx, ny, step + 1});
            }
        }
        
        int res = 0x3f3f3f3f;
        boolean[][] visited = new boolean[n][m];
        q.offer(new int[]{px, py, 0});
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            visited[x][y] = true;
            if (step > r1) continue;
            
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' ||
                    visited[nx][ny]) {
                    continue;
                }
                
                if (canFeel[nx][ny]) {
                    res = Math.min(res, step + 1 + dist[nx][ny]);
                } else {
                    q.offer(new int[]{nx, ny, step + 1});
                }
            }
        }
            
        out.println(res == 0x3f3f3f3f ? -1 : res);
            
        out.flush();
        in.close();
    }  
}
"
43,C,Java,54851004,2022-11-18 21:14:00,霖酱,运行超时,"import java.util.*;
import java.math.*;
import java.io.*;

public class Main {
    
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static final int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public static void main(String[] args) throws Exception{
        
        String[] params = in.readLine().split("" "");
        int n = Integer.parseInt(params[0]), m = Integer.parseInt(params[1]);
        
        params = in.readLine().split("" "");
        int r1 = Integer.parseInt(params[0]), r2 = Integer.parseInt(params[1]);

        String[] grid = new String[n];
        for (int i = 0; i < n; i++) {
            grid[i] = in.readLine();
        }
        
        Deque<int[]> q = new LinkedList<>();
        int px = -1, py = -1, cx = -1, cy = -1;
        for (int i = 0; i < n; i++) {
            String row = grid[i];
            for (int j = 0; j < m; j++) {
                if (row.charAt(j) == 'P') {
                    px = i; py = j;
                }
                if (row.charAt(j) == 'M') {
                    cx = i; cy = j;
                    q.offer(new int[]{cx, cy, 0});
                }
            }
        }
        
        int[][] dist = new int[n][m];
        boolean[][] canFeel = new boolean[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(dist[i], -1);
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            if (Math.abs(x - cx) + Math.abs(y - cy) <= r2) canFeel[x][y] = true;
            dist[x][y] = step;    
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' || 
                    dist[nx][ny] != -1) {
                    continue;
                }
                q.offer(new int[]{nx, ny, step + 1});
            }
        }
        
        int res = 0x3f3f3f3f;
        boolean[][] visited = new boolean[n][m];
        q.offer(new int[]{px, py, 0});
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            visited[x][y] = true;
            if (step > r1) continue;
            
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' ||
                    visited[nx][ny]) {
                    continue;
                }
                
                if (canFeel[nx][ny]) {
                    res = Math.min(res, step + 1 + dist[nx][ny]);
                    out.println(res);
                    out.flush();
                    in.close();
                    return;
                } else {
                    q.offer(new int[]{nx, ny, step + 1});
                }
            }
        }
            
        out.println(res == 0x3f3f3f3f ? -1 : res);
            
        out.flush();
        in.close();
    }  
}
"
44,C,Java,54853507,2022-11-18 21:36:25,霖酱,运行超时,"import java.util.*;
import java.math.*;
import java.io.*;

public class Main {
    
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static final int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public static void main(String[] args) throws Exception{
        
        String[] params = in.readLine().split("" "");
        int n = Integer.parseInt(params[0]), m = Integer.parseInt(params[1]);
        
        params = in.readLine().split("" "");
        int r1 = Integer.parseInt(params[0]), r2 = Integer.parseInt(params[1]);

        String[] grid = new String[n];
        for (int i = 0; i < n; i++) {
            grid[i] = in.readLine();
        }
        
        Deque<int[]> q = new LinkedList<>();
        int px = -1, py = -1, cx = -1, cy = -1;
        for (int i = 0; i < n; i++) {
            String row = grid[i];
            for (int j = 0; j < m; j++) {
                if (row.charAt(j) == 'P') {
                    px = i; py = j;
                }
                if (row.charAt(j) == 'M') {
                    cx = i; cy = j;
                    q.offer(new int[]{cx, cy, 0});
                }
            }
        }
        
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) Arrays.fill(dist[i], -1);
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            dist[x][y] = step;    
            if (Math.abs(x - cx) + Math.abs(y - cy) > r2) dist[x][y] = 0x3f3f3f3f;
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' || 
                    dist[nx][ny] >= 0) {
                    continue;
                }
                q.offer(new int[]{nx, ny, step + 1});
            }
        }
        
        int res = 0x3f3f3f3f;
        boolean[][] visited = new boolean[n][m];
        q.offer(new int[]{px, py, 0});
        while (!q.isEmpty()) {
            int[] point = q.poll();
            int x = point[0], y = point[1], step = point[2];
            visited[x][y] = true;
            if (Math.abs(x - px) + Math.abs(y - py) > r1) continue;
            
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                if (nx < 0 || nx >= n ||
                    ny < 0 || ny >= m || 
                    grid[nx].charAt(ny) == '*' ||
                    visited[nx][ny]) {
                    continue;
                }
                
                if (dist[nx][ny] >= 0 && dist[nx][ny] < 0x3f3f3f3f) {
                    res = Math.min(res, step + 1 + dist[nx][ny]);
                    out.println(res);
                    out.flush();
                    in.close();
                    return;
                } else {
                    q.offer(new int[]{nx, ny, step + 1});
                }
            }
        }
            
        out.println(res == 0x3f3f3f3f ? -1 : res);
            
        out.flush();
        in.close();
    }  
}
"
45,C,Java,54855939,2022-11-18 21:59:37,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,mx,my,px,py;
        int[] x = {-1,0,1,0,1,-1,1,-1};
        int[] y = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] map1 = new int[1005][1005];
        int[][] map2 = new int[1005][1005];

        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];

        Deque<Node> q = new ArrayDeque<>();
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        
        void bfs(int givex,int givey,int id){
            int[][] vis = new int[1005][1005];
            vis[givex][givey] = 1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y],now.step);
                }
                if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y],now.step);
                }

                for (int i = 0; i < 4; i++) {
                    int nx = now.x+x[i];
                    int ny = now.y+y[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if (vis[nx][ny] == 0) {
                        vis[nx][ny] = 1;
                        q.offer(new Node(nx, ny, now.step + 1));
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                    else if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    int c1 = Math.abs(mx-i)+Math.abs(my-j);
                    int c2 = Math.abs(px-i)+Math.abs(py-j);
                    if(c1>=0&&c1<=r2&&map[i][j]!='*')
                        map1[i][j] = 1;
                    if(c2>=0&&c2<=r1&&map[i][j]!='*')
                        map2[i][j] = 2;
                }
            }
            q.offer(new Node(mx,my,0));
            bfs(mx,my,1);
            q.clear();
            q.offer(new Node(px,py,0));
            bfs(px,py,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map1[i][j]==1&&map2[i][j]==2){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }

            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);




        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
46,C,Java,54856849,2022-11-18 22:24:13,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    int c1 = Math.abs(i-px)+Math.abs(j-py);
                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
                        t1[i][j]=1;
                    }
                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
                        t2[i][j]=1;
                    }
                }
            }
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
47,C,Java,54857260,2022-11-18 22:38:51,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            break;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    int c1 = Math.abs(i-px)+Math.abs(j-py);
//                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
//                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
//                        t1[i][j]=1;
//                    }
//                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
//                        t2[i][j]=1;
//                    }
//                }
//            }
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
48,C,Java,54857279,2022-11-18 22:39:48,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;

            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    int c1 = Math.abs(i-px)+Math.abs(j-py);
//                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
//                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
//                        t1[i][j]=1;
//                    }
//                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
//                        t2[i][j]=1;
//                    }
//                }
//            }
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
49,C,Java,54857514,2022-11-18 22:50:56,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    int c1 = Math.abs(i-px)+Math.abs(j-py);
//                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
//                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
//                        t1[i][j]=1;
//                    }
//                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
//                        t2[i][j]=1;
//                    }
//                }
//            }
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
50,C,Java,54857539,2022-11-18 22:52:17,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            break;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    int c1 = Math.abs(i-px)+Math.abs(j-py);
//                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
//                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
//                        t1[i][j]=1;
//                    }
//                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
//                        t2[i][j]=1;
//                    }
//                }
//            }
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
51,C,Java,54857562,2022-11-18 22:53:28,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            break;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    int c1 = Math.abs(i-px)+Math.abs(j-py);
//                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
//                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
//                        t1[i][j]=1;
//                    }
//                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
//                        t2[i][j]=1;
//                    }
//                }
//            }
            t1[px][py]=1;
            t2[px][py]=1;
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
52,C,Java,54857603,2022-11-18 22:55:18,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            break;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    int c1 = Math.abs(i-px)+Math.abs(j-py);
//                    int c2 = Math.abs(i-mx)+Math.abs(j-my);
//                    if(c1>=0&&c1<=r1&&map[i][j]!='*'){
//                        t1[i][j]=1;
//                    }
//                    if(c2>=0&&c2<=r2&&map[i][j]!='*'){
//                        t2[i][j]=1;
//                    }
//                }
//            }
            t1[px][py]=1;
            t2[mx][my]=1;
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
53,C,Java,54857689,2022-11-18 23:00:01,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            break;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }

            t1[px][py]=1;
            t2[mx][my]=1;
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        if(cnt1[i][j]==0&&cnt2[i][j]==0)
                            continue;
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
54,C,Java,54857853,2022-11-18 23:09:27,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            break;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }

            t1[px][py]=1;
            t2[mx][my]=1;
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        if(cnt1[i][j]==0&&cnt2[i][j]==0)
                            continue;
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
55,C,Java,54858061,2022-11-18 23:20:32,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 4; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        if(cnt1[i][j]==0&&cnt2[i][j]==0)
                            continue;
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
56,C,Java,54858069,2022-11-18 23:20:53,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if(cnt1[now.x][now.y]==0)
                        cnt1[now.x][now.y]=now.step;
                    else
                        cnt1[now.x][now.y]=Math.min(cnt1[now.x][now.y],now.step);
                }
                else if(id==2){
                    if(cnt2[now.x][now.y]==0)
                        cnt2[now.x][now.y]=now.step;
                    else
                        cnt2[now.x][now.y]=Math.min(cnt2[now.x][now.y],now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }
        void test(int gx,int gy,int id){
            if(id==1){
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r1){
                            t1[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
            else{
                for (int i = 0; i < 8; i++) {
                    int tx = gx;
                    int ty = gy;
                    while (IsTrue(tx+ax[i],ty+ay[i])){
                        tx+=ax[i];
                        ty+=ay[i];
                        if(map[tx][ty]=='*')
                            continue;
                        int c = Math.abs(tx-gx)+Math.abs(ty-gy);
                        if(c>=0&&c<=r2){
                            t2[tx][ty]=1;
                        }
                        else
                            break;
                    }
                }
            }
        }
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            test(px,py,1);
            test(mx,my,2);
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1){
                        if(cnt1[i][j]==0&&cnt2[i][j]==0)
                            continue;
                        ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                    }
                }
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
57,C,Java,54858290,2022-11-18 23:34:16,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        int c = Math.abs(nx - px) + Math.abs(ny - py);
                        if (c >= 0 && c <= r1) {
                            t1[nx][ny] = 1;
                        }
                    }
                    else if(id==2){
                        int c = Math.abs(nx - mx) + Math.abs(ny - my);
                        if (c >= 0 && c <= r2) {
                            t2[nx][ny] = 1;
                        }
                    }
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1) {
                        if (cnt1[i][j] == 0 && cnt2[i][j] == 0)
                            continue;
                        ans = Math.min(ans, cnt1[i][j] + cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
58,C,Java,54858419,2022-11-18 23:44:04,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        int c = Math.abs(nx - px) + Math.abs(ny - py);
                        if (c >= 0 && c <= r1) {
                            t1[nx][ny] = 1;
                        }
                    }
                    else if(id==2){
                        int c = Math.abs(nx - mx) + Math.abs(ny - my);
                        if (c >= 0 && c <= r2) {
                            t2[nx][ny] = 1;
                        }
                    }
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1&&map[i][j]!='*') {
                        if (cnt1[i][j] == 0 && cnt2[i][j] == 0)
                            continue;
                        ans = Math.min(ans, cnt1[i][j] + cnt2[i][j]);
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    out.print(t1[i][j]+"" "");
                }
                out.println();
            }
            out.println();
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    out.print(t2[i][j]+"" "");
                }
                out.println();
            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
59,C,Java,54858423,2022-11-18 23:44:17,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[1005][1005];
        int[][] t1 = new int[1005][1005];
        int[][] t2 = new int[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        int c = Math.abs(nx - px) + Math.abs(ny - py);
                        if (c >= 0 && c <= r1) {
                            t1[nx][ny] = 1;
                        }
                    }
                    else if(id==2){
                        int c = Math.abs(nx - mx) + Math.abs(ny - my);
                        if (c >= 0 && c <= r2) {
                            t2[nx][ny] = 1;
                        }
                    }
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(t1[i][j]==1&&t2[i][j]==1&&map[i][j]!='*') {
                        if (cnt1[i][j] == 0 && cnt2[i][j] == 0)
                            continue;
                        ans = Math.min(ans, cnt1[i][j] + cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
60,C,Java,54858532,2022-11-18 23:49:16,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0,1,-1,1,-1};
        int[] ay = {0,-1,0,1,1,-1,-1,1};
        char[][] map = new char[2000][2000];
        int[][] t1 = new int[2000][2000];
        int[][] t2 = new int[2000][2000];
        int[][] cnt1 = new int[2000][2000];
        int[][] cnt2 = new int[2000][2000];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[2000][2000];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        int c = Math.abs(nx - px) + Math.abs(ny - py);
                        if (c >= 0 && c <= r1) {
                            t1[nx][ny] = 1;
                        }
                    }
                    else if(id==2){
                        int c = Math.abs(nx - mx) + Math.abs(ny - my);
                        if (c >= 0 && c <= r2) {
                            t2[nx][ny] = 1;
                        }
                    }
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map[i][j]!='*'&&t1[i][j]==1&&t2[i][j]==1) {
                        if (cnt1[i][j] + cnt2[i][j] == 0)
                            continue;
                        ans = Math.min(ans, cnt1[i][j] + cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
61,C,Java,54858862,2022-11-19 00:20:04,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Deque<Node> q = new ArrayDeque<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map[i][j]=='*')
                        continue;
                    int c1 = Math.abs(px-i)+Math.abs(py-j);
                    if(c1>=0&&c1<=r1){
                        int c2 = Math.abs(mx-i)+Math.abs(my-j);
                        if(c2>=0&&c2<=r2){
                            ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                        }
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
62,C,Java,54858869,2022-11-19 00:21:03,人工智能3211江海洋,答案错误,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Deque<Node> q = new ArrayDeque<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;

                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map[i][j]=='*')
                        continue;
                    int c1 = Math.abs(px-i)+Math.abs(py-j);
                    if(c1>=0&&c1<=r1){
                        int c2 = Math.abs(mx-i)+Math.abs(my-j);
                        if(c2>=0&&c2<=r2){
                            if(cnt1[i][j]+cnt2[i][j]!=0)
                                ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                        }
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
63,C,Java,54858927,2022-11-19 00:31:17,人工智能3211江海洋,答案正确,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[1005][1005];
        int[][] cnt1 = new int[1005][1005];
        int[][] cnt2 = new int[1005][1005];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Deque<Node> q = new ArrayDeque<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[1005][1005];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map[i][j]=='*')
                        continue;
                    int c1 = Math.abs(px-i)+Math.abs(py-j);
                    if(c1>=0&&c1<=r1){
                        int c2 = Math.abs(mx-i)+Math.abs(my-j);
                        if(c2>=0&&c2<=r2){
                            if(cnt1[i][j]!=0&&cnt2[i][j]!=0)
                                ans = Math.min(ans,cnt1[i][j]+cnt2[i][j]);
                        }
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
64,C,Java,54858938,2022-11-19 00:33:21,人工智能3211江海洋,答案正确,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[2000][2000];
        int[][] t1 = new int[2000][2000];
        int[][] t2 = new int[2000][2000];
        int[][] cnt1 = new int[2000][2000];
        int[][] cnt2 = new int[2000][2000];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Queue<Node> q = new LinkedList<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[2000][2000];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        int c = Math.abs(nx - px) + Math.abs(ny - py);
                        if (c >= 0 && c <= r1) {
                            t1[nx][ny] = 1;
                        }
                    }
                    else if(id==2){
                        int c = Math.abs(nx - mx) + Math.abs(ny - my);
                        if (c >= 0 && c <= r2) {
                            t2[nx][ny] = 1;
                        }
                    }
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map[i][j]!='*'&&t1[i][j]==1&&t2[i][j]==1) {
                        if (cnt1[i][j]!=0 && cnt2[i][j] != 0)
                            ans = Math.min(ans, cnt1[i][j] + cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
65,C,Java,54858974,2022-11-19 00:38:57,人工智能3211江海洋,答案正确,"import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskA {
        static class Node{
            int x,y,step;
            public Node(int x, int y, int step) {
                this.x = x;
                this.y = y;
                this.step = step;
            }
        }
        int n,m,r1,r2,px,py,mx,my;
        int[] ax = {-1,0,1,0};
        int[] ay = {0,-1,0,1};
        char[][] map = new char[2000][2000];
        int[][] t1 = new int[2000][2000];
        int[][] t2 = new int[2000][2000];
        int[][] cnt1 = new int[2000][2000];
        int[][] cnt2 = new int[2000][2000];
        boolean IsTrue(int x,int y){
            if(x>=0&&x<n&&y>=0&&y<m)
                return true;
            return false;
        }
        Deque<Node> q = new ArrayDeque<>();
        void bfs(int gx,int gy,int id){
            q.clear();
            int[][] vis = new int[2000][2000];
            q.offer(new Node(gx,gy,0));
            vis[gx][gy]=1;
            while (!q.isEmpty()){
                Node now = q.poll();
                if(id==1){
                    if (cnt1[now.x][now.y] == 0)
                        cnt1[now.x][now.y] = now.step;
                    else
                        cnt1[now.x][now.y] = Math.min(cnt1[now.x][now.y], now.step);
                }
                else if(id==2){
                    if (cnt2[now.x][now.y] == 0)
                        cnt2[now.x][now.y] = now.step;
                    else
                        cnt2[now.x][now.y] = Math.min(cnt2[now.x][now.y], now.step);
                }
                for (int i = 0; i < 4; i++) {
                    int nx = now.x+ax[i];
                    int ny = now.y+ay[i];
                    if(!IsTrue(nx,ny))
                        continue;
                    if(map[nx][ny]=='*')
                        continue;
                    if(id==1) {
                        int c = Math.abs(nx - px) + Math.abs(ny - py);
                        if (c >= 0 && c <= r1) {
                            t1[nx][ny] = 1;
                        }
                    }
                    else if(id==2){
                        int c = Math.abs(nx - mx) + Math.abs(ny - my);
                        if (c >= 0 && c <= r2) {
                            t2[nx][ny] = 1;
                        }
                    }
                    if(vis[nx][ny]==0){
                        vis[nx][ny]=1;
                        q.offer(new Node(nx,ny,now.step+1));
                    }
                }
            }
        }

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            r1 = in.nextInt();
            r2 = in.nextInt();
            for (int i = 0; i < n; i++) {
                String s = in.next();
                for (int j = 0; j < m; j++) {
                    map[i][j] = s.charAt(j);
                    if(map[i][j]=='P'){
                        px = i;
                        py = j;
                    }
                    else if(map[i][j]=='M'){
                        mx = i;
                        my = j;
                    }
                }
            }
            t1[px][py]=1;
            t2[mx][my]=1;
            bfs(px,py,1);
            bfs(mx,my,2);
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if(map[i][j]!='*'&&t1[i][j]==1&&t2[i][j]==1) {
                        if (cnt1[i][j]!=0 && cnt2[i][j] != 0)
                            ans = Math.min(ans, cnt1[i][j] + cnt2[i][j]);
                    }
                }
            }
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t1[i][j]+"" "");
//                }
//                out.println();
//            }
//            out.println();
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    out.print(t2[i][j]+"" "");
//                }
//                out.println();
//            }
            if(ans==Integer.MAX_VALUE)
                out.println(-1);
            else
                out.println(ans);

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        boolean hasNext() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (Exception e) {
                    return false;
                    // TODO: handle exception
                }
            }
            return true;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public String nextLine() {
            String str = null;
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public BigInteger nextBigInteger() {
            return new BigInteger(next());
        }

        public BigDecimal nextBigDecimal() {
            return new BigDecimal(next());
        }

    }
}
"
66,C,Java,54859306,2022-11-19 01:54:28,ws&t,答案错误,"import java.util.*;

public class Main {


    static final int VISITED = -1;
    static final int UNVISITED = 0;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int r1 = sc.nextInt();
        int r2 = sc.nextInt();
        int px = 0, py = 0, mx = 0, my = 0;
        sc.nextLine();
        int[][] maze = new int[n][m];
        for (int i = 0; i < n; i++) {
            char[] chars = sc.nextLine().toCharArray();
            for (int j = 0; j < m; j++) {
                switch (chars[j]) {
                    case 'P':
                        px = i;
                        py = j;
                        break;
                    case 'M':
                        mx = i;
                        my = j;
                        break;
                    case '*':
                        maze[i][j] = -1;
                        break;
                    default:
                        break;
                }
            }
        }
        if (bfs(maze, px, py, mx, my, r1, r2)) {
            System.out.println(bfs(maze, mx, my));
        } else {
            System.out.println(-1);
        }
    }

    static class Point {
        int x, y, step;

        public Point(int x, int y, int step) {
            this.x = x;
            this.y = y;
            this.step = step;
        }
    }

    static public boolean bfs(int[][] maze, int px, int py, int mx, int my, int r1, int r2) {
        // 可以移动的方向
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        int m = maze.length;
        int n = maze[0].length;
        boolean cat = false;
        Queue<Point> queue = new LinkedList<>();
        // 入口入队
        queue.offer(new Point(px, py, 0));
        // 标记为已访问过
        maze[px][py] = VISITED;
        while (!queue.isEmpty()) {
            Point poll = queue.poll();
            // 枚举四个方向
            for (int k = 0; k < dx.length; k++) {
                int x = poll.x + dx[k];
                int y = poll.y + dy[k];
                // 没越界
                boolean isNotOutOfBound = x >= 0 && x < m && y >= 0 && y < n;
                if (isNotOutOfBound && maze[x][y] == UNVISITED && isInTheRange(x, y, px, py, r1)) {
                    // 标记为已访问过
                    maze[x][y] = VISITED;
                    // 在猫的嗅觉范围内
                    if (isInTheRange(x, y, mx, my, r2)) {
                        cat = true;
                        maze[x][y] = poll.step + 1;
                        continue;
                    }
                    queue.offer(new Point(x, y, poll.step + 1));
                }
            }
        }
        return cat;
    }

    static public int bfs(int[][] maze, int mx, int my) {
        // 可以移动的方向
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        int m = maze.length;
        int n = maze[0].length;
        Queue<Point> queue = new LinkedList<>();
        // 入口入队
        queue.offer(new Point(mx, my, 0));
        // 标记为已访问过
        maze[mx][my] = VISITED;
        int min = Integer.MAX_VALUE;
        while (!queue.isEmpty()) {
            Point poll = queue.poll();
            // 枚举四个方向
            for (int k = 0; k < dx.length; k++) {
                int x = poll.x + dx[k];
                int y = poll.y + dy[k];
                // 没越界
                boolean isNotOutOfBound = x >= 0 && x < m && y >= 0 && y < n;
                if (isNotOutOfBound && maze[x][y] != VISITED) {
                    // 如果这是漂亮美眉可达的地方
                    if (maze[x][y] > 0) {
                        min = Math.min(min, maze[x][y] + poll.step + 1);
                    } else {
                        // 标记为已访问过
                        maze[x][y] = VISITED;
                    }
                    queue.offer(new Point(x, y, poll.step + 1));
                }
            }
        }
        //程序运行到这里，说明不存在这样的路径，返回 -1
        return min;
    }

    static boolean isInTheRange(int x1, int y1, int x2, int y2, int r) {
        return Math.abs(x1 - x2) + Math.abs(y1 - y2) <= r;
    }

}
"
67,C,Java,54859310,2022-11-19 01:57:34,ws&t,答案正确,"import java.util.*;

public class Main {


    static final int VISITED = -1;
    static final int UNVISITED = 0;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int r1 = sc.nextInt();
        int r2 = sc.nextInt();
        int px = 0, py = 0, mx = 0, my = 0;
        sc.nextLine();
        int[][] maze = new int[n][m];
        for (int i = 0; i < n; i++) {
            char[] chars = sc.nextLine().toCharArray();
            for (int j = 0; j < m; j++) {
                switch (chars[j]) {
                    case 'P':
                        px = i;
                        py = j;
                        break;
                    case 'M':
                        mx = i;
                        my = j;
                        break;
                    case '*':
                        maze[i][j] = -1;
                        break;
                    default:
                        break;
                }
            }
        }
        if (bfs(maze, px, py, mx, my, r1, r2)) {
            int steps = bfs(maze, mx, my);
            System.out.println(steps == Integer.MAX_VALUE ? -1 : steps);
        } else {
            System.out.println(-1);
        }
    }

    static class Point {
        int x, y, step;

        public Point(int x, int y, int step) {
            this.x = x;
            this.y = y;
            this.step = step;
        }
    }

    static public boolean bfs(int[][] maze, int px, int py, int mx, int my, int r1, int r2) {
        // 可以移动的方向
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        int m = maze.length;
        int n = maze[0].length;
        boolean cat = false;
        Queue<Point> queue = new LinkedList<>();
        // 入口入队
        queue.offer(new Point(px, py, 0));
        // 标记为已访问过
        maze[px][py] = VISITED;
        while (!queue.isEmpty()) {
            Point poll = queue.poll();
            // 枚举四个方向
            for (int k = 0; k < dx.length; k++) {
                int x = poll.x + dx[k];
                int y = poll.y + dy[k];
                // 没越界
                boolean isNotOutOfBound = x >= 0 && x < m && y >= 0 && y < n;
                if (isNotOutOfBound && maze[x][y] == UNVISITED && isInTheRange(x, y, px, py, r1)) {
                    // 标记为已访问过
                    maze[x][y] = VISITED;
                    // 在猫的嗅觉范围内
                    if (isInTheRange(x, y, mx, my, r2)) {
                        cat = true;
                        maze[x][y] = poll.step + 1;
                        continue;
                    }
                    queue.offer(new Point(x, y, poll.step + 1));
                }
            }
        }
        return cat;
    }

    static public int bfs(int[][] maze, int mx, int my) {
        // 可以移动的方向
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        int m = maze.length;
        int n = maze[0].length;
        Queue<Point> queue = new LinkedList<>();
        // 入口入队
        queue.offer(new Point(mx, my, 0));
        // 标记为已访问过
        maze[mx][my] = VISITED;
        int min = Integer.MAX_VALUE;
        while (!queue.isEmpty()) {
            Point poll = queue.poll();
            // 枚举四个方向
            for (int k = 0; k < dx.length; k++) {
                int x = poll.x + dx[k];
                int y = poll.y + dy[k];
                // 没越界
                boolean isNotOutOfBound = x >= 0 && x < m && y >= 0 && y < n;
                if (isNotOutOfBound && maze[x][y] != VISITED) {
                    // 如果这是漂亮美眉可达的地方
                    if (maze[x][y] > 0) {
                        min = Math.min(min, maze[x][y] + poll.step + 1);
                    } else {
                        // 标记为已访问过
                        maze[x][y] = VISITED;
                    }
                    queue.offer(new Point(x, y, poll.step + 1));
                }
            }
        }
        //程序运行到这里，说明不存在这样的路径，返回 -1
        return min;
    }

    static boolean isInTheRange(int x1, int y1, int x2, int y2, int r) {
        return Math.abs(x1 - x2) + Math.abs(y1 - y2) <= r;
    }

}
"
68,C,Java,54860692,2022-11-19 09:31:03,hhhhhn,答案错误,"import java.util.Scanner;
import java.util.ArrayDeque;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        char[][] map = new char[row][col];
        int[] p = null, m = null;
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) {
                map[i][j] = s.charAt(j);
                if (map[i][j] == 'P') p = new int[]{i, j};
                else if (map[i][j] == 'M') m = new int[]{i, j};
            }
        }
        int[][] dd = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(p);
        int step = 0;
        boolean f1 = false;
        boolean[][] vis = new boolean[row][col];
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (Math.abs(cur[0] - m[0]) + Math.abs(cur[1] - m[1]) <= r2) {
                    f1 = true;
                    p[0] = cur[0];
                    p[1] = cur[1];
                    break;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*'
                        || vis[x][y]
                        || Math.abs(x - p[0]) + Math.abs(y - p[1]) > r1) continue;
                    vis[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
            if (f1) break;
            step++;
        }
        if (!f1) {
            System.out.println(-1);
            return;
        }
        queue = new ArrayDeque<>();
        queue.offer(m);
        int s2 = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (cur[0] == p[0] && cur[1] == p[1]) {
                    System.out.println(s2 + step);
                    return;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*') continue;
                    map[x][y] = '*';
                    queue.offer(new int[]{x, y});
                }
            }
            s2++;
        }
        System.out.println(-1);
    }
}"
69,C,Java,54860915,2022-11-19 09:40:51,hhhhhn,运行超时,"import java.util.Scanner;
import java.util.ArrayDeque;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        char[][] map = new char[row][col];
        int[] p = null, m = null;
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) {
                map[i][j] = s.charAt(j);
                if (map[i][j] == 'P') p = new int[]{i, j};
                else if (map[i][j] == 'M') m = new int[]{i, j};
            }
        }
        int[][] dd = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(p);
        int step = 0;
        boolean f1 = false;
        boolean[][] vis = new boolean[row][col];
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                vis[cur[0]][cur[1]] = true;
                if (Math.abs(cur[0] - m[0]) + Math.abs(cur[1] - m[1]) <= r2) {
                    f1 = true;
                    map[p[0]][p[1]] = '.';
                    map[cur[0]][cur[1]] = 'P';
                    break;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*'
                        || vis[x][y]
                        || Math.abs(x - p[0]) + Math.abs(y - p[1]) > r1) continue;
                    queue.offer(new int[]{x, y});
                }
            }
            if (f1) break;
            step++;
        }
        if (!f1) {
            System.out.println(-1);
            return;
        }
        queue = new ArrayDeque<>();
        queue.offer(m);
        map[m[0]][m[1]] = '*';
        int s2 = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (map[cur[0]][cur[1]] == 'P') {
                    System.out.println(s2 + step);
                    return;
                }
                map[cur[0]][cur[1]] = '*';
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*') continue;
                    queue.offer(new int[]{x, y});
                }
            }
            s2++;
        }
        System.out.println(-1);
    }
}"
70,C,Java,54860968,2022-11-19 09:43:41,hhhhhn,运行超时,"import java.util.Scanner;
import java.util.ArrayDeque;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        char[][] map = new char[row][col];
        int[] p = null, m = null;
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) {
                map[i][j] = s.charAt(j);
                if (map[i][j] == 'P') p = new int[]{i, j};
                else if (map[i][j] == 'M') m = new int[]{i, j};
            }
        }
        int[][] dd = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(p);
        int step = 0;
        boolean f1 = false;
        boolean[][] vis = new boolean[row][col];
        vis[p[0]][p[1]] = true;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (Math.abs(cur[0] - m[0]) + Math.abs(cur[1] - m[1]) <= r2) {
                    f1 = true;
                    map[p[0]][p[1]] = '.';
                    map[cur[0]][cur[1]] = 'P';
                    break;
                }
                vis[cur[0]][cur[1]] = true;
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*'
                        || vis[x][y]
                        || Math.abs(x - p[0]) + Math.abs(y - p[1]) > r1) continue;
                    queue.offer(new int[]{x, y});
                }
            }
            if (f1) break;
            step++;
        }
        if (!f1) {
            System.out.println(-1);
            return;
        }
        queue = new ArrayDeque<>();
        queue.offer(m);
        map[m[0]][m[1]] = '*';
        int s2 = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (map[cur[0]][cur[1]] == 'P') {
                    System.out.println(s2 + step);
                    return;
                }
                map[cur[0]][cur[1]] = '*';
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*') continue;
                    queue.offer(new int[]{x, y});
                }
            }
            s2++;
        }
        System.out.println(-1);
    }
}"
71,C,Java,54861105,2022-11-19 09:49:43,hhhhhn,运行超时,"import java.util.Scanner;
import java.util.ArrayDeque;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        char[][] map = new char[row][col];
        int[] p = null, m = null;
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) {
                map[i][j] = s.charAt(j);
                if (map[i][j] == 'P') p = new int[]{i, j};
                else if (map[i][j] == 'M') m = new int[]{i, j};
            }
        }
        if (p[0] == m[0] && p[1] == m[1]) {
            System.out.println(0);
            return;
        }
        int[][] dd = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(p);
        int step = 0;
        boolean f1 = false;
        boolean[][] vis = new boolean[row][col];
        vis[p[0]][p[1]] = true;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                vis[cur[0]][cur[1]] = true;
                if (Math.abs(cur[0] - m[0]) + Math.abs(cur[1] - m[1]) <= r2) {
                    f1 = true;
                    p[0] = cur[0];
                    p[1] = cur[1];
                    break;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*'
                        || vis[x][y]
                        || Math.abs(x - p[0]) + Math.abs(y - p[1]) > r1) continue;
                    queue.offer(new int[]{x, y});
                }
            }
            if (f1) break;
            step++;
        }
        if (!f1) {
            System.out.println(-1);
            return;
        }
        queue = new ArrayDeque<>();
        queue.offer(m);
        map[m[0]][m[1]] = '*';
        int s2 = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (cur[0] == p[0] && cur[1] == p[1]) {
                    System.out.println(s2 + step);
                    return;
                }
                map[cur[0]][cur[1]] = '*';
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*') continue;
                    queue.offer(new int[]{x, y});
                }
            }
            s2++;
        }
        System.out.println(-1);
    }
}"
72,C,Java,54861185,2022-11-19 09:53:27,hhhhhn,运行超时,"import java.util.Scanner;
import java.util.ArrayDeque;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        char[][] map = new char[row][col];
        int[] p = null, m = null;
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) {
                map[i][j] = s.charAt(j);
                if (map[i][j] == 'P') p = new int[]{i, j};
                else if (map[i][j] == 'M') m = new int[]{i, j};
            }
        }
        if (p[0] == m[0] && p[1] == m[1]) {
            System.out.println(0);
            return;
        }
        int[][] dd = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(p);
        int step = 0;
        boolean f1 = false;
        boolean[][] vis = new boolean[row][col];
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                vis[cur[0]][cur[1]] = true;
                if (Math.abs(cur[0] - m[0]) + Math.abs(cur[1] - m[1]) <= r2) {
                    f1 = true;
                    p[0] = cur[0];
                    p[1] = cur[1];
                    break;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*'
                        || vis[x][y]
                        || Math.abs(x - p[0]) + Math.abs(y - p[1]) > r1
                        || Math.abs(x - m[0]) + Math.abs(y - m[1]) > Math.abs(cur[0] - m[0]) + Math.abs(cur[0] - m[1])) continue;
                    queue.offer(new int[]{x, y});
                }
            }
            if (f1) break;
            step++;
        }
        if (!f1) {
            System.out.println(-1);
            return;
        }
        queue = new ArrayDeque<>();
        queue.offer(m);
        int s2 = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (cur[0] == p[0] && cur[1] == p[1]) {
                    System.out.println(s2 + step);
                    return;
                }
                map[cur[0]][cur[1]] = '*';
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*') continue;
                    queue.offer(new int[]{x, y});
                }
            }
            s2++;
        }
        System.out.println(-1);
    }
}"
73,C,Java,54861214,2022-11-19 09:55:25,hhhhhn,答案错误,"import java.util.Scanner;
import java.util.ArrayDeque;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        char[][] map = new char[row][col];
        int[] p = null, m = null;
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) {
                map[i][j] = s.charAt(j);
                if (map[i][j] == 'P') p = new int[]{i, j};
                else if (map[i][j] == 'M') m = new int[]{i, j};
            }
        }
        if (p[0] == m[0] && p[1] == m[1]) {
            System.out.println(0);
            return;
        }
        int[][] dd = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(p);
        int step = 0;
        boolean f1 = false;
        boolean[][] vis = new boolean[row][col];
        vis[p[0]][p[1]] = true;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (Math.abs(cur[0] - m[0]) + Math.abs(cur[1] - m[1]) <= r2) {
                    f1 = true;
                    p[0] = cur[0];
                    p[1] = cur[1];
                    break;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*'
                        || vis[x][y]
                        || Math.abs(x - p[0]) + Math.abs(y - p[1]) > r1
                        || Math.abs(x - m[0]) + Math.abs(y - m[1]) > Math.abs(cur[0] - m[0]) + Math.abs(cur[0] - m[1])) continue;
                    vis[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
            if (f1) break;
            step++;
        }
        if (!f1) {
            System.out.println(-1);
            return;
        }
        queue = new ArrayDeque<>();
        queue.offer(m);
        map[m[0]][m[1]] = '*';
        int s2 = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            for (int i = 0; i < len; i++) {
                int[] cur = queue.poll();
                if (cur[0] == p[0] && cur[1] == p[1]) {
                    System.out.println(s2 + step);
                    return;
                }
                for (int[] d : dd) {
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if (x < 0 || y < 0 || x >= row || y >= col
                        || map[x][y] == '*') continue;
                    map[x][y] = '*';
                    queue.offer(new int[]{x, y});
                }
            }
            s2++;
        }
        System.out.println(-1);
    }
}"
74,C,Java,54862668,2022-11-19 10:48:29,hhhhhn,答案错误,"import java.util.Scanner;
import java.util.ArrayDeque;
import java.util.Arrays;

public class Main {
    static int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    static int INF = 999999999;
    static char[][] map;
    static int[] p, m;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        map = new char[row][col];
        int[][][] arr = new int[2][row][col];
        for (int i = 0; i < 2; i++)
            for (int j = 0; j < row; j++) 
                for (int k = 0; k < col; k++) arr[i][j][k] = INF;
        
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) 
                map[i][j] = s.charAt(j);
        }
        
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++)
                if (map[i][j] == 'P') bfs(0, i, j, r1, arr);
                else if (map[i][j] == 'M') bfs(1, i, j, INF, arr);

        int ans = INF;
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++) ans = Math.min(ans, arr[0][i][j] + arr[1][i][j]);
        System.out.println(ans == INF ? -1 : ans);
    }
    
    private static void bfs(int idx, int r, int c, int rr, int[][][] arr) {
        arr[idx][r][c] = 0;
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{r, c});
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            for (int[] d : dir) {
                int x = cur[0] + d[0];
                int y = cur[1] + d[1];
                if (!check(x, y) || arr[idx][x][y] == INF || map[x][y] == '*' || Math.abs(x - r) + Math.abs(y - c) > rr) continue;
                arr[idx][x][y] = arr[idx][cur[0]][cur[1]] + 1;
                queue.offer(new int[]{x, y});
            }
        }
    }
    private static boolean check(int x, int y) {
        return x >= 0 && y >= 0 && x < map.length && y < map[0].length;
    }
}"
75,C,Java,54862894,2022-11-19 10:55:49,hhhhhn,答案正确,"import java.util.Scanner;
import java.util.ArrayDeque;
import java.util.Arrays;

public class Main {
    static int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    static int INF = 999999999;
    static char[][] map;
    static int[] p, m;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt(), col = sc.nextInt();
        int r1 = sc.nextInt(), r2 = sc.nextInt();
        map = new char[row][col];
        int[][][] arr = new int[2][row][col];
        for (int i = 0; i < 2; i++)
            for (int j = 0; j < row; j++) 
                for (int k = 0; k < col; k++) arr[i][j][k] = INF;
        
        for (int i = 0; i < row; i++) {
            String s = sc.next();
            for (int j = 0; j < col; j++) 
                map[i][j] = s.charAt(j);
        }
        
        int nx = 0, ny = 0;
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++)
                if (map[i][j] == 'P') bfs(0, i, j, r1, arr);
                else if (map[i][j] == 'M') {
                    bfs(1, i, j, INF, arr);
                    nx = i;
                    ny = j;
                }
        

        int ans = INF;
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++) {
                if (Math.abs(i - nx) + Math.abs(j - ny) <= r2)
                    ans = Math.min(ans, arr[0][i][j] + arr[1][i][j]);
            }
        System.out.println(ans == INF ? -1 : ans);
    }
    
    private static void bfs(int idx, int r, int c, int rr, int[][][] arr) {
        arr[idx][r][c] = 0;
        ArrayDeque<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{r, c});
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            for (int[] d : dir) {
                int x = cur[0] + d[0];
                int y = cur[1] + d[1];
                if (!check(x, y) || map[x][y] == '*' || arr[idx][x][y] != INF || Math.abs(x - r) + Math.abs(y - c) > rr) continue;
                arr[idx][x][y] = arr[idx][cur[0]][cur[1]] + 1;
                queue.offer(new int[]{x, y});
            }
        }
    }
    private static boolean check(int x, int y) {
        return x >= 0 && y >= 0 && x < map.length && y < map[0].length;
    }
}"
76,C,Java,54865486,2022-11-19 12:33:11,亭亭好きだ,答案正确,"import java.util.*;
import java.io.*;
import java.math.*;
import java.text.*;
import java.util.Scanner;

public class Main {
    static int move[][] = {{1, 0}, { -1, 0}, {0, 1}, {0, -1}};
    public static void main(String args[]) throws IOException {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int r1 = sc.nextInt();
        int r2 = sc.nextInt();
        char c[][] = new char[n][];
        for (int i = 0; i < n; i++) {
            c[i] = sc.next().toCharArray();
        }
        //两个人的位置
        int mm[] = find(c, 'M');
        int pp[] = find(c, 'P');
        int dm[][] = dis(c, mm, m * n + 1);
        int dp[][] = dis(c, pp, r1);
        if (Math.abs(mm[0] - pp[0]) + Math.abs(mm[1] - pp[1]) <= r2) {
           System.out.println(dm[pp[0]][pp[1]]);
        } else {
            int ans = 10000000;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (Math.abs(i - mm[0]) + Math.abs(j - mm[1]) == r2 && dm[i][j] != -1 && dp[i][j] != -1) {
                        ans = Math.min(ans, dm[i][j] + dp[i][j]);
                    }
                }
            }
            System.out.println(ans == 10000000 ? -1 : ans);
        }
        //sc.print(0);
        
        sc.close();
    }
    static int[][] dis(char c[][], int pp[], int max) {
        int ans[][] = new int[c.length][c[0].length];
        for (int i = 0; i < c.length; i++) {
            Arrays.fill(ans[i], -1);
        }
        ans[pp[0]][pp[1]] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(pp);
        while (q.size() > 0) {
            int aa[] = q.poll();
            if (ans[aa[0]][aa[1]] >= max) {
                continue;
            }
            for (int m[] : move) {
                int x = aa[0] + m[0], y = aa[1] + m[1];
                if (x < 0 || x == c.length || y < 0 || y == c[0].length || ans[x][y] != -1 || c[x][y] == '*') {
                    continue;
                }
                ans[x][y] = ans[aa[0]][aa[1]] + 1;
                q.add(new int[] {x, y});
            }
        }
        return ans;
    }
    public static int[] find(char c[][], char ch) {
        for (int i = 0; i < c.length; i++) {
            for (int j = 0; j < c[0].length; j++) {
                if (c[i][j] == ch) {
                    return new int[] {i, j};
                }
            }
        }
        return new int[] { -1, -1};
    }
}"
77,C,Java,54884622,2022-11-19 20:29:39,牛客489187966号,答案正确,"
import java.io.*;
import java.util.*;

public class Main {

    static int N = 1010, sx, sy, ex, ey;
    static int[][] dist = new int[N][N];
    static boolean[][] used = new boolean[N][N];
    static char[][] map = new char[N][N];
    static List<int[]> list = new ArrayList<>();
    static int[][] df = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};


    public static void main(String[] args) throws IOException {
        initReader();
        int n = nextInt();
        int m = nextInt();
        int r1 = nextInt();
        int r2 = nextInt();
        for (int i = 1; i <= n; i++) {
            String s = next();
            char[] chars = s.toCharArray();
            for (int j = 1; j <= m; j++) {
                map[i][j] = chars[j - 1];
                if (map[i][j] == 'P') {
                    sx = i;
                    sy = j;
                }
                if (map[i][j] == 'M') {
                    ex = i;
                    ey = j;
                }
            }
        }

        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{sx, sy});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && dist[nx][ny] == 0 && Math.abs(nx - sx) + Math.abs(ny - sy) <= r1) {
                    queue.add(new int[]{nx, ny});
                    dist[nx][ny] = dist[x][y] + 1;
                    list.add(new int[]{nx, ny,dist[nx][ny]});
                }
            }
        }

        for (int i = 0; i < N; i++) {
            Arrays.fill(dist[i], 0);
            Arrays.fill(used[i], false);
        }

        queue.add(new int[]{ex, ey});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && dist[nx][ny] == 0) {
                    queue.add(new int[]{nx, ny});
                    dist[nx][ny] = dist[x][y] + 1;
                }
            }
        }

        boolean f = false;
        int ans = 0x3f3f3f3f;
        for (int[] e : list) {
            int x = e[0];
            int y = e[1];
            int w = e[2];
            if (Math.abs(x - ex) + Math.abs(y - ey) <= r2) {
                if (dist[x][y] != 0) {
                    f = true;
                    ans = Math.min(w + dist[x][y], ans);
                }
            }
        }

        pw.println(f ? ans : -1);


        pw.close();
    }


    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter pw;

    public static void initReader() throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = new StringTokenizer("""");
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    }


    public static boolean hasNext() {
        try {
            while (!tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(reader.readLine());
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        try {
            return reader.readLine();
        } catch (Exception e) {
            return null;
        }
    }

    public static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    public static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

    public static char nextChar() throws IOException {
        return next().charAt(0);
    }
}
"
78,C,Java,54890358,2022-11-19 22:37:50,shitter,运行超时,"import java.io.*;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;

public class Main {

    static InputReader in;
    static OutputWriter out;

    static int n,m;
    static int r1,r2;
    static int x1,y1,x2,y2;
    static char[][] s;

    public static void main(String[] args) throws IOException {
        in=new InputReader(System.in);
        out=new OutputWriter(System.out);

        n=in.nextInt();
        m=in.nextInt();

        r1=in.nextInt();
        r2=in.nextInt();

        s=new char[n+1][m+1];
        for(int i=1;i<=n;i++)
            s[i]=("" ""+in.next()).toCharArray();

        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++) {
                if(s[i][j]=='P') {
                    x1=i;
                    y1=j;
                }
                else if(s[i][j]=='M') {
                    x2=i;
                    y2=j;
                }
            }
        }

        if(distance(x1,y1,x2,y2)>r2) {
            long[][] dis1=new long[n+1][m+1];
            for(int i=1;i<=n;i++) {
                for(int j=1;j<=m;j++)
                    dis1[i][j]=Integer.MAX_VALUE;
            }
            dis1[x1][y1]=0;

            boolean[][] vis1=new boolean[n+1][m+1];

            HashSet<Pair> set1=new HashSet<>();
            set1.add(new Pair(x1,y1));
            while(!set1.isEmpty()) {
                for(Pair p:(HashSet<Pair>)set1.clone()) {
                    set1.remove(p);
                    vis1[p.x][p.y]=true;

                    if(p.x>1) {
                        if(!vis1[p.x-1][p.y] && s[p.x-1][p.y]=='.' && distance(p.x-1,p.y,x1,y1)<=r1) {
                            dis1[p.x-1][p.y]=dis1[p.x][p.y]+1;
                            set1.add(new Pair(p.x-1,p.y));
                        }
                    }
                    if(p.x<n) {
                        if(!vis1[p.x+1][p.y] && s[p.x+1][p.y]=='.' && distance(p.x+1,p.y,x1,y1)<=r1) {
                            dis1[p.x+1][p.y]=dis1[p.x][p.y]+1;
                            set1.add(new Pair(p.x+1,p.y));
                        }
                    }
                    if(p.y>1) {
                        if(!vis1[p.x][p.y-1] && s[p.x][p.y-1]=='.' && distance(p.x,p.y-1,x1,y1)<=r1) {
                            dis1[p.x][p.y-1]=dis1[p.x][p.y]+1;
                            set1.add(new Pair(p.x,p.y-1));
                        }
                    }
                    if(p.y<m) {
                        if(!vis1[p.x][p.y+1] && s[p.x][p.y+1]=='.' && distance(p.x,p.y+1,x1,y1)<=r1) {
                            dis1[p.x][p.y+1]=dis1[p.x][p.y]+1;
                            set1.add(new Pair(p.x,p.y+1));
                        }
                    }
                }
            }

            long[][] dis2=new long[n+1][m+1];
            for(int i=1;i<=n;i++) {
                for(int j=1;j<=m;j++)
                    dis2[i][j]=Integer.MAX_VALUE;
            }
            dis2[x2][y2]=0;

            boolean[][] vis2=new boolean[n+1][m+1];

            HashSet<Pair> set2=new HashSet<>();
            set2.add(new Pair(x2,y2));
            while(!set2.isEmpty()) {
                for(Pair p:(HashSet<Pair>)set2.clone()) {
                    set2.remove(p);
                    vis2[p.x][p.y]=true;

                    if(p.x>1) {
                        if(!vis2[p.x-1][p.y] && s[p.x-1][p.y]=='.') {
                            dis2[p.x-1][p.y]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x-1,p.y));
                        }
                    }
                    if(p.x<n) {
                        if(!vis2[p.x+1][p.y] && s[p.x+1][p.y]=='.') {
                            dis2[p.x+1][p.y]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x+1,p.y));
                        }
                    }
                    if(p.y>1) {
                        if(!vis2[p.x][p.y-1] && s[p.x][p.y-1]=='.') {
                            dis2[p.x][p.y-1]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x,p.y-1));
                        }
                    }
                    if(p.y<m) {
                        if(!vis2[p.x][p.y+1] && s[p.x][p.y+1]=='.') {
                            dis2[p.x][p.y+1]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x,p.y+1));
                        }
                    }
                }
            }

            long ans=Long.MAX_VALUE;
            for(int i=1;i<=n;i++) {
                for(int j=1;j<=m;j++) {
                    if(distance(i,j,x2,y2)==r2)
                        ans=Math.min(dis1[i][j]+dis2[i][j],ans);
                }
            }

            if(ans>n*m)
                ans=-1;
            out.println(ans);
        }
        else {
            long[][] dis2=new long[n+1][m+1];
            for(int i=1;i<=n;i++) {
                for(int j=1;j<=m;j++)
                    dis2[i][j]=Integer.MAX_VALUE;
            }
            dis2[x2][y2]=0;

            boolean[][] vis2=new boolean[n+1][m+1];

            HashSet<Pair> set2=new HashSet<>();
            set2.add(new Pair(x2,y2));
            while(!set2.isEmpty()) {
                for(Pair p:(HashSet<Pair>)set2.clone()) {
                    set2.remove(p);
                    vis2[p.x][p.y]=true;

                    if(p.x>1) {
                        if(!vis2[p.x-1][p.y] && s[p.x-1][p.y]!='*') {
                            dis2[p.x-1][p.y]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x-1,p.y));
                        }
                    }
                    if(p.x<n) {
                        if(!vis2[p.x+1][p.y] && s[p.x+1][p.y]!='*') {
                            dis2[p.x+1][p.y]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x+1,p.y));
                        }
                    }
                    if(p.y>1) {
                        if(!vis2[p.x][p.y-1] && s[p.x][p.y-1]!='*') {
                            dis2[p.x][p.y-1]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x,p.y-1));
                        }
                    }
                    if(p.y<m) {
                        if(!vis2[p.x][p.y+1] && s[p.x][p.y+1]!='*') {
                            dis2[p.x][p.y+1]=dis2[p.x][p.y]+1;
                            set2.add(new Pair(p.x,p.y+1));
                        }
                    }
                }
            }

            long ans=dis2[x1][y1];
            if(ans>n*m)
                ans=-1;

            out.println(ans);
        }

        out.flush();
    }

    static class Pair {
        int x;
        int y;

        public Pair(int x,int y) {
            this.x=x;
            this.y=y;
        }
    }

    private static int distance(int x1,int y1,int x2,int y2) {
        return Math.abs(x1-x2)+Math.abs(y1-y2);
    }

    static class InputReader  {
        private final BufferedReader br;

        public InputReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream));
        }

        public int nextInt() throws IOException {
            int c = br.read();
            while (c <= 32) {
                c = br.read();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = br.read();
            }
            int x = 0;
            while (c > 32) {
                x = x * 10 + c - '0';
                c = br.read();
            }
            return negative ? -x : x;
        }

        public long nextLong() throws IOException {
            int c = br.read();
            while (c <= 32) {
                c = br.read();
            }
            boolean negative = false;
            if (c == '-') {
                negative = true;
                c = br.read();
            }
            long x = 0;
            while (c > 32) {
                x = x * 10 + c - '0';
                c = br.read();
            }
            return negative ? -x : x;
        }

        public String next() throws IOException {
            int c = br.read();
            while (c <= 32) {
                c = br.read();
            }
            StringBuilder sb = new StringBuilder();
            while (c > 32) {
                sb.append((char) c);
                c = br.read();
            }
            return sb.toString();
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    static class OutputWriter {

        private final BufferedWriter writer;

        public OutputWriter(OutputStream out) {
            writer=new BufferedWriter(new OutputStreamWriter(out));
        }

        public void print(String str) {
            try {
                writer.write(str);
            }
            catch (IOException e) {
                e.printStackTrace();
            }
        }

        public void print(Object obj) {
            print(String.valueOf(obj));
        }

        public void println(String str) {
            print(str+""\n"");
        }

        public void println() {
            print('\n');
        }

        public void println(Object obj) {
            println(String.valueOf(obj));
        }

        public void flush() {
            try {
                writer.flush();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

}"
79,C,Java,54900491,2022-11-20 15:10:27,桃李.,编译错误,"{""SPECIAL_TM_FH_MEMO_JSON_TAG"":""SPECIAL_TM_FH_MEMO_JSON_TAG"",""stderr"":""Main.java:42: error: cannot find symbol\n        for (var i : per) Arrays.fill(i, -1); // 初始化距离\n             ^\n  symbol:   class var\n  location: class Main\nMain.java:47: error: cannot find symbol\n            var t = q.poll();\n            ^\n  symbol:   class var\n  location: class Main\nMain.java:58: error: cannot find symbol\n        for (var i : cat) Arrays.fill(i, -1); // 初始化距离\n             ^\n  symbol:   class var\n  location: class Main\nMain.java:63: error: cannot find symbol\n            var t = p.poll();\n            ^\n  symbol:   class var\n  location: class Main\n4 errors""}

// package com.csh.C;
/**
 * @author :Changersh
 * @date : 2022/11/18
 */

import java.io.*;
import java.util.*;
import java.lang.*;

public class Main {
    private static int N = 1005, n, m, r1, r2, x1, x2, y1, y2;
    private static int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};
    private static char[][] g = new char[N][N];
    private static int[][] per = new int[N][N], cat = new int[N][N];
    public static void main(String[] args) {
        n = sc.nextInt(); m = sc.nextInt(); r1 = sc.nextInt(); r2 = sc.nextInt();
        for (int i = 0; i < n; i++) {
            g[i] = sc.next().toCharArray();
            Arrays.fill(per[i], -1);
            Arrays.fill(cat[i], -1);
        }
        int[] a = find('P');
        x1 = a[0]; y1 = a[1];
        int[] b = find('M');
        x2 = b[0]; y2 = b[1];
        bfs();
        // 确定好距离之后，判断是否能走到猫咪的嗅觉内，并且猫咪能到达的点
        int ans = 20021016;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m ;j++) {
                if ((Math.abs(i - x2) + Math.abs(j - y2)) <= r2 && per[i][j] != -1 && cat[i][j] != -1) {
                    ans = Math.min(per[i][j] + cat[i][j], ans);
                }
            }
        }
        out.println(ans == 20021016 ? -1 : ans);
        out.close();
    }
    private static void bfs() {
        // 人
        for (var i : per) Arrays.fill(i, -1); // 初始化距离
        per[x1][y1] = 0;
        LinkedList<int[]> q = new LinkedList<>();
        q.add(new int[]{x1, y1});
        while (!q.isEmpty()) {
            var t = q.poll();
            int a = t[0]; int b = t[1];
            for (int i = 0; i < 4; i++) {
                int x = dx[i] +a; int y = dy[i] + b;
                if ( x >= 0 && x < n && y >= 0 && y < m && ((Math.abs(x - x1) + Math.abs(y - y1)) <= r1) && per[x][y] == -1 && g[x][y] != '*') {
                    per[x][y] = per[a][b] + 1;
                    q.add(new int[]{x, y});
                }
            }
        }

        for (var i : cat) Arrays.fill(i, -1); // 初始化距离
        cat[x2][y2] = 0;
        LinkedList<int[]> p = new LinkedList<>();
        p.add(new int[]{x2, y2});
        while (!p.isEmpty()) {
            var t = p.poll();
            int a = t[0]; int b = t[1];
            for (int i = 0; i < 4; i++) {
                int x = dx[i] +a; int y = dy[i] + b;
                if ( x >= 0 && x < n && y >= 0 && y < m && cat[x][y] == -1 && g[x][y] != '*') {
                    cat[x][y] = cat[a][b] + 1;
                    p.add(new int[]{x, y});
                }
            }
        }
    }
    private static int[] find(char c) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (g[i][j] == c) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }

    static class FastScanner{
        // sc.xxx;
        // out.print();
        // out.flush();
        // out.close();
        BufferedReader br;
        StringTokenizer st;
        public FastScanner(InputStream in) {
            br=new BufferedReader( new InputStreamReader(System.in));
            eat("""");
        }
        public void eat(String s) {
            st=new StringTokenizer(s);
        }

        public String nextLine() {
            try {
                return br.readLine();
            }catch(IOException e) {
                return null;
            }
        }

        public boolean hasNext() {
            while(!st.hasMoreTokens()) {
                String s=nextLine();
                if(s==null)return false;
                eat(s);
            }

            return true;
        }

        public String next() {
            hasNext();
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    static FastScanner sc=new FastScanner(System.in);
    static PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
}"
80,C,Java,54900559,2022-11-20 15:11:19,桃李.,答案正确,"// package com.csh.C;
/**
 * @author :Changersh
 * @date : 2022/11/18
 */

import java.io.*;
import java.util.*;
import java.lang.*;

public class Main {
    private static int N = 1005, n, m, r1, r2, x1, x2, y1, y2;
    private static int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};
    private static char[][] g = new char[N][N];
    private static int[][] per = new int[N][N], cat = new int[N][N];
    public static void main(String[] args) {
        n = sc.nextInt(); m = sc.nextInt(); r1 = sc.nextInt(); r2 = sc.nextInt();
        for (int i = 0; i < n; i++) {
            g[i] = sc.next().toCharArray();
            Arrays.fill(per[i], -1);
            Arrays.fill(cat[i], -1);
        }
        int[] a = find('P');
        x1 = a[0]; y1 = a[1];
        int[] b = find('M');
        x2 = b[0]; y2 = b[1];
        bfs();
        // 确定好距离之后，判断是否能走到猫咪的嗅觉内，并且猫咪能到达的点
        int ans = 20021016;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m ;j++) {
                if ((Math.abs(i - x2) + Math.abs(j - y2)) <= r2 && per[i][j] != -1 && cat[i][j] != -1) {
                    ans = Math.min(per[i][j] + cat[i][j], ans);
                }
            }
        }
        out.println(ans == 20021016 ? -1 : ans);
        out.close();
    }
    private static void bfs() {
        // 人
        for (int[] i : per) Arrays.fill(i, -1); // 初始化距离
        per[x1][y1] = 0;
        LinkedList<int[]> q = new LinkedList<>();
        q.add(new int[]{x1, y1});
        while (!q.isEmpty()) {
            int[] t = q.poll();
            int a = t[0]; int b = t[1];
            for (int i = 0; i < 4; i++) {
                int x = dx[i] +a; int y = dy[i] + b;
                if ( x >= 0 && x < n && y >= 0 && y < m && ((Math.abs(x - x1) + Math.abs(y - y1)) <= r1) && per[x][y] == -1 && g[x][y] != '*') {
                    per[x][y] = per[a][b] + 1;
                    q.add(new int[]{x, y});
                }
            }
        }

        for (int[] i : cat) Arrays.fill(i, -1); // 初始化距离
        cat[x2][y2] = 0;
        LinkedList<int[]> p = new LinkedList<>();
        p.add(new int[]{x2, y2});
        while (!p.isEmpty()) {
            int[] t = p.poll();
            int a = t[0]; int b = t[1];
            for (int i = 0; i < 4; i++) {
                int x = dx[i] +a; int y = dy[i] + b;
                if ( x >= 0 && x < n && y >= 0 && y < m && cat[x][y] == -1 && g[x][y] != '*') {
                    cat[x][y] = cat[a][b] + 1;
                    p.add(new int[]{x, y});
                }
            }
        }
    }
    private static int[] find(char c) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (g[i][j] == c) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }

    static class FastScanner{
        // sc.xxx;
        // out.print();
        // out.flush();
        // out.close();
        BufferedReader br;
        StringTokenizer st;
        public FastScanner(InputStream in) {
            br=new BufferedReader( new InputStreamReader(System.in));
            eat("""");
        }
        public void eat(String s) {
            st=new StringTokenizer(s);
        }

        public String nextLine() {
            try {
                return br.readLine();
            }catch(IOException e) {
                return null;
            }
        }

        public boolean hasNext() {
            while(!st.hasMoreTokens()) {
                String s=nextLine();
                if(s==null)return false;
                eat(s);
            }

            return true;
        }

        public String next() {
            hasNext();
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    static FastScanner sc=new FastScanner(System.in);
    static PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
}"
81,C,Java,54956801,2022-11-24 08:50:41,giao1,答案正确,"import java.io.*;
import java.util.*;

public class Main {

    static int N = 1010, sx, sy, ex, ey;
    static int[][] dist = new int[N][N];
    static boolean[][] used = new boolean[N][N];
    static char[][] map = new char[N][N];
    static List<int[]> list = new ArrayList<>();
    static int[][] df = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};


    public static void main(String[] args) throws IOException {
        initReader();
        int n = nextInt();
        int m = nextInt();
        int r1 = nextInt();
        int r2 = nextInt();
        for (int i = 1; i <= n; i++) {
            String s = next();
            char[] chars = s.toCharArray();
            for (int j = 1; j <= m; j++) {
                map[i][j] = chars[j - 1];
                if (map[i][j] == 'P') {
                    sx = i;
                    sy = j;
                }
                if (map[i][j] == 'M') {
                    ex = i;
                    ey = j;
                }
            }
        }

        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{sx, sy});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && dist[nx][ny] == 0 && Math.abs(nx - sx) + Math.abs(ny - sy) <= r1) {
                    queue.add(new int[]{nx, ny});
                    dist[nx][ny] = dist[x][y] + 1;
                    list.add(new int[]{nx, ny,dist[nx][ny]});
                }
            }
        }

        for (int i = 0; i < N; i++) {
            Arrays.fill(dist[i], 0);
            Arrays.fill(used[i], false);
        }

        queue.add(new int[]{ex, ey});
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0];
            int y = t[1];
            for (int i = 0; i < 4; i++) {
                int nx = x + df[i][0];
                int ny = y + df[i][1];
                if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && map[nx][ny] != '*' && dist[nx][ny] == 0) {
                    queue.add(new int[]{nx, ny});
                    dist[nx][ny] = dist[x][y] + 1;
                }
            }
        }

        boolean f = false;
        int ans = 0x3f3f3f3f;
        for (int[] e : list) {
            int x = e[0];
            int y = e[1];
            int w = e[2];
            if (Math.abs(x - ex) + Math.abs(y - ey) <= r2) {
                if (dist[x][y] != 0) {
                    f = true;
                    ans = Math.min(w + dist[x][y], ans);
                }
            }
        }

        pw.println(f ? ans : -1);


        pw.close();
    }


    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter pw;

    public static void initReader() throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        tokenizer = new StringTokenizer("""");
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    }


    public static boolean hasNext() {
        try {
            while (!tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(reader.readLine());
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        try {
            return reader.readLine();
        } catch (Exception e) {
            return null;
        }
    }

    public static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    public static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    public static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

    public static char nextChar() throws IOException {
        return next().charAt(0);
    }
}
"
82,C,Java,60114436,2023-01-04 10:10:15,codingj,答案正确,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
	static char[][]ch = new char[1010][1010];
	static int vis[][] = new int[1010][1010];
	static int dis[][] = new int[1010][1010];
	static int disp[][] = new int[1010][1010];
	static int disc[][] = new int[1010][1010];
	static int dx[] = {0,1,0,-1};
	static int dy[] = {1,0,-1,0};
	static Queue<node>q = new LinkedList<node>();
	static int n = 0, m = 0, r1 = 0, r2 = 0 ,px = 0,py =0, cx = 0, cy = 0;
	public static void main(String[] args) throws Exception {
		solve();
	}
	static void solve() throws Exception {
		String nm[] = br.readLine().split("" "");
		n = Integer.parseInt(nm[0]);
		m = Integer.parseInt(nm[1]);
		String rr[] = br.readLine().split("" "");
		int r1 = Integer.parseInt(rr[0]);
		int r2 = Integer.parseInt(rr[1]);
		for(int i = 1; i <= n; i++) {
			String cc = br.readLine();
			for(int j = 1; j <= m; j++) {
				char c = cc.charAt(j - 1);
				ch[i][j] = c;
				if(c == 'P') { px = i; py = j; }
				if(c == 'M') { cx = i; cy = j; }
			}
		}
		
		for(int i = 0; i < 1010; i++) {
			for(int j = 0; j < 1010; j++) {
				dis[i][j] = 0;
				vis[i][j] = 0;
			}
		}
		
		bfs(cx,cy);
		
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				disc[i][j] = dis[i][j];
			}
		}
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				if(disc[i][j] == 0) {
					disc[i][j] = (int)(1e9);
				}
			}
		}
		disc[cx][cy] = 0;
		
		for(int i = 0; i < 1010; i++) {
			for(int j = 0; j < 1010; j++) {
				dis[i][j] = 0;
				vis[i][j] = 0;
			}
		}
		
		q.clear();
		bfs(px,py);
		
//		for(int i = 1; i <= n; i++) {
//			for(int j = 1; j <= m; j++) {
//				System.out.print(dis[i][j] + "" "");
//			}
//			System.out.println();
//		}
		
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				disp[i][j] = dis[i][j];
			}
		}
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				if(disp[i][j] == 0) {
					disp[i][j] = (int)(1e9);
				}
//				System.out.println(disp[i][j]);
			}
		}
		disp[px][py] = 0;
		
		int ans = (int) 1e9;
	    for(int i = 1;i <= n; i++){
	        for(int j = 1;j <= m; j++){
	            if(Math.abs(cx-i) + Math.abs(cy-j) <= r2){
	                if(disp[i][j] <= r1){
	                    ans = Math.min(ans,disp[i][j] + disc[i][j]);
	                }
	            }
	        }
	    }
	    if(ans == 1e9) {
	    	ans = -1;
	    }
	    System.out.println(ans);
		
	}
	static void bfs(int x, int y) {
		node cur = new node();
		cur.x = x;
		cur.y = y;
		q.add(cur);
		dis[x][y] = 0;
		vis[x][y] = 1;
		while(!q.isEmpty()) {
			
			cur = q.peek();
			q.remove();
			
			for(int i = 0; i < 4; i++) {
				int tx = cur.x + dx[i];
				int ty = cur.y + dy[i];
				if(tx >= 1 && ty >= 1 && tx <=n && ty <= m) {
					if(ch[tx][ty] != '*' && vis[tx][ty] == 0) {
						vis[tx][ty] = 1;
		                dis[tx][ty] = dis[cur.x][cur.y] + 1;
		                node next = new node();
		                next.x = tx;
		                next.y = ty;
		                q.add(next);
					}
				}
			}
		}
	}

}
class node{
	int x,y;
}
"
