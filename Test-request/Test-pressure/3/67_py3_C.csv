,index,languageName,submissionId,submitTime,userName,statusMessage,code
0,C,Python3,60968689,2023-02-24 19:27:17,zxcv0112358,运行超时,"# from math import abs

eps=1e-6
t=int(input())
while t:
    t=t-1
    xb,xc,yc=map(int,input().split())
    area=0.5*xb*yc
    flag=False
    for tmpx in range(0,xb+1,1):
        if tmpx<=xc:
            tmpy=yc/xc*tmpx
            if abs(tmpy*tmpx*0.5*2-area)<=eps:
                print(""YES"")
                flag=True
                break
            else:
                continue
        if tmpx>xc:
            tmpy=yc/(xb-xc)*(xb-tmpx)
            if abs(tmpy*(xb-tmpx)*0.5*2-area)<=eps:
                print(""YES"")
                flag=True
                break
            else:
                continue
    if flag==False:
        print(""NO"")
                "
1,C,Python3,60968927,2023-02-24 19:29:47,zxcv0112358,答案正确,"# from math import abs
from math import ceil

eps=1e-6
t=int(input())
while t:
    t=t-1
    xb,xc,yc=map(int,input().split())
    area=0.5*xb*yc
    flag=False
    for tmpx in range(min(xc,ceil(xb/2)),max(xc,ceil(xb/2))+1,1):
        if tmpx<=xc:
            tmpy=yc/xc*tmpx
            if abs(tmpy*tmpx*0.5*2-area)<=eps:
                print(""YES"")
                flag=True
                break
            else:
                continue
        if tmpx>xc:
            tmpy=yc/(xb-xc)*(xb-tmpx)
            if abs(tmpy*(xb-tmpx)*0.5*2-area)<=eps:
                print(""YES"")
                flag=True
                break
            else:
                continue
    if flag==False:
        print(""NO"")
                "
2,C,Python3,60969278,2023-02-24 19:33:52,牛客481337953号,答案错误,"for _ in range(int(input())):
    a, b, c = map(int, input().split())
    s = a * c
    f = 0
    for i in range(a):
        if i >= b:
            v = c / (a - b) * (a - i) ** 2
        else:
            v = c / b * i ** 2
        if v * 2 == s:
            f = 1
    print(""YES"" if f else ""NO"")
            "
3,C,Python3,60969400,2023-02-24 19:35:07,书生alin,答案正确,"t = int(input())
for i in range(t):
    xb, xc, yc = map(int, input().split())
    if 2*xc == xb:
        print(""YES"")
    elif 2*xc > xb:
        temp = (xb*xc/2)**0.5
        if temp % 1 == 0:
            print(""YES"")
        else:
            print(""NO"")
    else:
        temp = (xb*(xb-xc)/2)**0.5
        if temp % 1 == 0:
            print(""YES"")
        else:
            print(""NO"")

"
4,C,Python3,60969843,2023-02-24 19:40:14,Garett,答案正确,"t=int(input())
ans=[]
for _  in range(t):
    xb,xc,yc=map(int,input().split())
    if xc<xb-xc:
        xc=xb-xc
    temp=xb*xc*yc/(2*yc)
    if (int(temp**0.5))**2==temp and int(temp**0.5)<=xc:
        ans.append('YES')
    else:
        ans.append('NO')
print('\n'.join(ans))"
5,C,Python3,60969953,2023-02-24 19:41:24,牛客481337953号,答案错误,"def ck(i, a, b, c, s):
    if i >= b:
        v = s - c / (a - b) * (a - i) ** 2
    else:
        v = c / b * i ** 2
    return v * 2

for _ in range(int(input())):
    a, b, c = map(int, input().split())
    s = a * c
    f = 0
    l, r = 0, a
    while l <= r:
        m = (l + r) // 2
        v = ck(m, a, b, c, s)
        if v == s:
            f = 1
            break
        elif v > s:
            r = m - 1
        else:
            l = m + 1
    print(""YES"" if f else ""NO"")
            "
6,C,Python3,60970563,2023-02-24 19:48:43,GHOSTANDBREAD,答案错误,"import sys

t = int(input())

for _ in range(t):
    xb, xc, yc = map(int, sys.stdin.readline().split())
    if xc * 2 == xb:
        print(""YES"")
        continue
    else:
        ok = False
        for i in range(xc, xb):
            res = 2 * yc * (xb - i) ** 2 // (xb - xc)
            if res == xb * yc:
                ok = True
                break
        if ok: print(""YES"")
        else: print(""NO"")
    "
7,C,Python3,60970789,2023-02-24 19:51:33,牛客233537359号,答案错误,"T = int(input())
for ca in range(T):
    xb,xc,yc = map(int,input().split())
    s = xb*yc/2
    fl = 0
    if xb - xc > xc:
        xc = xb-xc

   # print(xb,xc,yc,xb*yc)
    for i in range(1,xc+1):
        if 2*i*yc/xc*i == xb*yc:
            fl = 1
            break
    if fl:
        print('YES')

    else:
        print(""NO"")
"
8,C,Python3,60970844,2023-02-24 19:52:20,Paren7,答案错误,"def calc():
    xb, xc, yc = list(map(int, input().split()))
    for x in range(1, xb):
        if x <= xc:
            h = x * yc / xc
        else:
            h = x * yc / (xb - xc)
        # print(x, h, x * h * 2, xb * yc)
        if x * h * 2 == xb * yc:
            
            print(""YES"")
            return
    print(""NO"")


t = int(input())
for _ in range(t):
    calc()
"
9,C,Python3,60970922,2023-02-24 19:53:17,牛客233537359号,答案正确,"T = int(input())
for ca in range(T):
    xb,xc,yc = map(int,input().split())
    s = xb*yc/2
    fl = 0
    if xb - xc > xc:
        xc = xb-xc

   # print(xb,xc,yc,xb*yc)
    for i in range(1,xc+1):
        if abs(2*i*yc/xc*i - xb*yc) < 1e-10:
            fl = 1
            break
    if fl:
        print('YES')

    else:
        print(""NO"")
"
10,C,Python3,60971662,2023-02-24 20:03:19,謝拾叁,答案正确,"import math
T = int(input())
for i in range(T):
    xb,xc,yc = map(int,input().split())
    xc = max(xc,xb-xc)
    x0p = xc * xb / 2
    x0 = math.sqrt(x0p)
    if x0 == int(x0):
        print('YES')
    else:
        print('NO')
"
11,C,Python3,60971681,2023-02-24 20:03:33,Conqueror712,答案错误,"def solve():
    xb, xc, yc = map(float, input().split())
    for i in range(int(xc)+1):
        h = i * (yc / xc)
        s1 = i * h / 2
        s = xb * yc / 2
        s2 = s - s1
        if s1 == s2:
            print(""YES"")
            return
    for i in range(int(xc)+1, int(xb)+1):
        h = (yc / (xb - xc)) * (xb - i)
        s1 = (xb - i) * h / 2
        s = xb * yc / 2
        s2 = s - s1
        if s1 == s2:
            print(""YES"")
            return
    print(""NO"")
    return

T = int(input())
for i in range(T):
    solve()
"
12,C,Python3,60971715,2023-02-24 20:04:04,print(&quot;无聊&quot;),答案错误,"get = False
t = int(input())
while t:
    get = False
    a, b, c = map(int, input().split())
    s = a * c / 4
    k1 = c / b
    k2 = c / (a-b)
    if (pow(2 * s / k1, 0.5) - int(pow(2 * s / k1, 0.5)) == 0 and pow(2 * s / k1, 0.5) <= b):
        get = True
    if (pow(2 * s / k2, 0.5) - int(pow(2 * s / k2, 0.5)) == 0 and pow(2 * s / k2, 0.5) <= a - b):
        get = True
    if (get):
        print(""YES"")
    else:
        print(""NO"")
    t -= 1
"
13,C,Python3,60971990,2023-02-24 20:07:33,牛客481337953号,答案正确,"def ck(i, a, b, c, s):
    if i >= b:
        v = s - c / (a - b) * (a - i) ** 2
    else:
        v = c / b * i ** 2
    return v * 2

for _ in range(int(input())):
    a, b, c = map(int, input().split())
    s = a * c
    f = 0
    l, r = 0, a
    while l <= r:
        m = (l + r) // 2
        v = ck(m, a, b, c, s)
        if abs(v - s) < 0.001:
            f = 1
            break
        elif v > s:
            r = m - 1
        else:
            l = m + 1
    print(""YES"" if f else ""NO"")
            "
14,C,Python3,60972516,2023-02-24 20:14:42,刘雨晖,运行超时,"import sys
input = sys.stdin.readline
import random
import math
from collections import namedtuple as np
from collections import defaultdict as ded
from operator import attrgetter
from collections import Counter as CT
from queue import PriorityQueue as PQ
from itertools import permutations as PE
mod=1000000007

#n=int(input())
#n,m=map(int,input().split())
#a=list(map(int,input().split()))
#d=ded(lambda: 0)



def solve():
    xb,xc,yc=map(int,input().split())
    s=xb*yc/2
    for i in range(1,1001):
        if i<=xc:
            st=i*yc/xc*i/2
            if st*2==s:
                print(""YES"")
                return
        else:
            st= yc*(xb-i)/(xb-xc)*(xb-i)/2
            if st*2==s:
                print(""YES"")
                return
    print(""NO"")






if __name__==""__main__"":
    for T in range(int(input())):
        solve()"
15,C,Python3,60973208,2023-02-24 20:24:24,条条大路通WA,答案错误,"T=int(input())
for i in range(T):
    xb,xc,yc=map(int,input().split("" ""))
#     print(xb,xc,yc)
    S=xb*yc/2
#     print(S)
    flag=0
    flag2=0
    for j in range(1,xb+1):
        if (S-(yc/xc)*j/2==S/2):
            print('YES')
            flag=1
            break;
        if (S-(xb-j)*(yc*(j-xb)/(xc-xb))/2==S/2):
            print('YES')
            flag2=1
            break;

    if (flag==0 and flag2==0):
        print('NO')
        "
16,C,Python3,60973244,2023-02-24 20:25:04,zhaoxl2003,答案错误,"import re
import functools
import random
import sys
import os
import math
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce, cmp_to_key
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heappushpop, heapify, heappop, heappush
from io import BytesIO, IOBase
from copy import deepcopy
import threading
from typing import *
from operator import add, xor, mul, ior, iand, itemgetter
import bisect
from string import ascii_lowercase, ascii_uppercase
BUFSIZE = 4096
inf = float('inf')
if ""PyPy"" in sys.version:
    import pypyjit; pypyjit.set_param('max_unroll_recursion=-1')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin = IOWrapper(sys.stdin)
sys.stdout = IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

t = II()
for _ in range(t):
#     xb = II()
#     xc = II()
#     yc = II()
    xb, xc, yc = LII()
    
    tot = xb * yc / 4
    k1 = yc / xc
    k2 = yc / (xc - xb)
    b = -k2 * xb
    
#     print(""!"", tot, k1, k2)
    
    ok = False
    for x in range(1, xb):
        if x <= xc:
#             print(""<"", x * k1 * x / 2)
            if x * k1 * x / 2 == tot:
                print(""YES"")
                ok = True
                break
        else:
#             print("">"", x * k2 * (xb - x) / 2)
            if (x * k2 + b) * (xb - x) / 2 == tot:
                print(""YES"")
                ok = True
                break
                
    if ok == False:
        print(""NO"")"
17,C,Python3,60973472,2023-02-24 20:28:34,aaaacme,答案错误,"import math
def half_s(xb,xc,yc):
    s=xb*yc*0.5
    ans=xb-math.sqrt(s*(xb-xc)/yc)
#     k=isinstance(ans,int)
#     ans=str(ans)
    if ans-int(ans)==0:
        print('YES')
    else:
        print('NO')
count=int(input())
for _ in range(count):
    xb,xc,yc=input().split(' ')
    xb=int(xb)    
    xc=int(xc)
    yc=int(yc)  
    half_s(xb,xc,yc)"
18,C,Python3,60973491,2023-02-24 20:28:48,zhaoxl2003,答案错误,"import re
import functools
import random
import sys
import os
import math
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce, cmp_to_key
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heappushpop, heapify, heappop, heappush
from io import BytesIO, IOBase
from copy import deepcopy
import threading
from typing import *
from operator import add, xor, mul, ior, iand, itemgetter
import bisect
from string import ascii_lowercase, ascii_uppercase
BUFSIZE = 4096
inf = float('inf')
if ""PyPy"" in sys.version:
    import pypyjit; pypyjit.set_param('max_unroll_recursion=-1')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin = IOWrapper(sys.stdin)
sys.stdout = IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

t = II()
for _ in range(t):
#     xb = II()
#     xc = II()
#     yc = II()
    xb, xc, yc = LII()
    
    tot = xb * yc / 4
    k1 = yc / xc
    k2 = yc / (xc - xb)
    b = -k2 * xb
    
#     print(""!"", tot, k1, k2)
    
    ok = False
    for x in range(0, xb + 1):
        if x <= xc:
#             print(""<"", x * k1 * x / 2)
            if x * k1 * x / 2 - tot == 0:
                print(""YES"")
                ok = True
                break
        else:
#             print("">"", x * k2 * (xb - x) / 2)
            if (x * k2 + b) * (xb - x) / 2 - tot == 0:
                print(""YES"")
                ok = True
                break
                
    if ok == False:
        print(""NO"")"
19,C,Python3,60973611,2023-02-24 20:30:50,aaaacme,答案错误,"import math
def half_s(xb,xc,yc):
    s=xb*yc*0.5
    ans=xb-math.sqrt(s*(xb-xc)/yc)
#     k=isinstance(ans,int)
#     ans=str(ans)
    if ans-int(ans)==0:
        print('YES')
    else:
        print('NO')
count=int(input())
for _ in range(count):
    xb,xc,yc=input().split(' ')
    xb=int(xb)    
    xc=int(xc)
    yc=int(yc)  
    half_s(xb,xc,yc)"
20,C,Python3,60973822,2023-02-24 20:34:35,zhaoxl2003,答案错误,"import re
import functools
import random
import sys
import os
import math
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce, cmp_to_key
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heappushpop, heapify, heappop, heappush
from io import BytesIO, IOBase
from copy import deepcopy
import threading
from typing import *
from operator import add, xor, mul, ior, iand, itemgetter
import bisect
from string import ascii_lowercase, ascii_uppercase
BUFSIZE = 4096
inf = float('inf')
if ""PyPy"" in sys.version:
    import pypyjit; pypyjit.set_param('max_unroll_recursion=-1')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin = IOWrapper(sys.stdin)
sys.stdout = IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

t = II()
for _ in range(t):
#     xb = II()
#     xc = II()
#     yc = II()
    xb, xc, yc = LII()
    
    tot = xb * yc / 4
    tana = yc / xc
    tanb = yc / (xb - xc)
    
    ok = False
    for x in range(0, xb + 1):
        if x <= xc:
            if tot == x * tana * x / 2:
                print(""YES"")
                ok = True
                break
        else:
            if tot == (xb - x) * tanb * (xb - x) / 2:
                print(""YES"")
                ok = True
                break
                
    if ok == False:
        print(""NO"")"
21,C,Python3,60974218,2023-02-24 20:41:31,zhaoxl2003,答案错误,"import re
import functools
import random
import sys
import os
import math
from collections import Counter, defaultdict, deque
from functools import lru_cache, reduce, cmp_to_key
from itertools import accumulate, combinations, permutations
from heapq import nsmallest, nlargest, heappushpop, heapify, heappop, heappush
from io import BytesIO, IOBase
from copy import deepcopy
import threading
from typing import *
from operator import add, xor, mul, ior, iand, itemgetter
import bisect
from string import ascii_lowercase, ascii_uppercase
BUFSIZE = 4096
inf = float('inf')
if ""PyPy"" in sys.version:
    import pypyjit; pypyjit.set_param('max_unroll_recursion=-1')

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin = IOWrapper(sys.stdin)
sys.stdout = IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def I():
    return input()

def II():
    return int(input())

def MII():
    return map(int, input().split())

def LI():
    return list(input().split())

def LII():
    return list(map(int, input().split()))

def GMI():
    return map(lambda x: int(x) - 1, input().split())

def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

t = II()
for _ in range(t):
#     xb = II()
#     xc = II()
#     yc = II()
    xb, xc, yc = LII()
    
    tot = xb * yc
    tana = yc / xc
    tanb = yc / (xb - xc)
    
    ok = False
    
    for x in range(0, xb + 1):
        if x <= xc:
            if tot == x * tana * x * 2:
                print(""YES"")
                ok = True
                break
        else:
            if tot == (xb - x) * tanb * (xb - x) * 2:
                print(""YES"")
                ok = True
                break
                
    if ok == False:
        print(""NO"")"
22,C,Python3,60974255,2023-02-24 20:42:06,许大大1,答案错误,"for i in range(int(input())):
    a = list(map(int,input().split()))
    s = int(a[0]*a[2]/2)
    x,y,z = 0,0,0
    k1 = a[2]/a[0]
    k2 = a[2]/(a[1]-a[0])
    if a[0]/2 == a[1]:
        x+=1
    elif a[1] > a[0]/2:
        for j in range(1,a[1]):
            if int(k1*j*j) ==int(s/2) and type(j) == int:
                print('YES')
    elif a[1] < a[0]/2:
        for q in range(a[1],a[0]):
            if int(k2*(q-a[0])*q) ==int(s/2) and type(q) == int:
                print('YES')
    else:
        print('NO')
                "
23,C,Python3,60974403,2023-02-24 20:44:23,Paren7,答案错误,"def calc():
    xb, xc, yc = list(map(int, input().split()))
    s = float(xb * yc)
    for x in range(1, xb):
        if x <= xc:
            h = (x * yc) / xc
            l = x
        else:
            h = (xb * yc - x * yc) / (xb - xc)
            l = xb - x
        s1 = l * h
        if l * h * 2 == s:
            print(""YES"")
            return
    print(""NO"")


t = int(input())
for _ in range(t):
    calc()
"
24,C,Python3,60974566,2023-02-24 20:46:33,Paren7,答案错误,"def calc():
    xb, xc, yc = list(map(int, input().split()))
    s = float(xb * yc)
    for x in range(1, xb):
        if x < xc:
            h = (x * yc) / xc
            l = x
            if l * h * 2 == s:
                print(""YES"")
                return
        elif x > xc:
            h = (xb * yc - x * yc) / (xb - xc)
            l = xb - x
            if l * h * 2 == s:
                print(""YES"")
                return
        else:
            h = (x * yc) / xc
            l = x
            if l * h * 2 == s:
                print(""YES"")
                return
            h = (xb * yc - x * yc) / (xb - xc)
            l = xb - x
            if l * h * 2 == s:
                print(""YES"")
                return
    print(""NO"")


t = int(input())
for _ in range(t):
    calc()
"
25,C,Python3,60974891,2023-02-24 20:51:45,Paren7,答案正确,"def calc():
    xb, xc, yc = list(map(int, input().split()))
    s = float(xb * yc)
    for x in range(1, xb):
        if x <= xc:
            h = (x * yc) / xc
            l = x
        else:
            h = (xb * yc - x * yc) / (xb - xc)
            l = xb - x
        if abs(l * h * 2 - s) <= 1e-6:
            print(""YES"")
            return
    print(""NO"")


t = int(input())
for _ in range(t):
    calc()
"
26,C,Python3,60975048,2023-02-24 20:54:13,aaaacme,答案错误,"import math
def half_s(xb,xc,yc):
    s=xb*yc*0.5
    if xc/2<xb: 
        ans=xb-math.sqrt(s*(xb-xc)/yc)
    #     k=isinstance(ans,int)
    #     ans=str(ans)
        if ans-int(ans)==0:
            print('YES')
        else:
            print('NO')
    else:
        ans=math.sqrt(s*xc/yc)
        if ans-int(ans)==0:
            print('YES')
        else:
            print('NO')   
count=int(input())
for _ in range(count):
    xb,xc,yc=input().split(' ')
    xb=int(xb)    
    xc=int(xc)
    yc=int(yc)  
    half_s(xb,xc,yc)"
27,C,Python3,60975088,2023-02-24 20:54:45,aaaacme,答案正确,"import math
def half_s(xb,xc,yc):
    s=xb*yc*0.5
    if xc<xb/2: 
        ans=xb-math.sqrt(s*(xb-xc)/yc)
    #     k=isinstance(ans,int)
    #     ans=str(ans)
        if ans-int(ans)==0:
            print('YES')
        else:
            print('NO')
    else:
        ans=math.sqrt(s*xc/yc)
        if ans-int(ans)==0:
            print('YES')
        else:
            print('NO')   
count=int(input())
for _ in range(count):
    xb,xc,yc=input().split(' ')
    xb=int(xb)    
    xc=int(xc)
    yc=int(yc)  
    half_s(xb,xc,yc)"
28,C,Python3,60975753,2023-02-24 21:06:19,Paren7,答案正确,"def calc():
    xb, xc, yc = list(map(int, input().split()))
    s = xb * yc
    for x in range(1, xb):
        if x <= xc:
            h = (x * yc)
            l = x
            c = xc
        else:
            h = (xb * yc - x * yc)
            c = xb - xc
            l = xb - x
        if l * h * 2 == s * c:
            print(""YES"")
            return
    print(""NO"")


t = int(input())
for _ in range(t):
    calc()
"
29,C,Python3,60975942,2023-02-24 21:11:52,尉大帅的同学,答案错误,"A=input()
A=int(A)
B=[]
C=[]
X_0=0
k=0
for i in range(1,A+1):
    B=input().split(' ')
    B[0] = int(B[0])
    B[1] = int(B[1])
    B[2] = int(B[2])
    C.append(B[0])
    C.append(B[1])
    C.append(B[2])
for i in range(1,A+1):
    S_2bei=C[k]*C[k+2]
    S_2_yiban=C[k+1]*C[k+2]
    S_3=S_2bei-S_2_yiban
    if C[k]>C[k+1]*2:
       xielv_1=C[k+2]/(C[k+1]-C[k])
       X_0=C[k+1]-S_2bei/(2*xielv_1)
    if C[k]<C[k+1]*2:
       xielv=C[k+2]/C[k+1]
       X_0=S_2bei/2*xielv
    if X_0==int(X_0):
        print(""YES"")
    else:
        print(""NO"")
    k+=3
    "
30,C,Python3,60975943,2023-02-24 21:11:55,尉大帅的同学,答案错误,"A=input()
A=int(A)
B=[]
C=[]
X_0=0
k=0
for i in range(1,A+1):
    B=input().split(' ')
    B[0] = int(B[0])
    B[1] = int(B[1])
    B[2] = int(B[2])
    C.append(B[0])
    C.append(B[1])
    C.append(B[2])
for i in range(1,A+1):
    S_2bei=C[k]*C[k+2]
    S_2_yiban=C[k+1]*C[k+2]
    S_3=S_2bei-S_2_yiban
    if C[k]>C[k+1]*2:
       xielv_1=C[k+2]/(C[k+1]-C[k])
       X_0=C[k+1]-S_2bei/(2*xielv_1)
    if C[k]<C[k+1]*2:
       xielv=C[k+2]/C[k+1]
       X_0=S_2bei/2*xielv
    if X_0==int(X_0):
        print(""YES"")
    else:
        print(""NO"")
    k+=3
    "
31,C,Python3,60975974,2023-02-24 21:12:41,尉大帅的同学,答案错误,"A=input()
A=int(A)
B=[]
C=[]
X_0=0
k=0
for i in range(1,A+1):
    B=input().split(' ')
    B[0] = int(B[0])
    B[1] = int(B[1])
    B[2] = int(B[2])
    C.append(B[0])
    C.append(B[1])
    C.append(B[2])
for i in range(1,A+1):
    S_2bei=C[k]*C[k+2]
    S_2_yiban=C[k+1]*C[k+2]
    S_3=S_2bei-S_2_yiban
    if C[k]>C[k+1]*2:
       xielv_1=C[k+2]/(C[k+1]-C[k])
       X_0=C[k+1]-S_2bei/(2*xielv_1)
    if C[k]<C[k+1]*2:
       xielv=C[k+2]/C[k+1]
       X_0=S_2bei/2*xielv
    if X_0==int(X_0):
        print(""YES"")
    else:
        print(""NO"")
    k+=3
    "
32,C,Python3,60975984,2023-02-24 21:12:51,尉大帅的同学,答案错误,"A=input()
A=int(A)
B=[]
C=[]
X_0=0
k=0
for i in range(1,A+1):
    B=input().split(' ')
    B[0] = int(B[0])
    B[1] = int(B[1])
    B[2] = int(B[2])
    C.append(B[0])
    C.append(B[1])
    C.append(B[2])
for i in range(1,A+1):
    S_2bei=C[k]*C[k+2]
    S_2_yiban=C[k+1]*C[k+2]
    S_3=S_2bei-S_2_yiban
    if C[k]>C[k+1]*2:
       xielv_1=C[k+2]/(C[k+1]-C[k])
       X_0=C[k+1]-S_2bei/(2*xielv_1)
    if C[k]<C[k+1]*2:
       xielv=C[k+2]/C[k+1]
       X_0=S_2bei/2*xielv
    if X_0==int(X_0):
        print(""YES"")
    else:
        print(""NO"")
    k+=3
    "
33,C,Python3,60977579,2023-02-24 22:23:51,只会暴力啊,答案错误,"# 三个点的坐标求三角形面积

t = int(input())
for i in range(t):
    xb, xc, yc = list(map(int, input().split()))
#     print(xb, xc, yc)
    ok = False
    if xb >= xc:
        for x0 in range(xb+1):
            # print(getArea(0, 0, xb, 0, xc, yc)/2, getArea(0, 0, x0, 0, x0, k*x0))
            area1 = xb*yc/2
            if x0 <= xc:
                k = yc/xc
                area2 = x0*k*x0
            else:
                k = yc/(xc-xb)
                area2 = (xb-x0)*(k*x0-k*xb)
            if area1 == area2:
#                 print(x0, area1, area2)
                ok = True
                break
    else:
        for x0 in range(xc+1):
            # print(getArea(0, 0, xb, 0, xc, yc)/2, getArea(0, 0, x0, 0, x0, k*x0))
            area1 = xb*yc/2
            if x0 <= xb:
                k = yc/xc
                area2 = x0*k*x0
            else:
                k1 = yc/xc
                k2 = yc/(xc-xb)
                area2 = (xc-x0)*(k1*x0-k2*x0)
            
            if area2 == area1 :
#                 print(x0, area1, area2)
                ok = True
                break
    if ok:
        print(""YES"")
    else:
        print(""NO"")
"
34,C,Python3,60977611,2023-02-24 22:25:41,只会暴力啊,答案错误,"# 三个点的坐标求三角形面积

t = int(input())
for i in range(t):
    xb, xc, yc = list(map(int, input().split()))
#     print(xb, xc, yc)
    ok = False
    for x0 in range(xb+1):
        # print(getArea(0, 0, xb, 0, xc, yc)/2, getArea(0, 0, x0, 0, x0, k*x0))
        area1 = xb*yc/2
        if x0 <= xc:
            k = yc/xc
            area2 = x0*k*x0
        else:
            k = yc/(xc-xb)
            area2 = (xb-x0)*(k*x0-k*xb)
        if area1 == area2:
#                 print(x0, area1, area2)
            ok = True
            break
    if ok:
        print(""YES"")
    else:
        print(""NO"")
"
35,C,Python3,60977780,2023-02-24 22:39:43,只会暴力啊,答案错误,"# 三个点的坐标求三角形面积

t = int(input())
for i in range(t):
    xb, xc, yc = list(map(int, input().split()))
    ok = False
    for x0 in range(xb+1):
        area1 = xb*yc/2
        if x0 <= xc:
            area2 = x0*(yc/xc)*x0
        else:
            k1=yc/(xc-xb)
            area2=(k1*x0-k1*xb)*(xb-x0)
        # print(x0, area1, area2)
        if area1 == area2:
            ok = True
            break
    if ok:
        print(""YES"")
    else:
        print(""NO"")
"
36,C,Python3,60977842,2023-02-24 22:45:04,只会暴力啊,答案错误,"# 三个点的坐标求三角形面积

t = int(input())
for i in range(t):
    xb, xc, yc = list(map(int, input().split()))
    ok = False
    for x0 in range(xb):
        area1 = xb*yc/2
        if x0 <= xc:
            area2 = x0*(yc/xc)*x0
        else:
            k1=yc/(xc-xb)
            area2=(k1*x0-k1*xb)*(xb-x0)
        # print(x0, area1, area2)
        if area1 == area2:
            ok = True
            break
    if ok:
        print(""YES"")
    else:
        print(""NO"")
"
37,C,Python3,60977848,2023-02-24 22:46:05,只会暴力啊,答案错误,"# 三个点的坐标求三角形面积

t = int(input())
for i in range(t):
    xb, xc, yc = list(map(int, input().split()))
    ok = False
    for x0 in range(1,xb):
        area1 = xb*yc/2
        if x0 <= xc:
            area2 = x0*(yc/xc)*x0
        else:
            k1=yc/(xc-xb)
            area2=(k1*x0-k1*xb)*(xb-x0)
        # print(x0, area1, area2)
        if area1 == area2:
            ok = True
            break
    if ok:
        print(""YES"")
    else:
        print(""NO"")
"
38,C,Python3,60977862,2023-02-24 22:48:10,陈立03,答案正确,"import math
T = int(input())
for i in range(T):
    xb,xc,yc = map(int,input().split())
    xc = max(xc,xb-xc)
    x0p = xc * xb / 2
    x0 = math.sqrt(x0p)
    if x0 == int(x0):
        print('YES')
    else:
        print('NO')
"
39,C,Python3,60978564,2023-02-24 23:56:14,正在卷的艾伦很能干,运行超时,"n = int(input())
for i in range(n):
    xb,xc,yc = map(int,input().split())
    for j in range(1,xb):
        if j <= xc and 2*(j**2) == xb*xc:
            print(""YES"")
            break
        elif j> xc and 2* (xb-j)**2 == xb*(xb-xc):
            print(""YES"")
            break
    else:
        print(""NO"")"
40,C,Python3,60980325,2023-02-25 11:33:17,大大业,答案正确,"n = int(input())
while n > 0:
    n -= 1
    flag = 0
    xb, xc, yc = map(int, input().split())
    S = xb * yc
    for i in range(xb + 1):
        if i <= xc:
            if 2*i*i*yc%xc == 0:
                s = 2*i*i*yc/xc
                if s == S:
                    flag = 1
                    break
        else:
            if 2*(xb-i)*(xb-i)*yc%(xb-xc) == 0:
                s = 2*yc*(xb-i)*(xb-i)/(xb-xc)
                if s == S:
                    flag = 1
                    break
    if flag: print(""YES"")
    else: print(""NO"")"
41,C,Python3,60981458,2023-02-25 13:22:14,GHOSTANDBREAD,答案错误,"import sys

t = int(input())

for _ in range(t):
    xb, xc, yc = map(int, sys.stdin.readline().split())
    if xc * 2 == xb:
        print(""YES"")
        continue
    else:
        ok = False
        for i in range(xc, xb):
            res = 2 * yc * (xb - i) ** 2
            if res == xb * yc * (xb - xc):
                ok = True
                break
        if ok: print(""YES"")
        else: print(""NO"")
    "
42,C,Python3,60986205,2023-02-25 19:00:12,牛客545811652号,答案错误,"def fangcheng1(xc,yc):
    k=yc/xc
    return k
def fangcheng2(xb,xc,yc):
    b=((0-(yc*xb))/(xc-xb))
    k=-b/xb
    return k,b
T=int(input())
a=[]
Y=[]
for i in range(T):
    caozuo=list(map(int,input().split()))
    a.append(caozuo)
for i in a:
    S=abs(i[0])*abs(i[2])/2
    if i[0]>0 and i[1]>0 and i[2]>0:
        for j in range(i[0],0,-1):
            if j>=i[1]:
                k2, b2 = fangcheng2(i[0], i[1], i[2])
                yxia=k2*j+b2
                S1=(i[0]-j)*yxia/2
                if S1==S/2:
                    Y.append(j)
            else:
                break
        for k in range(i[0]):
            if k<=i[1]:
                k1 = fangcheng1(i[1], i[2])
                yshang=k1*k
                S2=k*yshang/2
                if S2==S/2:
                    Y.append(k)
    if i[0]>0 and i[1]<0 and i[2]>0:
        i[1]=abs(i[1])
        k1=fangcheng1(i[1],i[2])
        k2, b2 = fangcheng2(i[0], i[1], i[2])
        print(k2,b2)
        for j in range(i[0],0,-1):
            if j>=i[1]:
                yxia=k2*j+b2
                S1=(i[0]-j)*yxia/2
                if S1==S/2:
                    Y.append(j)
            else:
                break
        for k in range(i[0]):
            if k<=i[1]:
                yshang=k1*k
                S2=k*yshang/2
                if S2==S/2:
                    Y.append(k)
    if Y==[]:
        print('NO')
    else:
        print('YES')
        Y.clear()"
43,C,Python3,61128887,2023-03-08 00:56:01,虚无xw,答案错误,"t=int(input())
for i in range(t):
    oo=0
    xb,xc,yc=map(float,input().split())
    s=xb*yc/2
    s1=s/2
    if xc>xb/2:
        p=yc/xc
        for x in range(1,int(xb)):
            if x*x*p/2==s1:
                print(""YES"")
                oo+=1
                break
    elif xc<xb/2:
        p=yc/(xb-xc)
        for x in range(1,int(xb)):
            if x*x*p/2==s1:
                print(""YES"")
                oo+=1
                break
    elif xc==xb/2:
        print(""YES"")
        oo+=1
    if oo==0:
        print(""NO"")
            
    "
44,C,Python3,61128891,2023-03-08 01:05:58,虚无xw,答案错误,"t=int(input())
for i in range(t):
    oo=0
    xb,xc,yc=map(float,input().split())
    s=xb*yc/2
    s1=s/2
    if xc>xb/2:
        p=yc/xc
        for x in range(1,int(xb)):
            if x*x*p/2==s1:
                print(""YES"")
                oo+=1
                break
    elif xc<xb/2:
        p=yc/(xb-xc)
        for x in range(1,int(xb)):
            if x*x*p/2==s1:
                print(""YES"")
                oo+=1
                break
    elif xc==xb/2:
        print(""YES"")
        oo+=1
    if oo==0:
        print(""NO"")
            
    "
45,C,Python3,61128896,2023-03-08 01:25:09,虚无xw,答案错误,"t=int(input())
for i in range(t):
    oo=0
    xb,xc,yc=map(float,input().split())
    s=xb*yc/2
    s1=s
    if xc>xb/2:
        p=yc/xc
        for x in range(1,int(xb)):
            x=float(x)
            if x*x*p==s1:
                print(""YES"")
                oo+=1
                break
    elif xc<xb/2:
        p=yc/(xb-xc)
        for x in range(1,int(xb)):
            x=float(x)
            if x*x*p==s1:
                print(""YES"")
                oo+=1
                break
    elif xc==xb/2:
        print(""YES"")
        oo+=1
    if oo==0:
        print(""NO"")
            
    "
46,C,Python3,61150262,2023-03-10 00:00:54,阿来想AC,答案错误,"import math
t = int(input())
for i in range(t):
    li = list(map(int,input().split(' ')))
    xb,xc,yc = li[0],li[1],li[2]
    x1 = math.sqrt(0.5*xb*xc)
    if x1<=xc and x1>=0:
        print('YES')
        continue
    x2 = xb-math.sqrt(0.5*xb*(xb-xc))
    if x2>xc and  x2<=xb:
        print(""YES"")
        continue
    print(""NO"")"
47,C,Python3,61150281,2023-03-10 00:06:59,阿来想AC,答案错误,"import math
#Judge whether it is an integer. If it is, return the integer value, otherwise return FALSE
def is_an_integer(num_string):    
    try:                                                  #Judge whether the input is an integer
        int(num_string)
        return int(num_string)
    except ValueError:                                   #Consider 1.000000 integer of floating point type
        Integer_part,Fractional_part = num_string.split('.')       
        if set(Fractional_part) == set('0'):
            return int(Integer_part[0])
    return False
t = int(input())
for i in range(t):
    li = list(map(int,input().split(' ')))
    xb,xc,yc = li[0],li[1],li[2]
    x1 = math.sqrt(0.5*xb*xc)
    if is_an_integer(str(x1)):
        print('YES')
        continue
    x2 = xb-math.sqrt(0.5*xb*(xb-xc))
    if x2>xc :
        print(""YES"")
        continue
    print(""NO"")"
48,C,Python3,61150285,2023-03-10 00:07:44,阿来想AC,答案正确,"import math
#Judge whether it is an integer. If it is, return the integer value, otherwise return FALSE
def is_an_integer(num_string):    
    try:                                                  #Judge whether the input is an integer
        int(num_string)
        return int(num_string)
    except ValueError:                                   #Consider 1.000000 integer of floating point type
        Integer_part,Fractional_part = num_string.split('.')       
        if set(Fractional_part) == set('0'):
            return int(Integer_part[0])
    return False
t = int(input())
for i in range(t):
    li = list(map(int,input().split(' ')))
    xb,xc,yc = li[0],li[1],li[2]
    x1 = math.sqrt(0.5*xb*xc)
    if is_an_integer(str(x1)) and x1<=xc:
        print('YES')
        continue
    x2 = xb-math.sqrt(0.5*xb*(xb-xc))
    if x2>xc and is_an_integer(str(x2)) :
        print(""YES"")
        continue
    print(""NO"")"
49,C,Python3,61150591,2023-03-10 09:04:59,L-李,执行出错,"t = int(input())

for i in range(0, t):
    t = 0
    xb = int(input())
    xc = float(input())
    yc = float(input())
    s = xc * yc / 2.0
    for j in range(1, xb + 1):
        if j <= xc:
            y = j * yc / xc
            s1 = y * j / 2.0
            s2 = s - s1
            if s1 == s2:
                t = 1
        if j > xc:
            y = yc * (xb - j) / (xb - xc)
            s1 = (xb - j) * y / 2.0
            s2 = s - s1
            if s1 == s2:
                t = 1
        if t == 1:
            print(""YES"")
        else:
            print(""NO"")"
50,C,Python3,61173223,2023-03-10 22:44:33,L-李,执行出错,"t = int(input())

for i in range(0, t):
    t = 0
    xb = int(input())
    xc = float(input())
    yc = float(input())
    s = xc * yc / 2.0
    for j in range(1, xb + 1):
        if j <= xc:
            y = j * yc / xc
            s1 = y * j / 2.0
            s2 = s - s1
            if s1 == s2:
                t = 1
        if j > xc:
            y = yc * (xb - j) / (xb - xc)
            s1 = (xb - j) * y / 2.0
            s2 = s - s1
            if s1 == s2:
                t = 1
        if t == 1:
            print(""YES"")
        else:
            print(""NO"")"
51,C,Python3,61173245,2023-03-10 22:45:24,L-李,答案错误,"t = int(input())
for i in range(0, t):
    f = 0
    xb, xc, yc = list(map(int, input().split()))
    s = float(xc * yc * 0.5)
    for j in range(1, xc):
        y = float(j * yc / xc)
        s1 = y * j * 0.5
        s2 = s - s1
        if s1 == s2:
            f = 1
    for k in range(xc, xb + 1):
        y = float(yc * (xb - k) / (xb - xc))
        s1 = (xb - k) * y * 0.5
        s2 = s - s1
        if s1 == s2:
            f = 1
    if f != 1:
        print(""NO"")
    else:
        print(""YES"")
"
52,C,Python3,61280001,2023-03-14 11:27:22,ZhongHaoWang,答案错误,"import sys, collections, math, bisect, heapq, random, functools, io, os, copy
from heapq import *
from io import BytesIO, IOBase
 
sys.setrecursionlimit(100000)
BUFSIZE = 4096
 
mod1,mod2 = 10 ** 15 + 7,998244353
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
 
def rep():
    a = list(map(int, input().split()))
    return a
 
 
def sep():
    a = input().rstrip('\n')
    return a
 
 
def qpow(x, y, mod):
    ans = 1
    while y:
        if y & 1:
            ans *= x
            ans %= mod
        x *= x
        x %= mod
        y >>= 1
    return ans
 
 
def Comb(n, m, p):
    a = (math.factorial(n)) % p
    b = (qpow(math.factorial(m), (p - 2), p)) % p
    c = (qpow(math.factorial(n - m), (p - 2), p)) % p
    return a * b * c % p
 
 
def Lucas(n, m, p):
    if m == 0:
        return 1
    return Comb(n % p, m % p, p) * Lucas(n // p, m // p, p) % p
 
 
class Trie:
    def __init__(self):
        self.trie = {}
 
    def insert(self, word):
        cur = self.trie
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
        if 'end' not in cur:
            cur['end'] = 0
        cur['end'] += 1
 
    def isprefix(self, word):
        cur = self.trie
        for c in word:
            if c not in word:
                return 0
            cur = cur[c]
        if 'end' not in cur:
            return 0
        return cur['end']
 
 
class UnionFind:
    def __init__(self, x) -> None:
        self.uf = [-1] * x
 
    def find(self, x):
        r = x
        while self.uf[x] >= 0:
            x = self.uf[x]
 
        while r != x:
            self.uf[r], r = x, self.uf[r]
        return x
 
    def union(self, x, y):
        ux, uy = self.find(x), self.find(y)
        if ux == uy:
            return
        if self.uf[ux] >= self.uf[uy]:
            self.uf[uy] += self.uf[ux]
            self.uf[ux] = uy
        else:
            self.uf[ux] += self.uf[uy]
            self.uf[uy] = ux
        return
 
    def count(self):
        ans = 0
        for c in self.uf:
            if c < 0 and c != -1:
                ans += 1
        return ans
 
    def valid(self):
        n = len(self.uf)
        for c in range(n):
            if self.uf[c] == -n:
                return True
        return False
 
    def __print__(self):
        return self.uf
 
 
def spfa(x, g, n):
    dis = [float('inf') for i in range(n)]
    dis[x] = 0
    state = [False for i in range(n)]
    state[x] = True
    queue = collections.deque()
    queue.append(x)
    while queue:
        cur = queue.popleft()
        state[cur] = False
        for next_ in g[cur]:
            if dis[next_] > dis[cur] + 1:
                dis[next_] = dis[cur] + 1
                if state[next_] == False:
                    state[next_] = True
                    if queue and dis[queue[0]] > dis[next_]:
                        queue.appendleft(next_)
                    else:
                        queue.append(next_)
    return dis
 
 
def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)
 
 
def lcm(x, y):
    return x * y // gcd(x, y)
 
 
def Topsort(G, deg, n):
    queue = collections.deque()
    #vis = set()
    ans = n
    for i in range(n):
        if deg[i] == 0:
            #vis.add(i)
            queue.append(i)
    while queue:
        ans -= 1
        cur = queue.popleft()
        for next_ in G[cur]:
            deg[next_] -= 1
            if deg[next_] == 0:
                queue.append(next_)
 
    return ans
 
class BinaryIndexTree:
 
    def __init__(self, array: list):
        '''初始化，总时间 O(n)'''
        self._array = [0] + array
        n = len(array)
        for i in range(1, n + 1):
            j = i + (i & -i)
            if j < n + 1:
                self._array[j] += self._array[i]
 
    def lowbit(self, x: int) -> int:
        return x & (-x)
 
    def update(self, idx: int, val: int):
       
        #prev = self.query(idx, idx + 1)    # 计算出原来的值
        idx += 1
        #val -= prev    # val 是要增加的值
        while idx < len(self._array):
            self._array[idx] += val
            idx += self.lowbit(idx)
 
    def query(self, begin: int, end: int) -> int:
        '''返回数组[begin, end) 的和'''
        return self._query(end) - self._query(begin)
 
    def _query(self, idx: int) -> int:
        '''计算数组[0, idx)的元素之和'''
        res = 0
        while idx > 0:
            res += self._array[idx]
            idx -= self.lowbit(idx)
        return res
 
 
def solve():
    xb,xc,yc = map(int,input().split())
    tot = xb * yc / 2
    f = 0
    for x in range(xc + 1):
        left =  (x * x * yc) / (2 * xc)
        #print(x,left,tot)
        if tot - left == left:
            f = 1
            break
    for x in range(xc + 1,xb + 1):
        # k = yc / (xc - xb) b = -(xb * yc) / (xc - xb)
        y = x * yc / (xc - xb) - (xb * yc) / (xc - xb)
        left = (xb - x) * y / 2
        if tot - left == left:
            f = 1
            break
    if f:
        print('YES')
    else:
        print('NO')
    
                
                
            
        
    
        
            
        
                
    
    

if __name__ == '__main__':
   for i in range(int(input())):
       solve()"
53,C,Python3,61280015,2023-03-14 11:30:21,ZhongHaoWang,答案错误,"import sys, collections, math, bisect, heapq, random, functools, io, os, copy
from heapq import *
from io import BytesIO, IOBase
 
sys.setrecursionlimit(100000)
BUFSIZE = 4096
 
mod1,mod2 = 10 ** 15 + 7,998244353
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
 
def rep():
    a = list(map(int, input().split()))
    return a
 
 
def sep():
    a = input().rstrip('\n')
    return a
 
 
def qpow(x, y, mod):
    ans = 1
    while y:
        if y & 1:
            ans *= x
            ans %= mod
        x *= x
        x %= mod
        y >>= 1
    return ans
 
 
def Comb(n, m, p):
    a = (math.factorial(n)) % p
    b = (qpow(math.factorial(m), (p - 2), p)) % p
    c = (qpow(math.factorial(n - m), (p - 2), p)) % p
    return a * b * c % p
 
 
def Lucas(n, m, p):
    if m == 0:
        return 1
    return Comb(n % p, m % p, p) * Lucas(n // p, m // p, p) % p
 
 
class Trie:
    def __init__(self):
        self.trie = {}
 
    def insert(self, word):
        cur = self.trie
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
        if 'end' not in cur:
            cur['end'] = 0
        cur['end'] += 1
 
    def isprefix(self, word):
        cur = self.trie
        for c in word:
            if c not in word:
                return 0
            cur = cur[c]
        if 'end' not in cur:
            return 0
        return cur['end']
 
 
class UnionFind:
    def __init__(self, x) -> None:
        self.uf = [-1] * x
 
    def find(self, x):
        r = x
        while self.uf[x] >= 0:
            x = self.uf[x]
 
        while r != x:
            self.uf[r], r = x, self.uf[r]
        return x
 
    def union(self, x, y):
        ux, uy = self.find(x), self.find(y)
        if ux == uy:
            return
        if self.uf[ux] >= self.uf[uy]:
            self.uf[uy] += self.uf[ux]
            self.uf[ux] = uy
        else:
            self.uf[ux] += self.uf[uy]
            self.uf[uy] = ux
        return
 
    def count(self):
        ans = 0
        for c in self.uf:
            if c < 0 and c != -1:
                ans += 1
        return ans
 
    def valid(self):
        n = len(self.uf)
        for c in range(n):
            if self.uf[c] == -n:
                return True
        return False
 
    def __print__(self):
        return self.uf
 
 
def spfa(x, g, n):
    dis = [float('inf') for i in range(n)]
    dis[x] = 0
    state = [False for i in range(n)]
    state[x] = True
    queue = collections.deque()
    queue.append(x)
    while queue:
        cur = queue.popleft()
        state[cur] = False
        for next_ in g[cur]:
            if dis[next_] > dis[cur] + 1:
                dis[next_] = dis[cur] + 1
                if state[next_] == False:
                    state[next_] = True
                    if queue and dis[queue[0]] > dis[next_]:
                        queue.appendleft(next_)
                    else:
                        queue.append(next_)
    return dis
 
 
def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)
 
 
def lcm(x, y):
    return x * y // gcd(x, y)
 
 
def Topsort(G, deg, n):
    queue = collections.deque()
    #vis = set()
    ans = n
    for i in range(n):
        if deg[i] == 0:
            #vis.add(i)
            queue.append(i)
    while queue:
        ans -= 1
        cur = queue.popleft()
        for next_ in G[cur]:
            deg[next_] -= 1
            if deg[next_] == 0:
                queue.append(next_)
 
    return ans
 
class BinaryIndexTree:
 
    def __init__(self, array: list):
        '''初始化，总时间 O(n)'''
        self._array = [0] + array
        n = len(array)
        for i in range(1, n + 1):
            j = i + (i & -i)
            if j < n + 1:
                self._array[j] += self._array[i]
 
    def lowbit(self, x: int) -> int:
        return x & (-x)
 
    def update(self, idx: int, val: int):
       
        #prev = self.query(idx, idx + 1)    # 计算出原来的值
        idx += 1
        #val -= prev    # val 是要增加的值
        while idx < len(self._array):
            self._array[idx] += val
            idx += self.lowbit(idx)
 
    def query(self, begin: int, end: int) -> int:
        '''返回数组[begin, end) 的和'''
        return self._query(end) - self._query(begin)
 
    def _query(self, idx: int) -> int:
        '''计算数组[0, idx)的元素之和'''
        res = 0
        while idx > 0:
            res += self._array[idx]
            idx -= self.lowbit(idx)
        return res
 
 
def solve():
    xb,xc,yc = map(int,input().split())
    tot = xb * yc / 2
    f = 0
    for x in range(xc + 1):
        left =  (x * x * yc) / (2 * xc)
        #print(x,left,tot)
        if 2 * left == tot:
            f = 1
            break
    for x in range(xc + 1,xb + 1):
        # k = yc / (xc - xb) b = -(xb * yc) / (xc - xb)
        y = x * yc / (xc - xb) - (xb * yc) / (xc - xb)
        left = (xb - x) * y / 2
        if 2 * left == tot:
            f = 1
            break
    if f:
        print('YES')
    else:
        print('NO')
    
if __name__ == '__main__':
   for i in range(int(input())):
       solve()"
54,C,Python3,61280104,2023-03-14 11:41:20,ZhongHaoWang,答案正确,"import sys, collections, math, bisect, heapq, random, functools, io, os, copy
from heapq import *
from io import BytesIO, IOBase
 
sys.setrecursionlimit(100000)
BUFSIZE = 4096
 
mod1,mod2 = 10 ** 15 + 7,998244353
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
 
def rep():
    a = list(map(int, input().split()))
    return a
 
 
def sep():
    a = input().rstrip('\n')
    return a
 
 
def qpow(x, y, mod):
    ans = 1
    while y:
        if y & 1:
            ans *= x
            ans %= mod
        x *= x
        x %= mod
        y >>= 1
    return ans
 
 
def Comb(n, m, p):
    a = (math.factorial(n)) % p
    b = (qpow(math.factorial(m), (p - 2), p)) % p
    c = (qpow(math.factorial(n - m), (p - 2), p)) % p
    return a * b * c % p
 
 
def Lucas(n, m, p):
    if m == 0:
        return 1
    return Comb(n % p, m % p, p) * Lucas(n // p, m // p, p) % p
 
 
class Trie:
    def __init__(self):
        self.trie = {}
 
    def insert(self, word):
        cur = self.trie
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
        if 'end' not in cur:
            cur['end'] = 0
        cur['end'] += 1
 
    def isprefix(self, word):
        cur = self.trie
        for c in word:
            if c not in word:
                return 0
            cur = cur[c]
        if 'end' not in cur:
            return 0
        return cur['end']
 
 
class UnionFind:
    def __init__(self, x) -> None:
        self.uf = [-1] * x
 
    def find(self, x):
        r = x
        while self.uf[x] >= 0:
            x = self.uf[x]
 
        while r != x:
            self.uf[r], r = x, self.uf[r]
        return x
 
    def union(self, x, y):
        ux, uy = self.find(x), self.find(y)
        if ux == uy:
            return
        if self.uf[ux] >= self.uf[uy]:
            self.uf[uy] += self.uf[ux]
            self.uf[ux] = uy
        else:
            self.uf[ux] += self.uf[uy]
            self.uf[uy] = ux
        return
 
    def count(self):
        ans = 0
        for c in self.uf:
            if c < 0 and c != -1:
                ans += 1
        return ans
 
    def valid(self):
        n = len(self.uf)
        for c in range(n):
            if self.uf[c] == -n:
                return True
        return False
 
    def __print__(self):
        return self.uf
 
 
def spfa(x, g, n):
    dis = [float('inf') for i in range(n)]
    dis[x] = 0
    state = [False for i in range(n)]
    state[x] = True
    queue = collections.deque()
    queue.append(x)
    while queue:
        cur = queue.popleft()
        state[cur] = False
        for next_ in g[cur]:
            if dis[next_] > dis[cur] + 1:
                dis[next_] = dis[cur] + 1
                if state[next_] == False:
                    state[next_] = True
                    if queue and dis[queue[0]] > dis[next_]:
                        queue.appendleft(next_)
                    else:
                        queue.append(next_)
    return dis
 
 
def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)
 
 
def lcm(x, y):
    return x * y // gcd(x, y)
 
 
def Topsort(G, deg, n):
    queue = collections.deque()
    #vis = set()
    ans = n
    for i in range(n):
        if deg[i] == 0:
            #vis.add(i)
            queue.append(i)
    while queue:
        ans -= 1
        cur = queue.popleft()
        for next_ in G[cur]:
            deg[next_] -= 1
            if deg[next_] == 0:
                queue.append(next_)
 
    return ans
 
class BinaryIndexTree:
 
    def __init__(self, array: list):
        '''初始化，总时间 O(n)'''
        self._array = [0] + array
        n = len(array)
        for i in range(1, n + 1):
            j = i + (i & -i)
            if j < n + 1:
                self._array[j] += self._array[i]
 
    def lowbit(self, x: int) -> int:
        return x & (-x)
 
    def update(self, idx: int, val: int):
       
        #prev = self.query(idx, idx + 1)    # 计算出原来的值
        idx += 1
        #val -= prev    # val 是要增加的值
        while idx < len(self._array):
            self._array[idx] += val
            idx += self.lowbit(idx)
 
    def query(self, begin: int, end: int) -> int:
        '''返回数组[begin, end) 的和'''
        return self._query(end) - self._query(begin)
 
    def _query(self, idx: int) -> int:
        '''计算数组[0, idx)的元素之和'''
        res = 0
        while idx > 0:
            res += self._array[idx]
            idx -= self.lowbit(idx)
        return res
 
 
def solve():
    xb,xc,yc = map(int,input().split())
    
    f = 0
    for x in range(xc + 1):
        if 2 * x * x == xb * xc:
            f = 1
            break
    for x in range(xc + 1,xb + 1):
        if 2 * x * x == (xb - xc) * xb:
            f = 1
            break
       
    if f:
        print('YES')
    else:
        print('NO')
    
if __name__ == '__main__':
   for i in range(int(input())):
       solve()"
