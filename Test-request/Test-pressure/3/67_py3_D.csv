,index,languageName,submissionId,submitTime,userName,statusMessage,code
0,D,Python3,60967857,2023-02-24 19:18:22,书生alin,运行超时,"m, q = map(int, input().split())
lis = []
for i in range(q):
    safe = []
    op, num = map(int, input().split())
    if op == 1:
        lis.append(num)
    else:
        lis[lis.index(num)] = -1
    for j in range(1, m+1):
        a = j+3
        b = j-3
        if a <= 0 or a>m:
            a = -10
        if b<=0 or b>m:
            b=-10
        if (a in lis) or (b in lis):
            safe.append(j)
    print(len(safe))
        
    "
1,D,Python3,60968289,2023-02-24 19:23:02,GHOSTANDBREAD,答案正确,"import sys
a = [0] * 100010
m, q = map(int, sys.stdin.readline().split())

ans = 0
for _ in range(q):
    op, num = map(int, sys.stdin.readline().split())
    if op == 1:
        tmp1 = num - 3; tmp2 = num + 3
        if tmp1 >= 1 and tmp1 <= m:
            if a[tmp1] == 0: ans += 1
            a[tmp1] += 1
        if tmp2 >= 1 and tmp2 <= m:
            if a[tmp2] == 0: ans += 1
            a[tmp2] += 1
        print(ans)
    elif op == 2:
        tmp1 = num - 3; tmp2 = num + 3
        if tmp1 >= 1 and tmp1 <= m:
            if a[tmp1] - 1 == 0: ans -= 1
            a[tmp1] -= 1
        if tmp2 >= 1 and tmp2 <= m:
            if a[tmp2] - 1 == 0: ans -= 1
            a[tmp2] -= 1
        print(ans)
        
        
        
        "
2,D,Python3,60968638,2023-02-24 19:26:30,456117,答案正确,"import sys
a = [0] * 100010
m, q = map(int, sys.stdin.readline().split())

ans = 0
for _ in range(q):
    op, num = map(int, sys.stdin.readline().split())
    if op == 1:
        tmp1 = num - 3; tmp2 = num + 3
        if tmp1 >= 1 and tmp1 <= m:
            if a[tmp1] == 0: ans += 1
            a[tmp1] += 1
        if tmp2 >= 1 and tmp2 <= m:
            if a[tmp2] == 0: ans += 1
            a[tmp2] += 1
        print(ans)
    elif op == 2:
        tmp1 = num - 3; tmp2 = num + 3
        if tmp1 >= 1 and tmp1 <= m:
            if a[tmp1] - 1 == 0: ans -= 1
            a[tmp1] -= 1
        if tmp2 >= 1 and tmp2 <= m:
            if a[tmp2] - 1 == 0: ans -= 1
            a[tmp2] -= 1
        print(ans)
        
        
        
        "
3,D,Python3,60969433,2023-02-24 19:35:32,zxcv0112358,运行超时,"m,q=map(int,input().split())

from collections import defaultdict
d = defaultdict(int)
# d=dict()



for qcase in range(0,q,1):
    op,num=map(int,input().split())
    if op==1:
        if num not in d:
            d[num]=1
        else:
            d[num]+=1
    elif op==2:
        if num not in d:
            d[num]=-1
        else:
            d[num]-=1
    s=set()
    for key in d:
        if d[key]>0:
            if key+3<=m:
                s.add(key+3)
            if key-3>=1:
                s.add(key-3)
#     print(s)
    print(len(s))
        "
4,D,Python3,60969464,2023-02-24 19:35:52,牛客481337953号,答案正确,"c = 0
m, n = map(int, input().split())
d = [0] * (m + 3)
for _ in range(n):
    a, b = map(int, input().split())
    l, r = b - 3, b + 3
    if a == 1:
        if l >= 1:
            if d[l] == 0:
                c += 1
            d[l] += 1
        if r <= m:
            if d[r] == 0:
                c += 1
            d[r] += 1
    else:
        if l >= 1:
            if d[l] == 1:
                c -= 1
            d[l] -= 1
        if r <= m:
            if d[r] == 1:
                c -= 1
            d[r] -= 1
    print(c)"
5,D,Python3,60969550,2023-02-24 19:37:00,zxcv0112358,运行超时,"m,q=map(int,input().split())

from collections import defaultdict
d = defaultdict(int)
# d=dict()



for qcase in range(0,q,1):
    op,num=map(int,input().split())
    if op==1:
        if num not in d:
            d[num]=1
        else:
            d[num]+=1
    elif op==2:
        if num not in d:
            d[num]=-1
        else:
            d[num]-=1
    s=set()
    for key in d:
        if d[key]>0:
            if key+3<=m:
                s.add(key+3)
            if key-3>=1:
                s.add(key-3)
#     print(s)
    print(len(s))
        "
6,D,Python3,60969947,2023-02-24 19:41:19,zxcv0112358,运行超时,"m,q=map(int,input().split())

from collections import defaultdict
d = defaultdict(int)
# d=dict()



for qcase in range(0,q,1):
    op,num=map(int,input().split())
    if(op==1):
        if  num+3<=m:
            d[num+3]+=1
        if  num-3>=1:
            d[num-3]+=1
    if(op==2):
        if d[num-3]==1:
            d.pop(num-3)
        else:
            d[num-3]-=1
        if d[num+3]==1:
            d.pop(num+3)
        else:
            d[num+3]-=1
#     print(d.keys())
    print(len(d.keys()))"
7,D,Python3,60970091,2023-02-24 19:42:58,zxcv0112358,运行超时,"m,q=map(int,input().split())

from collections import defaultdict
d = defaultdict(int)
# d=dict()



for qcase in range(0,q,1):
    op,num=map(int,input().split())
    if(op==1):
        if  num+3<=m:
            d[num+3]+=1
        if  num-3>=1:
            d[num-3]+=1
    if(op==2):
        if d[num-3]==1:
            d.pop(num-3)
        else:
            d[num-3]-=1
        if d[num+3]==1:
            d.pop(num+3)
        else:
            d[num+3]-=1
#     print(d.keys())
    print(len(d.keys()))"
8,D,Python3,60970237,2023-02-24 19:44:47,zxcv0112358,执行出错,"m,q=map(int,input().split())

from collections import defaultdict
d = defaultdict(int)
# d=dict()



for qcase in range(0,q,1):
    op,num=map(int,input().split())
    if(op==1):
        if  num+3<=m:
            d[num+3]+=1
        if  num-3>=1:
            d[num-3]+=1
    if(op==2):
        if d[num-3]==1:
            d.pop(num-3)
        else:
            d[num-3]-=1
        if d[num+3]==1:
            d.pop(num+3)
        else:
            d[num+3]-=1
#     print(d.keys())
#     print(len(d.keys()))
      print(1)"
9,D,Python3,60970266,2023-02-24 19:45:13,KevinSo,答案正确,"v = [0] * 200005

def add(x, n):
    if x < 1 or x > n:
        return 0
    v[x] += 1
    if v[x] == 1:
        return 1
    return 0

def suf(x, n):
    if x < 1 or x > n:
        return 0
    v[x] -= 1
    if v[x] == 0:
        return 1
    return 0
    
if __name__ == ""__main__"":
    ans = 0
    n, q = map(int, input().split())
    while q > 0:
        q -= 1
        a, b = map(int, input().split())
        if a == 1:
            ans += add(b + 3, n)
            ans += add(b - 3, n)
        else:
            ans -= suf(b + 3, n)
            ans -= suf(b - 3, n)
        print(ans)
            "
10,D,Python3,60970278,2023-02-24 19:45:24,zxcv0112358,答案错误,"m,q=map(int,input().split())

from collections import defaultdict
d = defaultdict(int)
# d=dict()



for qcase in range(0,q,1):
    op,num=map(int,input().split())
    if(op==1):
        if  num+3<=m:
            d[num+3]+=1
        if  num-3>=1:
            d[num-3]+=1
    if(op==2):
        if d[num-3]==1:
            d.pop(num-3)
        else:
            d[num-3]-=1
        if d[num+3]==1:
            d.pop(num+3)
        else:
            d[num+3]-=1
    print(1)
#     print(d.keys())
#     print(len(d.keys()))"
11,D,Python3,60971106,2023-02-24 19:56:04,Fei_xiangShi,运行超时,"m,q = map(int,input().split())
paihe = []
safe = []
for _ in range(q):
    op, num = map(int,input().split())
    if op == 1:
        safe.append(num+3)
        safe.append(num-3)
    else:
        safe.remove(num+3)
        safe.remove(num-3)
    print(len(set([x for x in safe if x > 0 and x <= m])))"
12,D,Python3,60971813,2023-02-24 20:05:18,謝拾叁,答案正确,"m,q = map(int,input().split())
book = [0 for i in range(m+100)]
cnt = 0
for i in range(q):
    op,num = map(int,input().split())
    for j in [num-3,num+3]:
        if j > m or j < 1:
            continue
        if op == 1:
            if book[j] == 0:
                cnt += 1
            book[j] += 1
        else:
            if book[j] == 1:
                cnt -= 1
            book[j] -= 1
    print(cnt)

    "
13,D,Python3,60972089,2023-02-24 20:08:37,牛客632869927号,答案正确,"

if __name__ == '__main__':
    m, q = map(int, input().split(' '))
    cards = {}
    for _ in range(q):
        op, num = map(int, input().split(' '))
        if op == 1:
            if num - 3 >= 1:
                cards[num - 3] = cards.get(num - 3, 0) + 1
            if num + 3 <= m:
                cards[num + 3] = cards.get(num + 3, 0) + 1
        else:
            if num - 3 >= 1:
                cards[num - 3] = cards.get(num - 3, 0) - 1
                if cards[num - 3] <= 0:
                    del cards[num - 3]
            if num + 3 <= m:
                cards[num + 3] = cards.get(num + 3, 0) - 1
                if cards[num + 3] <= 0:
                    del cards[num + 3]
        print(len(cards))

            "
14,D,Python3,60973197,2023-02-24 20:24:09,牛客545811652号,运行超时,"m,p=map(int,input().split())
a=[]
b=[]
c=[]
for i in range(1,m+1):
    a.append(i)
for i in range(p):
    caozuo=list(map(int,input().split()))
    c.append(caozuo)
for i in c:

    if i[0]==1:
        b.append(i[1])
    elif i[0]==2:
        b.remove(i[1])
    count=0
    for j in a:
        if j-3 in b:
            count+=1
        elif j+3 in b:
            count+=1
    print(count)"
15,D,Python3,60973221,2023-02-24 20:24:37,牛客545811652号,运行超时,"m,p=map(int,input().split())
a=[]
b=[]
c=[]
for i in range(1,m+1):
    a.append(i)
for i in range(p):
    caozuo=list(map(int,input().split()))
    c.append(caozuo)
for i in c:

    if i[0]==1:
        b.append(i[1])
    elif i[0]==2:
        b.remove(i[1])
    count=0
    for j in a:
        if j-3 in b:
            count+=1
        elif j+3 in b:
            count+=1
    print(count)"
16,D,Python3,60973236,2023-02-24 20:24:59,牛客545811652号,运行超时,"m,p=map(int,input().split())
a=[]
b=[]
c=[]
for i in range(1,m+1):
    a.append(i)
for i in range(p):
    caozuo=list(map(int,input().split()))
    c.append(caozuo)
for i in c:

    if i[0]==1:
        b.append(i[1])
    elif i[0]==2:
        b.remove(i[1])
    count=0
    for j in a:
        if j-3 in b:
            count+=1
        elif j+3 in b:
            count+=1
    print(count)"
17,D,Python3,60973445,2023-02-24 20:28:05,牛客616043488号,运行超时,"m,p=map(int,input().split())
a=[]
b=[]
c=[]
for i in range(1,m+1):
    a.append(i)
for i in range(p):
    caozuo=list(map(int,input().split()))
    c.append(caozuo)
for i in c:

    if i[0]==1:
        b.append(i[1])
    elif i[0]==2:
        b.remove(i[1])
    count=0
    for j in a:
        if j-3 in b:
            count+=1
        elif j+3 in b:
            count+=1
    print(count)"
18,D,Python3,60973468,2023-02-24 20:28:30,牛客616043488号,运行超时,"m,p=map(int,input().split())
a=[]
b=[]
c=[]
for i in range(1,m+1):
    a.append(i)
for i in range(p):
    caozuo=list(map(int,input().split()))
    c.append(caozuo)
for i in c:

    if i[0]==1:
        b.append(i[1])
    elif i[0]==2:
        b.remove(i[1])
    count=0
    for j in a:
        if j-3 in b:
            count+=1
        elif j+3 in b:
            count+=1
    print(count)"
19,D,Python3,60973492,2023-02-24 20:28:49,牛客396138626号,运行超时,"m,q = map(int,input().split())
s = list(range(1,m))
l = []
for _ in range(q):
    op,num = map(int,input().split())
    if op==1:
        l.append(num)
    else:
        l.remove(num)
    t =set()
    for i in l:
        a = i-3
        b = i+3
        if a in s:
            t.add(a)
        if b in s:
            t.add(b)
    print(len(t))"
20,D,Python3,60973505,2023-02-24 20:29:01,牛客616043488号,运行超时,"m,p=map(int,input().split())
a=[]
b=[]
c=[]
for i in range(1,m+1):
    a.append(i)
for i in range(p):
    caozuo=list(map(int,input().split()))
    c.append(caozuo)
for i in c:

    if i[0]==1:
        b.append(i[1])
    elif i[0]==2:
        b.remove(i[1])
    count=0
    for j in a:
        if j-3 in b:
            count+=1
        elif j+3 in b:
            count+=1
    print(count)"
21,D,Python3,60973523,2023-02-24 20:29:17,牛客396138626号,运行超时,"m,q = map(int,input().split())
s = list(range(1,m+1))
l = []
for _ in range(q):
    op,num = map(int,input().split())
    if op==1:
        l.append(num)
    else:
        l.remove(num)
    t =set()
    for i in l:
        a = i-3
        b = i+3
        if a in s:
            t.add(a)
        if b in s:
            t.add(b)
    print(len(t))"
22,D,Python3,60973606,2023-02-24 20:30:45,牛客396138626号,运行超时,"m,q = map(int,input().split())
s = list(range(1,m+1))
l = []
for _ in range(q):
    op,num = map(int,input().split())
    if op==1:
        l.append(num)
    else:
        l.remove(num)
    t =set()
    for i in l:
        a = i-3
        b = i+3
        if a in s:
            t.add(a)
        if b in s:
            t.add(b)
    print(len(t))"
23,D,Python3,60973770,2023-02-24 20:33:46,aaaacme,运行超时,"def safe(m,card:list):
    sc=[]
    for i in range(len(card)):
        if card[i]-3>=1 and card[i]+3<=m:
            sc.append(card[i]-3)
            sc.append(card[i]+3)
        elif card[i]-3>=1:
            sc.append(card[i]-3)
        elif card[i]+3<=m:
            sc.append(card[i]+3)
    sc_res=[]
    for i in sc:
        if i not in sc_res:
            sc_res.append(i)
    return len(sc_res)
m,q=input().split()
m=int(m)
q=int(q)
scc=[]
for _ in range(q):
    op,num=input().split()
    op=int(op)
    num=int(num)
    if op==1:
        scc.append(num)
    else:
        scc.remove(num)
    print(safe(m,scc))"
24,D,Python3,60973895,2023-02-24 20:35:45,aaaacme,运行超时,"def safe(m,card:list):
    sc=[]
    for i in range(len(card)):
        if card[i]-3>=1 and card[i]+3<=m:
            sc.append(card[i]-3)
            sc.append(card[i]+3)
        elif card[i]-3>=1:
            sc.append(card[i]-3)
        elif card[i]+3<=m:
            sc.append(card[i]+3)
    sc_res=[]
    for i in sc:
        if i not in sc_res:
            sc_res.append(i)
    return len(sc_res)
m,q=input().split()
m=int(m)
q=int(q)
scc=[]
for _ in range(q):
    op,num=input().split()
    op=int(op)
    num=int(num)
    if op==1:
        scc.append(num)
    else:
        scc.remove(num)
    print(safe(m,scc))"
25,D,Python3,60973999,2023-02-24 20:37:28,牛客396138626号,运行超时,"m,q = map(int,input().split())
s = list(range(1,m+1))
l = []
for i in range(q):
    op,num = map(int,input().split())
    if op==1:
        l.append(num)
    else:
        l.remove(num)
    t =set()
    for j in l:
        a = j-3
        b = j+3
        if a in s:
            t.add(a)
        if b in s:
            t.add(b)
    print(len(t))"
26,D,Python3,60974189,2023-02-24 20:41:04,真的离谱,运行超时,"m,q=map(int,input().split())
ls=[]
for i in range(q):
    kp=[]
    res=0
    a,b=map(int,input().split())
    if(a==1):
        ls.append(b)
    else:
        ls.remove(b)
    k=list(set(ls))
    for i in range(len(k)):
        if(k[i]-3>=1 and ((k[i]-3) not in kp)):
            res+=1
            kp.append(k[i]-3)
        if(k[i]+3<=m and ((k[i]+3) not in kp)):
            res+=1
            kp.append(k[i]+3)
    print(res)
            
        "
27,D,Python3,60974830,2023-02-24 20:50:46,aaaacme,运行超时,"def safe(m,card:list):
    sc=[]
    for i in range(len(card)):
        if card[i]-3>=1:
            sc.append(card[i]-3)
        if card[i]+3<=m:
            sc.append(card[i]+3)
    sc.sort()
    slow=0
    fast=0
    while fast<len(sc):
        if sc[fast]!=sc[slow]:
            slow+=1
            sc[slow]=sc[fast]
        fast+=1
    return slow+1
m,q=input().split()
m=int(m)
q=int(q)
scc=[]
for _ in range(q):
    op,num=input().split()
    op=int(op)
    num=int(num)
    if op==1:
        scc.append(num)
    else:
        scc.remove(num)
    print(safe(m,scc))"
28,D,Python3,60974834,2023-02-24 20:50:52,aaaacme,运行超时,"def safe(m,card:list):
    sc=[]
    for i in range(len(card)):
        if card[i]-3>=1:
            sc.append(card[i]-3)
        if card[i]+3<=m:
            sc.append(card[i]+3)
    sc.sort()
    slow=0
    fast=0
    while fast<len(sc):
        if sc[fast]!=sc[slow]:
            slow+=1
            sc[slow]=sc[fast]
        fast+=1
    return slow+1
m,q=input().split()
m=int(m)
q=int(q)
scc=[]
for _ in range(q):
    op,num=input().split()
    op=int(op)
    num=int(num)
    if op==1:
        scc.append(num)
    else:
        scc.remove(num)
    print(safe(m,scc))"
29,D,Python3,60975023,2023-02-24 20:53:54,真的离谱,运行超时,"m,q=map(int,input().split())
ls=[]
for i in range(q):
    kp=[]
    res=0
    a,b=map(int,input().split())
    if(a==1):
        ls.append(b)
    else:
        ls.remove(b)
    k=list(set(ls))
    for i in range(len(k)):
        if(k[i]-3>=1):
            res+=1
        if(k[i]+3<=m):
            res+=1
    for i in k:
        if((i+6) in ls):
            res-=1
    print(res)
            
        "
30,D,Python3,60975060,2023-02-24 20:54:26,牛客396138626号,运行超时,"m,q = map(int,input().split())
s = list(range(1,m+1))
l = []
for i in range(q):
    op,num = map(int,input().split())
    if op==1:
        l.append(num)
    else:
        l.remove(num)
    t =set()
    for j in l:
        a = j-3
        b = j+3
        if a in s:
            t.add(a)
        if b in s:
            t.add(b)
    print(len(t))"
31,D,Python3,60975951,2023-02-24 21:12:10,真的离谱,答案正确,"m,q = map(int,input().split())
book = [0 for i in range(m+100)]
cnt = 0
for i in range(q):
    op,num = map(int,input().split())
    #拿到数直接判
    for j in [num-3,num+3]:
        if j > m or j < 1:
            continue
            #加入
        if op == 1:
            #判断该数是否使用过
            if book[j] == 0:
                cnt += 1
            book[j] += 1
            #抛出
        else:
            if book[j] == 1:
                cnt -= 1
            book[j] -= 1
    print(cnt)

    
            
        "
32,D,Python3,60980606,2023-02-25 12:05:13,大大业,答案正确,"m, q = map(int, input().split())
check = [0 for _ in range(100010)]
ans = 0

def _add(num):
    global ans
    if num < 1 or num > m:
        return
    check[num] += 1
    if check[num] == 1:
        ans += 1

def _del(num):
    global ans
    if num < 1 or num > m:
        return
    check[num] -= 1
    if check[num] == 0:
        ans -= 1

while q > 0:
    q -= 1
    op, num = map(int, input().split())
    if op == 1:
        _add(num+3)
        _add(num-3)
    else:
        _del(num+3)
        _del(num-3)
    print(ans)"
33,D,Python3,60987925,2023-02-25 21:51:44,真的离谱,答案正确,"m,q = map(int,input().split())
book = [0 for i in range(m+10)]
cnt = 0
for i in range(q):
    op,num = map(int,input().split())
    #拿到数直接判
    for j in [num-3,num+3]:
        if j > m or j < 1:
            continue
            #加入
        if op == 1:
            #判断该数是否使用过
            if book[j] == 0:
                cnt += 1
            book[j] += 1
            #抛出
        else:
            if book[j] == 1:
                cnt -= 1
            book[j] -= 1
    print(cnt)

    
            
        "
34,D,Python3,60999141,2023-02-26 21:12:53,许大大1,运行超时,"m,q = map(int,input().split())
c = []
t = 0
for i in range(q):
    a,b = map(int,input().split())
    if a == 1:
        c.append(b)    
    elif a==2:
        c.remove(b)
    for j in range(1,m+1):
            if j+3 in c:
                t+=1
            elif j-3 in c:
                t+=1
    print(t)
    t = 0"
35,D,Python3,60999169,2023-02-26 21:13:48,许大大1,运行超时,"m,q = map(int,input().split())
c = []
t = 0
for i in range(q):
    a,b = map(int,input().split())
    if a == 1:
        c.append(b)    
    elif a==2:
        c.remove(b)
    for j in range(1,m+1):
            if j+3 in c:
                t+=1
            elif j-3 in c:
                t+=1
    print(t)
    t = 0"
36,D,Python3,60999170,2023-02-26 21:13:55,许大大1,运行超时,"m,q = map(int,input().split())
c = []
t = 0
for i in range(q):
    a,b = map(int,input().split())
    if a == 1:
        c.append(b)    
    elif a==2:
        c.remove(b)
    for j in range(1,m+1):
            if j+3 in c:
                t+=1
            elif j-3 in c:
                t+=1
    print(t)
    t = 0"
37,D,Python3,61011035,2023-02-28 12:56:11,陈立03,答案正确,"m,q = map(int,input().split())
book = [0 for i in range(m+10)]
cnt = 0
for i in range(q):
    op,num = map(int,input().split())
    #拿到数直接判安全牌
    for j in [num-3,num+3]:
        if j > m or j < 1:
            continue
            #加入
        if op == 1:
            #判断该数是否使用过
            if book[j] == 0:
                cnt += 1
            book[j] += 1
            #抛出
        else:
            if book[j] == 1:
                cnt -= 1
            book[j] -= 1
    print(cnt)
"
38,D,Python3,61034821,2023-03-02 00:20:31,AsunaTaisiki,运行超时,"m, q = map(int, input().split())
a = [0] * (m + 10)
cnt = [0] * (m + 10)
while q > 0 :
    op, num = map(int, input().split())
    if op == 1 :
        cnt[num] = cnt[num] + 1
        if num - 3 >= 1 :
            a[num - 3] = a[num - 3] + 1
        a[num + 3] = a[num + 3] + 1
    else :
        if num - 3 >= 1 :
            a[num - 3] = a[num - 3] - 1
        a[num + 3] = a[num + 3] - 1
    ans = 0
    for i in range(1, m + 1) :
        if a[i] >= 1 :
            #print(i, end = "" ****** "")
            ans = ans + 1
    print(ans)
    q = q - 1"
39,D,Python3,61034838,2023-03-02 00:29:45,AsunaTaisiki,答案正确,"m, q = map(int, input().split())
a = [0] * (m + 10)
ans = 0
while q > 0 :
    op, num = map(int, input().split())
    if op == 1 :
        if num - 3 >= 1 :
            if a[num - 3] == 0 :
                ans += 1
            a[num - 3] = a[num - 3] + 1
        if num + 3 <= m :
            if a[num + 3] == 0 :
                ans += 1
            a[num + 3] = a[num + 3] + 1
        
    else :
        if num - 3 >= 1 :
            a[num - 3] = a[num - 3] - 1
            if a[num - 3] == 0 :
                ans -= 1
        if num + 3 <= m :
            a[num + 3] = a[num + 3] - 1
            if a[num + 3] == 0 :
                ans -= 1
    print(ans)
    q = q - 1"
40,D,Python3,61128817,2023-03-08 00:14:46,虚无xw,运行超时,"m, q = map(int, input().split())
a = [0] * (m + 10)
cnt = [0] * (m + 10)
while q > 0 :
    op, num = map(int, input().split())
    if op == 1 :
        cnt[num] = cnt[num] + 1
        if num - 3 >= 1 :
            a[num - 3] = a[num - 3] + 1
        a[num + 3] = a[num + 3] + 1
    else :
        if num - 3 >= 1 :
            a[num - 3] = a[num - 3] - 1
        a[num + 3] = a[num + 3] - 1
    ans = 0
    for i in range(1, m + 1) :
        if a[i] >= 1 :
            ans = ans + 1
    print(ans)
    q = q - 1"
41,D,Python3,61128840,2023-03-08 00:20:00,虚无xw,答案正确,"m,q = map(int,input().split())
book = [0 for i in range(m+10)]
cnt = 0
for i in range(q):
    op,num = map(int,input().split())
    for j in [num-3,num+3]:
        if j > m or j < 1:
            continue
        if op == 1:
            if book[j] == 0:
                cnt += 1
            book[j] += 1
        else:
            if book[j] == 1:
                cnt -= 1
            book[j] -= 1
    print(cnt)"
42,D,Python3,61150162,2023-03-09 23:45:23,阿来想AC,运行超时,"m,q = input().split(' ')
m,q = int(m),int(q)
river = []
for i in range(q):
    result = []
    op,num = input().split(' ')
    if op == '1':
        river.append(int(num))
    if op == '2':
        river.remove(int(num))
    for i in river:
        if i+3<=m:
            result.append(i+3)
        if i-3>0:
            result.append(i-3)
    print(len(set(result)))"
43,D,Python3,61150291,2023-03-10 00:08:49,阿来想AC,答案正确,"m,q = map(int,input().split())
book = [0 for i in range(m+10)]
cnt = 0
for i in range(q):
    op,num = map(int,input().split())
    #拿到数直接判安全牌
    for j in [num-3,num+3]:
        if j > m or j < 1:
            continue
            #加入
        if op == 1:
            #判断该数是否使用过
            if book[j] == 0:
                cnt += 1
            book[j] += 1
            #抛出
        else:
            if book[j] == 1:
                cnt -= 1
            book[j] -= 1
    print(cnt)
"
44,D,Python3,61280122,2023-03-14 11:43:46,ZhongHaoWang,运行超时,"import sys, collections, math, bisect, heapq, random, functools, io, os, copy
from heapq import *
from io import BytesIO, IOBase
 
sys.setrecursionlimit(100000)
BUFSIZE = 4096
 
mod1,mod2 = 10 ** 15 + 7,998244353
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
 
def rep():
    a = list(map(int, input().split()))
    return a
 
 
def sep():
    a = input().rstrip('\n')
    return a
 
 
def qpow(x, y, mod):
    ans = 1
    while y:
        if y & 1:
            ans *= x
            ans %= mod
        x *= x
        x %= mod
        y >>= 1
    return ans
 
 
def Comb(n, m, p):
    a = (math.factorial(n)) % p
    b = (qpow(math.factorial(m), (p - 2), p)) % p
    c = (qpow(math.factorial(n - m), (p - 2), p)) % p
    return a * b * c % p
 
 
def Lucas(n, m, p):
    if m == 0:
        return 1
    return Comb(n % p, m % p, p) * Lucas(n // p, m // p, p) % p
 
 
class Trie:
    def __init__(self):
        self.trie = {}
 
    def insert(self, word):
        cur = self.trie
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
        if 'end' not in cur:
            cur['end'] = 0
        cur['end'] += 1
 
    def isprefix(self, word):
        cur = self.trie
        for c in word:
            if c not in word:
                return 0
            cur = cur[c]
        if 'end' not in cur:
            return 0
        return cur['end']
 
 
class UnionFind:
    def __init__(self, x) -> None:
        self.uf = [-1] * x
 
    def find(self, x):
        r = x
        while self.uf[x] >= 0:
            x = self.uf[x]
 
        while r != x:
            self.uf[r], r = x, self.uf[r]
        return x
 
    def union(self, x, y):
        ux, uy = self.find(x), self.find(y)
        if ux == uy:
            return
        if self.uf[ux] >= self.uf[uy]:
            self.uf[uy] += self.uf[ux]
            self.uf[ux] = uy
        else:
            self.uf[ux] += self.uf[uy]
            self.uf[uy] = ux
        return
 
    def count(self):
        ans = 0
        for c in self.uf:
            if c < 0 and c != -1:
                ans += 1
        return ans
 
    def valid(self):
        n = len(self.uf)
        for c in range(n):
            if self.uf[c] == -n:
                return True
        return False
 
    def __print__(self):
        return self.uf
 
 
def spfa(x, g, n):
    dis = [float('inf') for i in range(n)]
    dis[x] = 0
    state = [False for i in range(n)]
    state[x] = True
    queue = collections.deque()
    queue.append(x)
    while queue:
        cur = queue.popleft()
        state[cur] = False
        for next_ in g[cur]:
            if dis[next_] > dis[cur] + 1:
                dis[next_] = dis[cur] + 1
                if state[next_] == False:
                    state[next_] = True
                    if queue and dis[queue[0]] > dis[next_]:
                        queue.appendleft(next_)
                    else:
                        queue.append(next_)
    return dis
 
 
def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)
 
 
def lcm(x, y):
    return x * y // gcd(x, y)
 
 
def Topsort(G, deg, n):
    queue = collections.deque()
    #vis = set()
    ans = n
    for i in range(n):
        if deg[i] == 0:
            #vis.add(i)
            queue.append(i)
    while queue:
        ans -= 1
        cur = queue.popleft()
        for next_ in G[cur]:
            deg[next_] -= 1
            if deg[next_] == 0:
                queue.append(next_)
 
    return ans
 
class BinaryIndexTree:
 
    def __init__(self, array: list):
        '''初始化，总时间 O(n)'''
        self._array = [0] + array
        n = len(array)
        for i in range(1, n + 1):
            j = i + (i & -i)
            if j < n + 1:
                self._array[j] += self._array[i]
 
    def lowbit(self, x: int) -> int:
        return x & (-x)
 
    def update(self, idx: int, val: int):
       
        #prev = self.query(idx, idx + 1)    # 计算出原来的值
        idx += 1
        #val -= prev    # val 是要增加的值
        while idx < len(self._array):
            self._array[idx] += val
            idx += self.lowbit(idx)
 
    def query(self, begin: int, end: int) -> int:
        '''返回数组[begin, end) 的和'''
        return self._query(end) - self._query(begin)
 
    def _query(self, idx: int) -> int:
        '''计算数组[0, idx)的元素之和'''
        res = 0
        while idx > 0:
            res += self._array[idx]
            idx -= self.lowbit(idx)
        return res
 
 
def solve():
    m,q = map(int,input().split())
    vis = set()
    cnt = {}
    for i in range(q):
        op,num = map(int,input().split())
        if op == 1:
            vis.add(num)
            if num not in cnt:
                cnt[num] = 0
            cnt[num] += 1
        else:
            cnt[num] -= 1
            if cnt[num] == 0:
                del cnt[num]
                vis.remove(num)
        tmp = 0
        for j in range(1,m + 1):
            if j - 3 in vis or j + 3 in vis:
                   tmp += 1
        print(tmp)
            

if __name__ == '__main__':
   #for i in range(int(input())):
       solve()"
45,D,Python3,61280148,2023-03-14 11:49:31,ZhongHaoWang,答案正确,"import sys, collections, math, bisect, heapq, random, functools, io, os, copy
from heapq import *
from io import BytesIO, IOBase
 
sys.setrecursionlimit(100000)
BUFSIZE = 4096
 
mod1,mod2 = 10 ** 15 + 7,998244353
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
 
def rep():
    a = list(map(int, input().split()))
    return a
 
 
def sep():
    a = input().rstrip('\n')
    return a
 
 
def qpow(x, y, mod):
    ans = 1
    while y:
        if y & 1:
            ans *= x
            ans %= mod
        x *= x
        x %= mod
        y >>= 1
    return ans
 
 
def Comb(n, m, p):
    a = (math.factorial(n)) % p
    b = (qpow(math.factorial(m), (p - 2), p)) % p
    c = (qpow(math.factorial(n - m), (p - 2), p)) % p
    return a * b * c % p
 
 
def Lucas(n, m, p):
    if m == 0:
        return 1
    return Comb(n % p, m % p, p) * Lucas(n // p, m // p, p) % p
 
 
class Trie:
    def __init__(self):
        self.trie = {}
 
    def insert(self, word):
        cur = self.trie
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
        if 'end' not in cur:
            cur['end'] = 0
        cur['end'] += 1
 
    def isprefix(self, word):
        cur = self.trie
        for c in word:
            if c not in word:
                return 0
            cur = cur[c]
        if 'end' not in cur:
            return 0
        return cur['end']
 
 
class UnionFind:
    def __init__(self, x) -> None:
        self.uf = [-1] * x
 
    def find(self, x):
        r = x
        while self.uf[x] >= 0:
            x = self.uf[x]
 
        while r != x:
            self.uf[r], r = x, self.uf[r]
        return x
 
    def union(self, x, y):
        ux, uy = self.find(x), self.find(y)
        if ux == uy:
            return
        if self.uf[ux] >= self.uf[uy]:
            self.uf[uy] += self.uf[ux]
            self.uf[ux] = uy
        else:
            self.uf[ux] += self.uf[uy]
            self.uf[uy] = ux
        return
 
    def count(self):
        ans = 0
        for c in self.uf:
            if c < 0 and c != -1:
                ans += 1
        return ans
 
    def valid(self):
        n = len(self.uf)
        for c in range(n):
            if self.uf[c] == -n:
                return True
        return False
 
    def __print__(self):
        return self.uf
 
 
def spfa(x, g, n):
    dis = [float('inf') for i in range(n)]
    dis[x] = 0
    state = [False for i in range(n)]
    state[x] = True
    queue = collections.deque()
    queue.append(x)
    while queue:
        cur = queue.popleft()
        state[cur] = False
        for next_ in g[cur]:
            if dis[next_] > dis[cur] + 1:
                dis[next_] = dis[cur] + 1
                if state[next_] == False:
                    state[next_] = True
                    if queue and dis[queue[0]] > dis[next_]:
                        queue.appendleft(next_)
                    else:
                        queue.append(next_)
    return dis
 
 
def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)
 
 
def lcm(x, y):
    return x * y // gcd(x, y)
 
 
def Topsort(G, deg, n):
    queue = collections.deque()
    #vis = set()
    ans = n
    for i in range(n):
        if deg[i] == 0:
            #vis.add(i)
            queue.append(i)
    while queue:
        ans -= 1
        cur = queue.popleft()
        for next_ in G[cur]:
            deg[next_] -= 1
            if deg[next_] == 0:
                queue.append(next_)
 
    return ans
 
class BinaryIndexTree:
 
    def __init__(self, array: list):
        '''初始化，总时间 O(n)'''
        self._array = [0] + array
        n = len(array)
        for i in range(1, n + 1):
            j = i + (i & -i)
            if j < n + 1:
                self._array[j] += self._array[i]
 
    def lowbit(self, x: int) -> int:
        return x & (-x)
 
    def update(self, idx: int, val: int):
       
        #prev = self.query(idx, idx + 1)    # 计算出原来的值
        idx += 1
        #val -= prev    # val 是要增加的值
        while idx < len(self._array):
            self._array[idx] += val
            idx += self.lowbit(idx)
 
    def query(self, begin: int, end: int) -> int:
        '''返回数组[begin, end) 的和'''
        return self._query(end) - self._query(begin)
 
    def _query(self, idx: int) -> int:
        '''计算数组[0, idx)的元素之和'''
        res = 0
        while idx > 0:
            res += self._array[idx]
            idx -= self.lowbit(idx)
        return res
 
 
def solve():
    m,q = map(int,input().split())
    
    #cnt = {}
    safe = set()
    safe_cnt = collections.defaultdict(int)
    for i in range(q):
        op,num = map(int,input().split())
        if op == 1:
            
            if num - 3 >= 1:
                safe.add(num - 3)
                safe_cnt[num - 3] += 1
            if num + 3 <= m:
                safe.add(num + 3)
                safe_cnt[num + 3] += 1
        else:
            if num - 3 >= 1:
                safe_cnt[num - 3] -= 1
                if safe_cnt[num - 3] == 0:
                    safe.remove(num - 3)
                    
            if num + 3 <= m:
                safe_cnt[num + 3] -= 1
                if safe_cnt[num + 3] == 0:
                    safe.remove(num + 3)
            
        
        print(len(safe))
            

if __name__ == '__main__':
   #for i in range(int(input())):
       solve()"
